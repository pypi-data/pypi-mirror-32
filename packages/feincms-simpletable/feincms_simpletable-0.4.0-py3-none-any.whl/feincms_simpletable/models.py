import re

from django import forms
from django.contrib import admin
from django.db import models
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _


class SimpleTable(models.Model):
    """
    SimpleTable model that converts spreadsheet data to html

    Inherit from SimpleTable if you want your models to contain one specific
    table from spreadsheet contents

    If you need feincms content type, use SimpleTableContent
    """

    specification_csv = models.TextField(
        _('Spreadsheet data'),  # 'Текст таблицы из Excel',
        help_text=_(
            'Paste your spreadsheet data from Excel or Calc here'
            ' (Word not supported)'
        ),
        blank=True, null=True)

    specification_html = models.TextField(
        _('Table rendered as html'),
        help_text=_('This field is autogenerated, do not modify it!'),  # 'Это поле генерируется автоматически, не трогать!',
        blank=True, null=True)
    table_headless = models.BooleanField(
        _('Headless?'),
        help_text=_('Displays first row as ordinary row'),
        default=False)
    table_bordered = models.BooleanField(
        _('Bordered?'),
        help_text=_('Display border on all sides of the table and cells'),
        default=False)

    table_striped = models.BooleanField(
        _('Striped?'),
        help_text=_('Add zebra-striping'),
        default=False)
    table_hover = models.BooleanField(
        _('Highlight on hover?'),
        default=False)
    table_responsive = models.BooleanField(
        _('Responsive?'),
        help_text=_(
            'Displays better on mobile devices, '
            'displays as usual on big screens'
        ),
        default=True)
    table_condensed = models.BooleanField(
        _('Condensed?'),
        help_text=_('Makes table more compact in size'),
        default=False)

    class Meta:
        abstract = True
        verbose_name = _('Simple Table')
        verbose_name_plural = _('Simple Tables')

    def parse_table(self, *args, **kwargs):
        try:
            rows = self.specification_csv.split('\n')
            thead_cols = rows[0].split('\t')
            tbody_rows = rows[1:]

            # original table is malformed
            if not tbody_rows or not thead_cols:
                raise ValueError

            # filter any empty or whitespace-filled rows
            tbody_rows = [x for x in tbody_rows if not re.match('^\s*$', x)]

            # split each row string into a list of columns
            for i, v in enumerate(tbody_rows):
                tbody_rows[i] = tbody_rows[i].split('\t')

            table_type = getattr(self, 'type', 'default')

            self.specification_html = render_to_string([
                'content/simpletable/%s.html' % table_type,
                'content/simpletable/default.html',
            ], {
                'table': self,
                'tbody_rows': tbody_rows,
                'thead_cols': thead_cols,
                'table_headless':   self.table_headless,
                'table_striped':    self.table_striped,
                'table_bordered':    self.table_bordered,
                'table_hover':      self.table_hover,
                'table_responsive': self.table_responsive,
                'table_condensed':  self.table_condensed,
            })

        # return empty string in case of failure
        except ValueError:
            self.specification_html = ''


class SimpleTableContent(SimpleTable):
    """
    SimpleTableContent model that converts spreadsheet data to html

    This model is intended to be used as feincms content type. Add as many
    of these as you need to your feincms pages
    """

    class Meta:
        abstract = True
        verbose_name = _('Simple Table')
        verbose_name_plural = _('Simple Tables')

    def save(self, *args, **kwargs):
        SimpleTable.parse_table(self, *args, **kwargs)
        super(SimpleTableContent, self).save(*args, **kwargs)
    save.alters_data = True

    def render(self, **kwargs):
        return self.specification_html

    @classmethod
    def initialize_type(cls, cleanse=None, TYPE_CHOICES=None, **kwargs):

        def to_instance_method(func):
            def func_im(self, *args, **kwargs):
                return func(*args, **kwargs)
            return func_im

        if TYPE_CHOICES is None:
            cls.add_to_class(
                'type',
                models.CharField(
                    _('type'),
                    max_length=20,
                    choices=TYPE_CHOICES,
                    default='default',
                )
            )
        else:
            cls.add_to_class(
                'type',
                models.CharField(
                    _('type'),
                    max_length=20,
                    choices=TYPE_CHOICES,
                    default=TYPE_CHOICES[0][0],
                )
            )
