# Stubs for binfield.binfield (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import typing

class BaseBinFieldMeta: ...
class BaseMeta(type): ...

class BinFieldMeta(BaseMeta, type):
    def __new__(mcs, name: str, bases: typing.Tuple[typing.Type], classdict: typing.Dict) -> BinFieldMeta: ...
    @classmethod
    def __prepare__(mcs, name: str, bases: typing.Tuple[typing.Type], **kwargs) -> typing.Dict: ...
    @classmethod
    def makecls(mcs, name: str, mapping: typing.Optional[typing.Dict]=..., mask: typing.Optional[int]=..., size: typing.Optional[int]=...) -> BinFieldMeta: ...

class BinField(BaseBinFieldMeta):
    def __init__(self, x: typing.Union[int, str]=..., base: int=..., _parent: typing.Optional[typing.Tuple[BinField, int]]=...) -> None: ...
    def __len__(self) -> int: ...
    def __int__(self) -> int: ...
    def __index__(self) -> int: ...
    def __abs__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __iand__(self, other: typing.Any) -> BinField: ...
    def __ior__(self, other: typing.Any) -> BinField: ...
    def __ixor__(self, other: typing.Any) -> BinField: ...
    def __and__(self, other: typing.Any) -> BinField: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __or__(self, other: typing.Any) -> BinField: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __xor__(self, other: typing.Any) -> BinField: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __iadd__(self, other: typing.Any) -> BinField: ...
    def __isub__(self, other: typing.Any) -> BinField: ...
    def __add__(self, other: typing.Any) -> typing.Union[int, BinField]: ...
    def __radd__(self, other: typing.Any) -> typing.Any: ...
    def __sub__(self, other: typing.Any) -> typing.Union[int, BinField]: ...
    def __rsub__(self, other: typing.Any) -> typing.Any: ...
    def __mul__(self, other: typing.Any) -> int: ...
    def __rmul__(self, other: typing.Any) -> typing.Any: ...
    def __lshift__(self, other: typing.Any) -> int: ...
    def __rlshift__(self, other: typing.Any) -> typing.Any: ...
    def __rshift__(self, other: typing.Any) -> int: ...
    def __rrshift__(self, other: typing.Any) -> typing.Any: ...
    def __bool__(self) -> bool: ...
    def __hash__(self): ...
    def __copy__(self) -> BinField: ...
    def __getnewargs__(self) -> typing.Tuple: ...
    def __getitem__(self, item: typing.Union[str, int, slice, typing.Tuple[int, int], typing.List[int]]) -> BinField: ...
    def __setitem__(self, key: typing.Union[str, int, slice, typing.Tuple[int, int], typing.List[int]], value: int) -> None: ...
    def __pretty_str__(self, parser: typing.Any, indent: int, no_indent_start: bool) -> typing.AnyStr: ...
    def __pretty_repr__(self, _: typing.Any, indent: int, no_indent_start: bool) -> typing.AnyStr: ...
    def __dir__(self) -> typing.List[str]: ...

class _Formatter:
    def __init__(self, max_indent: int=..., indent_step: int=..., py2_str: bool=...) -> None: ...
    @property
    def indent_step(self) -> int: ...
    def next_indent(self, indent: int, multiplier: int=...) -> int: ...
    @property
    def max_indent(self) -> int: ...
    def process_element(self, src: BinField, indent: int=..., no_indent_start: bool=...) -> str: ...
    def __call__(self, src: BinField, indent: int=..., no_indent_start: bool=...) -> typing.AnyStr: ...
