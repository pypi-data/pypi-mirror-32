<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style type="text/css">
* {
	touch-action: none;
}
html:-webkit-full-screen {
	background-color: #000;
}
body {
	margin: 0px;
	padding: 0px;
	background-color: #000;
	color: #fff;
	font-family: Arial, Helvetica, sans-serif;
}
div#container {
	margin: 0px;
	padding: 0px;
	position: absolute;
	left: 0px;
	right: 0px;
	top: 0px;
	bottom: 0px;
	overflow: hidden;
	cursor: default;
}
div#subject {
	width: 50em;
	overflow: hidden;
}
.smooth {
	transition: transform linear 0.075s;
}
h1 {
	font-size: 50px;
}
h2 {
	font-size: 40px;
}
p {
	font-size: 25px;
	color: #ccc;
}
b {
	color: #fff;
}
</style>
<script type="text/javascript">
"use strict";
(function() {

/**
 * Scales the subject within the container, encapsulating the math, bounds checking,
 * and DOM elements.
 */
class Transform {
	constructor() {
		this.matrix = [ 1, 0, 0, 1, 0, 0 ];
		this.zoomMode = 0;
		this.matrixPattern = new RegExp(
			'^matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^\\)]+)\\)$'
		);
	}
	/** Get the x value of the subject's top-left corner. */
	get x() {
		return this.matrix[4];
	}
	/** Get the y value of the subject's top-left corner. */
	get y() {
		return this.matrix[5];
	}
	/** Get the subject's zoom factor. */
	get zoom() {
		return this.matrix[0];
	}
	/** Set a new pan and zoom for the subject and apply to the DOM immediately. */
	set(x, y, zoom, useTransition) {
		if (useTransition) {
			subject.classList.add('smooth');
		} else {
			subject.classList.remove('smooth');
		}
		const newWidth = subject.offsetWidth * zoom;
		if (newWidth > container.clientWidth) {
			// Subject cannot be panned past the container's edge.
			if (x > 0) {
				x = 0;
			} else if (x < container.clientWidth - newWidth) {
				x = container.clientWidth - newWidth;
			}
		} else {
			// Center the subject.
			x = (container.clientWidth - newWidth) / 2;
		}

		const newHeight = subject.offsetHeight * zoom;
		if (newHeight > container.clientHeight) {
			// Subject cannot be panned past the container's edge.
			if (y > 0) {
				y = 0;
			} else if (y < container.clientHeight - newHeight) {
				y = container.clientHeight - newHeight;
			}
		} else {
			// Center the subject.
			y = (container.clientHeight - newHeight) / 2;
		}
		this.matrix[0] = zoom;
		this.matrix[3] = zoom;
		this.matrix[4] = x;
		this.matrix[5] = y;
		subject.style.transform = 'matrix(' + this.matrix.join(',') + ')';
	}
	/** Called if the container is resized. */
	checkBounds(useTransition) {
		this.set(this.x, this.y, this.zoom, useTransition);
	}
	/** Zooms into or out of the given page coordinates. */
	zoomAt(x, y, zoomIn, useTransition) {
		let scaleFactor = 1.1;
		if (!zoomIn) {
			scaleFactor = 1 / scaleFactor;
		}
		const newX = x + scaleFactor * (this.x - x);
		const newY = y + scaleFactor * (this.y - y);
		const newZoom = this.zoom * scaleFactor;
		this.set(newX, newY, newZoom, useTransition);
	}
	/** Cycles zoom between Native, Fit, and Fill. */
	autozoom(useTransition) {
		let zoom = null;
		this.zoomMode = (this.zoomMode + 1) % 3;
		if (this.zoomMode === 0) { // Native
			zoom = 1;
		} else if (this.zoomMode === 1) { // Fit
			zoom = Math.min(container.clientWidth / subject.offsetWidth,
							container.clientHeight / subject.offsetHeight);
		} else if (this.zoomMode === 2) { // Fill
			zoom = Math.max(container.clientWidth / subject.offsetWidth,
							container.clientHeight / subject.offsetHeight);
		}
		transform.set(0, 0, zoom, useTransition);
	}
	/** Immediately stops any transition and updates the transformation to the current DOM values. */
	stop() {
		const transformStr = window.getComputedStyle(subject).transform;
		subject.style.transform = transformStr;
		const matrix = this.matrixPattern.exec(transformStr);
		if (matrix) {
			this.matrix[0] = parseFloat(matrix[1]);
			this.matrix[3] = parseFloat(matrix[4]);
			this.matrix[4] = parseFloat(matrix[5]);
			this.matrix[5] = parseFloat(matrix[6]);
		}
	}
}

/** Whether or not debug messages are logged to the console. */
const enableLogging = false;
/** The last known interaction point. */
let pointer = null;
/** The last known distance between the fingers. */
let pointerSpan = 0;
/** Maps each pointer ID to the location where it was last pressed. */
const pointersDown = {};
/** The maximum number of touches that have occurred during a user gesture. */
let maxTouches = 0;
/** Whether the left mouse button is currently being held. */
let isLeftMouseDown = false;
/** Whether the right mouse button is currently being held. */
let isRightMouseDown = false;
/** Whether the down arrow key is currently being held. */
let isDownArrowDown = false;
/** Whether the up arrow key is currently being held. */
let isUpArrowDown = false;
/** Whether an apparent click of the right mouse button should be ignored. */
let cancelRightMouse = false;
/** The scrolling speed while holding the up or down arrows. */
let autoscrollSpeed = 0;
/** The identifier returned by setInterval for autoscrolling. Value is null whenever inactive.*/
let autoscrollIntervalId = null;
/** The div that fills the entire window and contains all other elements. */
const container = document.createElement('div');
/** The object being scaled and panned. Oftentimes this is an image, but not always. */
let subject = null;
/** The singleton instance of the Transform class. */
const transform = new Transform();
/** The timeout handle for the hideCursor function. */
let hideCursorTimeout = null;
/** Whether the cursor is currently hidden. */
let isCursorHidden = false;
window.addEventListener('load', handleWindowLoad);
function handleWindowLoad() {
	container.id = 'container';
	document.body.appendChild(container);
	window.addEventListener('resize', handleWindowResize);
	window.addEventListener('mousedown', handleMouseDown);
	window.addEventListener('mouseup', handleMouseUp);
	window.addEventListener('mousemove', handleMouseMove);
	window.addEventListener('touchstart', handleTouchStart);
	window.addEventListener('touchend', handleTouchEnd);
	window.addEventListener('touchcancel', handleTouchEnd);
	window.addEventListener('touchmove', handleTouchMove);
	window.addEventListener('keydown', handleKeyDown);
	window.addEventListener('keyup', handleKeyUp);
	window.addEventListener('wheel', handleWheel);
	window.addEventListener('contextmenu', handleContextMenu);
	window.addEventListener('hashchange', handleHashChange);
	handleHashChange();
}
function handleWindowResize(event) {
	transform.checkBounds(false);
}
function handleMouseDown(event) {
	event.preventDefault();
	if (event.button === 0) { // Left mouse button
		isLeftMouseDown = true;
		pointer = pointersDown.mouse = {x: event.pageX, y: event.pageY};
	} else if (event.button === 2) { // Right mouse button
		isRightMouseDown = true;
		cancelRightMouse = false;
	}
}
function handleMouseUp(event) {
	event.preventDefault();
	if (event.button === 0) { // Left mouse button
		isLeftMouseDown = false;
		if (Math.abs(event.pageX - pointersDown.mouse.x) <= 5 &&
			Math.abs(event.pageY - pointersDown.mouse.y) <= 5) {
			advancePage();
		}
	} else if (event.button === 1) { // Middle mouse button
		transform.autozoom(true);
	} else if (event.button === 2) { // Right mouse button
		isRightMouseDown = false;
		if (!cancelRightMouse) {
			retreatPage();
		}
	}
}
function handleMouseMove(event) {
	window.clearTimeout(hideCursorTimeout);
	if (isCursorHidden) {
		showCursor();
	}
	hideCursorTimeout = window.setTimeout(hideCursor, 500);
	if (isLeftMouseDown) {
		// Pan the subject.
		event.preventDefault();
		const x = transform.x + (event.pageX - pointer.x);
		const y = transform.y + (event.pageY - pointer.y);
		transform.set(x, y, transform.zoom, false);
		pointer = {x: event.pageX, y: event.pageY};
	}
}
function handleTouchStart(event) {
	event.preventDefault();
	for (const touch of event.changedTouches) {
		log('Finger ' + touch.identifier + ' pressed.');
		pointersDown[touch.identifier] = {x: touch.pageX, y: touch.pageY};
	}
	log('There are now ' + event.touches.length + ' fingers pressed.');
	if (event.touches.length > maxTouches) {
		maxTouches = event.touches.length
	}
	if (event.touches.length == 1) {
		const touch = event.touches[0];
		pointer = {x: touch.pageX, y: touch.pageY};
	} else if (event.touches.length == 2) {
		const center = getCenter(event.touches);
		pointer = {x: center.x, y: center.y};
		pointerSpan = getDistance(event.touches);
	}
}
function handleTouchEnd(event) {
	event.preventDefault();
	for (const touch of event.changedTouches) {
		log('Finger ' + touch.identifier + ' lifted.');
	}
	log('There are now ' + event.touches.length + ' fingers pressed.');
	if (event.touches.length == 0) {
		// All fingers have been removed.
		const touch = event.changedTouches[0];
		if (maxTouches === 1 && !hasTouchMoved(touch)) {
			// A one-finger tap has occurred.
			if (document.webkitFullscreenElement === null) {
				document.documentElement.webkitRequestFullscreen();
			} else {
				if (touch.pageX > container.clientWidth / 4) {
					advancePage();
				} else {
					retreatPage();
				}
			}
		}
		maxTouches = 0;
	} else if (event.touches.length == 1) {
		// One finger has been removed while the other remains.
		const touch = event.changedTouches[0];
		if (!hasTouchMoved(touch)) {
			transform.autozoom(true);
		}
		const activeTouch = event.touches[0];
		pointer = {x: activeTouch.pageX, y: activeTouch.pageY};
	}
}
function handleTouchMove(event) {
	event.preventDefault();
	if (event.touches.length == 1) {
		// Pan the subject.
		const touch = event.touches[0];
		const x = transform.x + (touch.pageX - pointer.x);
		const y = transform.y + (touch.pageY - pointer.y);
		transform.set(x, y, transform.zoom, false);
		pointer = {x: touch.pageX, y: touch.pageY};
	} else if (event.touches.length == 2) {
		// Pan and zoom the subject.
		const center = getCenter(event.touches);
		const span = getDistance(event.touches);
		const scaleFactor = span / pointerSpan;
		// Zoom at point between fingers.
		let newX = center.x + scaleFactor * (transform.x - center.x);
		let newY = center.y + scaleFactor * (transform.y - center.y);
		const newZoom = scaleFactor * transform.zoom;
		// Pan.
		newX += center.x - pointer.x;
		newY += center.y - pointer.y;
		transform.set(newX, newY, newZoom, false);
		pointer = {x: center.x, y: center.y};
		pointerSpan = span;
	}
}
function handleKeyDown(event) {
	if (event.key === 'ArrowDown' && !event.repeat) {
		event.preventDefault();
		isDownArrowDown = true;
		beginAutoscroll();
	} else if (event.key === 'ArrowUp' && !event.repeat) {
		event.preventDefault();
		isUpArrowDown = true;
		beginAutoscroll();
	} else if (event.key === '=' || event.key === '+') {
		event.preventDefault();
		transform.zoomAt(container.clientWidth / 2, container.clientHeight / 2, true, true);
	} else if (event.key === '-') {
		event.preventDefault();
		transform.zoomAt(container.clientWidth / 2, container.clientHeight / 2, false, true);
	} else if (event.key === 'z' || event.key === '0') {
		event.preventDefault();
		transform.autozoom(true);
	}
}
function handleKeyUp(event) {
	if (event.key === 'ArrowDown') {
		event.preventDefault();
		isDownArrowDown = false;
		endAutoscroll();
	} else if (event.key === 'ArrowUp') {
		event.preventDefault();
		isUpArrowDown = false;
		endAutoscroll();
	} else if (event.key === 'ArrowRight' || event.key === ' ') {
		event.preventDefault();
		advancePage();
	} else if (event.key === 'ArrowLeft') {
		event.preventDefault();
		retreatPage();
	}
}
function handleWheel(event) {
	event.preventDefault();
	if (event.ctrlKey || isRightMouseDown) {
		// Zoom on cursor.
		cancelRightMouse = true;
		const zoomIn = event.deltaY < 0;
		transform.zoomAt(event.pageX, event.pageY, zoomIn, true);
	} else {
		// Scroll.
		transform.set(transform.x - event.deltaX, transform.y - event.deltaY, transform.zoom, true);
	}
}
function handleContextMenu(event) {
	event.preventDefault();
}
function handleHashChange() {
	// Load the page indicated by the URL.
	const pageNumber = getPageNumber();
	showPage(pageNumber);
	preloadPage(pageNumber + 1);
}
function hasTouchMoved(touch) {
	return Math.abs(touch.pageX - pointersDown[touch.identifier].x) > 5 ||
		   Math.abs(touch.pageY - pointersDown[touch.identifier].y) > 5;
}
function getPageNumber() {
	if (location.hash.length > 0) {
		return parseInt(location.hash.replace('#',''), 10);
	} else {
		return 0;
	}
}
/** Returns the distance between two touches. */
function getDistance(touches) {
	const deltaX = touches[0].pageX - touches[1].pageX;
	const deltaY = touches[0].pageY - touches[1].pageY;
	return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}
/** Returns the center point between two touches. */
function getCenter(touches) {
	return {
		x: (touches[0].pageX + touches[1].pageX) / 2,
		y: (touches[0].pageY + touches[1].pageY) / 2
	};
}
/** Starts autoscrolling if we're not already autoscrolling. */
function beginAutoscroll() {
	if (autoscrollIntervalId === null) {
		autoscrollSpeed = 0;
		stepAutoScroll();
		autoscrollIntervalId = window.setInterval(stepAutoScroll, 50);
	}
}
/** Scrolls one unit if the up or down arrow key is currently pressed. */
function stepAutoScroll() {
	autoscrollSpeed = Math.min(autoscrollSpeed + 20, 80);
	if (isDownArrowDown) {
		transform.set(transform.x, transform.y - autoscrollSpeed, transform.zoom, true);
	} else if (isUpArrowDown) {
		transform.set(transform.x, transform.y + autoscrollSpeed, transform.zoom, true);
	}
}
/** Stops autoscrolling if the arrow keys are no longer being pressed. */
function endAutoscroll() {
	if (!isDownArrowDown && !isUpArrowDown) {
		window.clearInterval(autoscrollIntervalId);
		autoscrollIntervalId = null;
		transform.stop();
	}
}
/** Advances to the next page of the comic. */
function advancePage() {
	log('Advancing page.');
	const pageNumber = getPageNumber();
	if (pageNumber <= imageUrls.length) {
		location.hash = pageNumber + 1;
	}
}
/** Retreats to the previous page of the comic. */
function retreatPage() {
	log('Retreating page.');
	const pageNumber = getPageNumber();
	if (pageNumber > 0) {
		location.hash = pageNumber - 1;
	}
}
/** Shows page i of the comic, counting from 1. */
function showPage(i) {
	let oldTransform = null;
	if (subject != null) {
		oldTransform = subject.style.transform;
		subject.remove();
	}
	if (i < 1) {
		// Show the instructions.
		subject = htmlToElement(instructions);
		subject.style.transformOrigin = 'left top';
		container.appendChild(subject);
		transform.set(0, 0, transform.zoom, false);
	} else if (i <= imageUrls.length) {
		// Show page i of the comic.
		subject = new Image();
		subject.style.transformOrigin = 'left top';
		if (oldTransform != null) {
			subject.style.transform = oldTransform;
		}
		subject.addEventListener('load', function(event) {
			transform.set(0, 0, transform.zoom, false);
		});
		container.appendChild(subject);
		subject.src = imageUrls[i - 1]; // Pages count from 1.
	} else {
		// Show the end card.
		subject = htmlToElement(theEnd);
		subject.style.transformOrigin = 'left top';
		container.appendChild(subject);
		transform.set(0, 0, transform.zoom, false);
	}
}
/** Preloads the image for page i of the comic, counting from 1. */
function preloadPage(i) {
	if (0 < i && i <= imageUrls.length) {
		new Image().src = imageUrls[i - 1]; // Pages count from 1.
	}
}
/** Hides the mouse cursor. */
function hideCursor() {
	container.style.cursor = 'none';
	isCursorHidden = true;
}
/** Shows the mouse cursor. */
function showCursor() {
	container.style.cursor = 'default';
	isCursorHidden = false;
}
/** Returns an element constructed from a string containing HTML. */
function htmlToElement(html) {
	const template = document.createElement('template');
	template.innerHTML = html.trim();
	return template.content.firstChild;
}
/** Logs to the console if logging is enabled. */
function log(...args) {
	if (enableLogging) {
		console.log(...args);
	}
}

const instructions = `
	<div id="subject">
	<h1>The Magic Comic Reader</h1>
	<h2>Mouse Controls:</h2>
	<p>
	<b>Next Page:</b> Click<br />
	<b>Previous Page:</b> Right-Click<br />
	<b>Scroll:</b> Wheel<br />
	<b>Pan:</b> Click and Drag<br />
	<b>Zoom:</b> Wheel while Holding Right-Click, or Wheel while Holding Ctrl<br />
	<b>Cycle Zoom Between Native, Fit, and Fill:</b> Middle-Click
	</p>
	<h2>Keyboard Controls:</h2>
	<p>
	<b>Next Page:</b> Right Arrow or Space<br />
	<b>Previous Page:</b> Left Arrow<br />
	<b>Scroll:</b> Up and Down Arrows<br />
	<b>Zoom:</b> Plus and Minus<br />
	<b>Cycle Zoom Between Native, Fit, and Fill:</b> Z or 0<br />
	<b>Full Screen:</b> F11
	</p>
	<h2>Touch Controls:</h2>
	<p>
	<b>Next Page:</b> Tap on the Right or Middle<br />
	<b>Previous Page:</b> Tap on the Left<br />
	<b>Pan:</b> Drag<br />
	<b>Zoom:</b> Pinch<br />
	<b>Cycle Zoom Between Native, Fit, and Fill:</b> Two-finger Tap, or Tap while Another Finger Holds<br />
	<b>Full Screen:</b> Tap
	</p>
	<h2>Other:</h2>
	<p>You may use your browser's back and forward buttons and bookmark any page.</p>
	</div>
`;

const theEnd = `
	<div id="subject">
	<h1>The End</h1>
	<p>I hope you enjoyed using <b>The Magic Comic Reader</b></p>
	</div>
`;

/** The pages of the comic. */
const imageUrls = {{imageUrls}};

})();
</script>
</head>
<body>
</body>
</html>
