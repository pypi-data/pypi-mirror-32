#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Created by pat on 4/9/18
"""
.. currentmodule:: modlit.sphinx.ext.modeldoc
.. moduleauthor:: Pat Daburu <pat@daburu.net>

This module contains a Sphinx extension that can be used to generate specialized
documentation for model classes.

:var IMAGES_PATH: a relative path to the `modlit` documentation images
"""
import logging
import os
import uuid
import shutil
from pathlib import Path
from typing import Any, cast, List, Set, Type, Union
from sphinx.ext.autodoc import (
    ClassLevelDocumenter, AttributeDocumenter, ClassDocumenter
)
from sphinx.util.docstrings import prepare_docstring
from sqlalchemy.sql.schema import Column
from sqlalchemy.orm.attributes import InstrumentedAttribute
from titlecase import titlecase
from modlit import __version__ as modlit_version
from .monkeypatch import monkeypatch
from ...base import ModelMixin
from ...model import IS_MODEL_CLASS
from ...meta import (
    ColumnMeta, COLUMN_META_ATTR, TABLE_META_ATTR, Requirement, Usage
)


# Apply monkeypatches.
monkeypatch()


IMAGES_PATH: Path = Path('_static/images/modlit')


def setup(app):
    """
    Set up the Sphinx extension.

    :param app: the Sphinx environment.
    """
    # type: (Sphinx) -> Dict[unicode, Any]
    app.add_autodocumenter(ModelClassDocumenter)
    app.add_autodocumenter(ColumnAttributeDocumenter)
    app.connect('autodoc-process-docstring', no_namedtuple_attrib_docstring)
    return {'version': modlit_version, 'parallel_read_safe': True}


# pylint: disable=too-many-locals
class ModelClassDocumenter(ClassDocumenter):
    """
    This is a specialized Documenter subclass for classes.  It overrides the
    parent class' behavior with special handling for classes that represent
    ORM model tables.
    """
    def get_doc(self, encoding=None, ignore=1):
        # Get the doc as generated by the parent class.
        doc = super().get_doc(encoding=encoding, ignore=ignore)
        # We only care about classes decorated as models.
        if not(hasattr(self.object, IS_MODEL_CLASS) and
               hasattr(self.object, TABLE_META_ATTR)):
            return doc
        # Create an image that we can put in-line with the rest of the
        # docstring.
        img_sub = str(uuid.uuid4()).replace('-', '')
        lines = [[
            f".. |{img_sub}_tbl| image:: {IMAGES_PATH / 'table.svg'}",
            '    :width: 24px',
            '    :height: 24px',
            ''
        ]]
        geom_markup: bool = False
        # Try to add the geometry type image.
        try:
            gtype = cast(ModelMixin, self.object).geometry_type()
            gtype_file = gtype.name.lower()
            img_path = IMAGES_PATH / f'{gtype_file}.svg'
            lines[0].extend([
                f".. |{img_sub}_geom| image:: {img_path}",
                '    :width: 24px',
                '    :height: 24px',
                ''
            ])
            # We have geometry markup!
            geom_markup = True
        except KeyError:
            logging.exception(
                f'{type(self.object)} does not define a geometry.'
            )
        # Create the line that defines the image that will appear before the
        # rest of the documentation.
        img_line = (
            f"|{img_sub}_tbl| |{img_sub}_geom|" if geom_markup
            else f"|{img_sub}_tbl|"
        )

        # Add the table image, along with (possibly) the geometry image and
        # the title.
        lines[0].extend([
            img_line,
            self.object.__doc__ or '', '',
            f':Table Name: {self.object.__tablename__}', ''
        ])

        # If the table has a geometry...
        geom_type = self.object.geometry_type()
        if geom_type is not None:
            # ...indicate the geometry type in the document.
            lines[0].extend([
                f':Geometry Type: {titlecase(self.object.geometry_type().name)}', ''
            ])
        # Return whatever we have.
        return lines


class ColumnAttributeDocumenter(AttributeDocumenter):
    """
    This is a specialized Documenter subclass for attributes.  It overrides the
    parent class' behavior with special handling for :py:class:`Column`
    attributes.
    """
    def add_content(self, more_content, no_docstring=False):
        # Remember the original no_docstring parameter.
        _no_docstring = no_docstring
        # If this attribute appears to be a Column...
        if (isinstance(self.object, Column)
                and hasattr(self.object, COLUMN_META_ATTR)):
            # ...we really want to document it.
            _no_docstring = False
        elif not self._datadescriptor:
            # if it's not a data descriptor, its docstring is very probably the
            # wrong thing to display
            _no_docstring = True

        ClassLevelDocumenter.add_content(self, more_content, _no_docstring)

    def get_doc(self, encoding=None, ignore: int = 1) -> List[List[str]]:
        """Decode and return lines of the docstring(s) for the object."""
        # If the current object is a Column (or InstrumentedAttribute) and
        # it appears to have metadata...
        if (isinstance(self.object, (Column, InstrumentedAttribute)) and
                hasattr(self.object, COLUMN_META_ATTR)):
            # Get the metadata from the column.
            meta = self.object.__meta__
            # Create an image that we can put in-line with the rest of the
            # docstring.
            img_sub = str(uuid.uuid4()).replace('-', '')
            lines = [
                f".. |{img_sub}| image:: {IMAGES_PATH / 'column.svg'}",
                '    :width: 24px',
                '    :height: 24px',
                '',
                f"|{img_sub}| **{meta.label}**", '',
                meta.description, '',
                self.doc_enum_table(enum_cls=Usage,
                                    meta=meta,
                                    excluded={Usage.NONE}), '',
                self.doc_enum_table(enum_cls=Requirement,
                                    meta=meta,
                                    excluded={Requirement.NONE}), ''
            ]
            # If the meta-data indicates there is a related NENA field...
            if meta.nena is not None:
                # ...we'll include it!
                lines.extend([f':NENA: *{meta.nena}*', ''])
            # Put it all together.
            rst = '\n'.join(lines)
            # OK, ship it out!
            return[prepare_docstring(rst, 0)]  # don't ignore it!
        else:  # In all other cases, let the parent class do its thing.
            return super().get_doc(encoding=encoding, ignore=ignore)

    @staticmethod
    def doc_enum_table(enum_cls: Type[Union[Requirement, Usage]],
                       meta: ColumnMeta,
                       excluded: Set[Any]):
        """
        Create a reStructuredText table to describe integer flag enumeration
        values.

        :param enum_cls: the enumeration type
        :param meta: the column's metadata
        :param excluded: enumeration values to be excluded from the table
        :return: the reStructuredText
        """
        # Get all of the enumerated values that aren't in the exclusion
        # set.
        vals = [v for v in enum_cls if v not in excluded]
        # Let's start off with the column specification for the table.
        colspec = f"|{'|'.join(['c'] * len(vals))}|"
        lines = [
            f'.. tabularcolumns:: {colspec}', ''
        ]
        # We're going to be formatting fixed-width text.  Let's do so with
        # three lists...
        tbl_hborders = [''] * len(vals)  # the horizontal borders
        tbl_headers = [''] * len(vals)  # the table headers
        tbl_values = [''] * len(vals)  # the values
        # Let's look at each of the values.
        for i, val in enumerate(vals):
            # We need the name.
            enum_name = val.name
            # The character width of the column is the length of the name
            # plus one (1) padding space on each side.
            colwidth = (len(enum_name) + 2)
            # Now that we know the width, the border for this index can be
            # defined.
            tbl_hborders[i] = '-' * colwidth
            # Title-case the numeration name and place it in the headers
            # list at the current index.
            tbl_headers[i] = f' {titlecase(enum_name)} '
            # The yes-or-no indicator will only take up a single character,
            # but we need to pad it to maintain the fixed width.
            xo = [' '] * colwidth  # pylint: disable=invalid-name
            # Leaving one space on the left, put a yes-or-no indicator in
            # the column.  (We're using ASCII characters which we'll
            # replace in a moment.  For some reason, the extended characters
            # seem to pad the list with an extra space.)
            xo[1] = (
                u'Y' if meta.get_enum(enum_cls) & vals[i].value else u'N'
            )
            # Build the string.
            xos = ''.join(xo)
            # Update the string with visual symbols.
            xos = xos.replace('N', '✘')
            xos = xos.replace('Y', '✔')
            # That's the text for the values list at this index.
            tbl_values[i] = xos
        # Construct the table.
        hborder = f"+{'+'.join(tbl_hborders)}+"
        lines.append(hborder)
        lines.append(f"|{'|'.join(tbl_headers)}|")
        lines.append(hborder)
        lines.append(f"|{'|'.join(tbl_values)}|")
        lines.append(hborder)
        # Put it all together, and...
        rst = '\n'.join(lines)
        return rst  # ...that's that.


# pylint: disable=unused-argument, too-many-arguments
def no_namedtuple_attrib_docstring(app, what, name, obj, options, lines):
    """
    `namedtuples` are awesome.  Unfortunately, if you find yourself with a large
    one and you use Sphinx for documentation you're going to find yourself with
    a gigantic part of your documentation documenting members as 'Alias for
    field...'  This function overrides that behavior.

    :param app:
    :param what:
    :param name:
    :param obj:
    :param options:
    :param lines: the lines that may contain Alias for field number'
    :return:

    .. seealso::

         https://chrisdown.name/2015/09/20/removing-namedtuple-docstrings-from-sphinx.html
    """
    is_namedtuple_docstring = (
        len(lines) > 0 and
        lines[0].startswith('Alias for field number')
    )
    if is_namedtuple_docstring:
        # We don't return, so we need to purge in-place
        del lines[:]



def export_images(path: Path):
    """
    Extract the `modlit` documentation images to a target directory.

    :param path: the path to the target directory
    """
    # Create the target directory (if it doesn't exist).
    os.makedirs(str(path.resolve()), exist_ok=True)
    # If the target directory path isn't a directory...
    if not path.is_dir():
        # ...well, that's going to be a problem.
        raise NotADirectoryError('The path is not a directory.')
    # Determine the local image path.
    local_img_path = (Path(__file__).resolve()).parent / 'images'
    # We'll need a logger.
    logger: logging.Logger = logging.getLogger(__name__)
    # Go through each of the local images...
    for source in [f for f in local_img_path.iterdir() if f.is_file()]:  # pylint: disable=no-member
        # ...determine the path where we'd like to palce it.
        target = path / source.name
        # If there isn't already a file there...
        if not target.exists():
            # ...copy it on over.
            logger.info(f'Copying doc images file {str(source)} to'
                        f' {str(target)}.')
            shutil.copy(str(source), str(path))
