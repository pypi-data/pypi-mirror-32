#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat May 19 14:29:27 2018 by generateDS.py version 2.29.11.
# Python 2.7.14 (default, Mar 14 2018, 13:36:31)  [GCC 7.3.1 20180303 (Red Hat 7.3.1-5)]
#
# Command line options:
#   ('-q', '')
#   ('-f', '')
#   ('-o', 'pyone/bindings/supbind.py')
#   ('-s', 'pyone/bindings/__init__.py')
#   ('--super', 'supbind')
#   ('--external-encoding', 'utf-8')
#   ('--silence', '')
#
# Command line arguments:
#   pyone/xsd/index.xsd
#
# Command line:
#   /home/rafael/Development/privaz.io/python/env/bin/generateDS -q -f -o "pyone/bindings/supbind.py" -s "pyone/bindings/__init__.py" --super="supbind" --external-encoding="utf-8" --silence pyone/xsd/index.xsd
#
# Current working directory (os.getcwd()):
#   pyone
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class HISTORY_RECORDS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HISTORY=None):
        self.original_tagname_ = None
        if HISTORY is None:
            self.HISTORY = []
        else:
            self.HISTORY = HISTORY
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORY_RECORDS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORY_RECORDS.subclass:
            return HISTORY_RECORDS.subclass(*args_, **kwargs_)
        else:
            return HISTORY_RECORDS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HISTORY(self): return self.HISTORY
    def set_HISTORY(self, HISTORY): self.HISTORY = HISTORY
    def add_HISTORY(self, value): self.HISTORY.append(value)
    def insert_HISTORY_at(self, index, value): self.HISTORY.insert(index, value)
    def replace_HISTORY_at(self, index, value): self.HISTORY[index] = value
    def hasContent_(self):
        if (
            self.HISTORY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HISTORY_RECORDS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORY_RECORDS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HISTORY_RECORDS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HISTORY_RECORDS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HISTORY_RECORDS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HISTORY_RECORDS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HISTORY_ in self.HISTORY:
            HISTORY_.export(outfile, level, namespace_, name_='HISTORY', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HISTORY':
            obj_ = HISTORY.factory()
            obj_.build(child_)
            self.HISTORY.append(obj_)
            obj_.original_tagname_ = 'HISTORY'
# end class HISTORY_RECORDS


class HISTORY(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OID=None, SEQ=None, HOSTNAME=None, HID=None, CID=None, STIME=None, ETIME=None, VM_MAD=None, TM_MAD=None, DS_ID=None, PSTIME=None, PETIME=None, RSTIME=None, RETIME=None, ESTIME=None, EETIME=None, ACTION=None, UID=None, GID=None, REQUEST_ID=None, VM=None):
        self.original_tagname_ = None
        self.OID = OID
        self.SEQ = SEQ
        self.HOSTNAME = HOSTNAME
        self.HID = HID
        self.CID = CID
        self.STIME = STIME
        self.ETIME = ETIME
        self.VM_MAD = VM_MAD
        self.TM_MAD = TM_MAD
        self.DS_ID = DS_ID
        self.PSTIME = PSTIME
        self.PETIME = PETIME
        self.RSTIME = RSTIME
        self.RETIME = RETIME
        self.ESTIME = ESTIME
        self.EETIME = EETIME
        self.ACTION = ACTION
        self.UID = UID
        self.GID = GID
        self.REQUEST_ID = REQUEST_ID
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORY.subclass:
            return HISTORY.subclass(*args_, **kwargs_)
        else:
            return HISTORY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OID(self): return self.OID
    def set_OID(self, OID): self.OID = OID
    def get_SEQ(self): return self.SEQ
    def set_SEQ(self, SEQ): self.SEQ = SEQ
    def get_HOSTNAME(self): return self.HOSTNAME
    def set_HOSTNAME(self, HOSTNAME): self.HOSTNAME = HOSTNAME
    def get_HID(self): return self.HID
    def set_HID(self, HID): self.HID = HID
    def get_CID(self): return self.CID
    def set_CID(self, CID): self.CID = CID
    def get_STIME(self): return self.STIME
    def set_STIME(self, STIME): self.STIME = STIME
    def get_ETIME(self): return self.ETIME
    def set_ETIME(self, ETIME): self.ETIME = ETIME
    def get_VM_MAD(self): return self.VM_MAD
    def set_VM_MAD(self, VM_MAD): self.VM_MAD = VM_MAD
    def get_TM_MAD(self): return self.TM_MAD
    def set_TM_MAD(self, TM_MAD): self.TM_MAD = TM_MAD
    def get_DS_ID(self): return self.DS_ID
    def set_DS_ID(self, DS_ID): self.DS_ID = DS_ID
    def get_PSTIME(self): return self.PSTIME
    def set_PSTIME(self, PSTIME): self.PSTIME = PSTIME
    def get_PETIME(self): return self.PETIME
    def set_PETIME(self, PETIME): self.PETIME = PETIME
    def get_RSTIME(self): return self.RSTIME
    def set_RSTIME(self, RSTIME): self.RSTIME = RSTIME
    def get_RETIME(self): return self.RETIME
    def set_RETIME(self, RETIME): self.RETIME = RETIME
    def get_ESTIME(self): return self.ESTIME
    def set_ESTIME(self, ESTIME): self.ESTIME = ESTIME
    def get_EETIME(self): return self.EETIME
    def set_EETIME(self, EETIME): self.EETIME = EETIME
    def get_ACTION(self): return self.ACTION
    def set_ACTION(self, ACTION): self.ACTION = ACTION
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_REQUEST_ID(self): return self.REQUEST_ID
    def set_REQUEST_ID(self, REQUEST_ID): self.REQUEST_ID = REQUEST_ID
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.OID is not None or
            self.SEQ is not None or
            self.HOSTNAME is not None or
            self.HID is not None or
            self.CID is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.VM_MAD is not None or
            self.TM_MAD is not None or
            self.DS_ID is not None or
            self.PSTIME is not None or
            self.PETIME is not None or
            self.RSTIME is not None or
            self.RETIME is not None or
            self.ESTIME is not None or
            self.EETIME is not None or
            self.ACTION is not None or
            self.UID is not None or
            self.GID is not None or
            self.REQUEST_ID is not None or
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HISTORY', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HISTORY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HISTORY', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HISTORY'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HISTORY', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OID>%s</OID>%s' % (self.gds_format_integer(self.OID, input_name='OID'), eol_))
        if self.SEQ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SEQ>%s</SEQ>%s' % (self.gds_format_integer(self.SEQ, input_name='SEQ'), eol_))
        if self.HOSTNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<HOSTNAME>%s</HOSTNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HOSTNAME), input_name='HOSTNAME')), eol_))
        if self.HID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<HID>%s</HID>%s' % (self.gds_format_integer(self.HID, input_name='HID'), eol_))
        if self.CID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CID>%s</CID>%s' % (self.gds_format_integer(self.CID, input_name='CID'), eol_))
        if self.STIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STIME>%s</STIME>%s' % (self.gds_format_integer(self.STIME, input_name='STIME'), eol_))
        if self.ETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ETIME>%s</ETIME>%s' % (self.gds_format_integer(self.ETIME, input_name='ETIME'), eol_))
        if self.VM_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VM_MAD>%s</VM_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VM_MAD), input_name='VM_MAD')), eol_))
        if self.TM_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TM_MAD>%s</TM_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD), input_name='TM_MAD')), eol_))
        if self.DS_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DS_ID>%s</DS_ID>%s' % (self.gds_format_integer(self.DS_ID, input_name='DS_ID'), eol_))
        if self.PSTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PSTIME>%s</PSTIME>%s' % (self.gds_format_integer(self.PSTIME, input_name='PSTIME'), eol_))
        if self.PETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PETIME>%s</PETIME>%s' % (self.gds_format_integer(self.PETIME, input_name='PETIME'), eol_))
        if self.RSTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RSTIME>%s</RSTIME>%s' % (self.gds_format_integer(self.RSTIME, input_name='RSTIME'), eol_))
        if self.RETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RETIME>%s</RETIME>%s' % (self.gds_format_integer(self.RETIME, input_name='RETIME'), eol_))
        if self.ESTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ESTIME>%s</ESTIME>%s' % (self.gds_format_integer(self.ESTIME, input_name='ESTIME'), eol_))
        if self.EETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EETIME>%s</EETIME>%s' % (self.gds_format_integer(self.EETIME, input_name='EETIME'), eol_))
        if self.ACTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ACTION>%s</ACTION>%s' % (self.gds_format_integer(self.ACTION, input_name='ACTION'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.REQUEST_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<REQUEST_ID>%s</REQUEST_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.REQUEST_ID), input_name='REQUEST_ID')), eol_))
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OID')
            self.OID = ival_
        elif nodeName_ == 'SEQ':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SEQ')
            self.SEQ = ival_
        elif nodeName_ == 'HOSTNAME':
            HOSTNAME_ = child_.text
            HOSTNAME_ = self.gds_validate_string(HOSTNAME_, node, 'HOSTNAME')
            self.HOSTNAME = HOSTNAME_
        elif nodeName_ == 'HID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'HID')
            self.HID = ival_
        elif nodeName_ == 'CID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CID')
            self.CID = ival_
        elif nodeName_ == 'STIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
        elif nodeName_ == 'ETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
        elif nodeName_ == 'VM_MAD':
            VM_MAD_ = child_.text
            VM_MAD_ = self.gds_validate_string(VM_MAD_, node, 'VM_MAD')
            self.VM_MAD = VM_MAD_
        elif nodeName_ == 'TM_MAD':
            TM_MAD_ = child_.text
            TM_MAD_ = self.gds_validate_string(TM_MAD_, node, 'TM_MAD')
            self.TM_MAD = TM_MAD_
        elif nodeName_ == 'DS_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DS_ID')
            self.DS_ID = ival_
        elif nodeName_ == 'PSTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PSTIME')
            self.PSTIME = ival_
        elif nodeName_ == 'PETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PETIME')
            self.PETIME = ival_
        elif nodeName_ == 'RSTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RSTIME')
            self.RSTIME = ival_
        elif nodeName_ == 'RETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RETIME')
            self.RETIME = ival_
        elif nodeName_ == 'ESTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ESTIME')
            self.ESTIME = ival_
        elif nodeName_ == 'EETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EETIME')
            self.EETIME = ival_
        elif nodeName_ == 'ACTION':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ACTION')
            self.ACTION = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'REQUEST_ID':
            REQUEST_ID_ = child_.text
            REQUEST_ID_ = self.gds_validate_string(REQUEST_ID_, node, 'REQUEST_ID')
            self.REQUEST_ID = REQUEST_ID_
        elif nodeName_ == 'VM':
            obj_ = VMType.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class HISTORY


class CLUSTER_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CLUSTER=None):
        self.original_tagname_ = None
        if CLUSTER is None:
            self.CLUSTER = []
        else:
            self.CLUSTER = CLUSTER
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTER_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTER_POOL.subclass:
            return CLUSTER_POOL.subclass(*args_, **kwargs_)
        else:
            return CLUSTER_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CLUSTER(self): return self.CLUSTER
    def set_CLUSTER(self, CLUSTER): self.CLUSTER = CLUSTER
    def add_CLUSTER(self, value): self.CLUSTER.append(value)
    def insert_CLUSTER_at(self, index, value): self.CLUSTER.insert(index, value)
    def replace_CLUSTER_at(self, index, value): self.CLUSTER[index] = value
    def hasContent_(self):
        if (
            self.CLUSTER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CLUSTER_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTER_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLUSTER_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CLUSTER_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLUSTER_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLUSTER_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CLUSTER_ in self.CLUSTER:
            CLUSTER_.export(outfile, level, namespace_, name_='CLUSTER', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CLUSTER':
            obj_ = CLUSTER.factory()
            obj_.build(child_)
            self.CLUSTER.append(obj_)
            obj_.original_tagname_ = 'CLUSTER'
# end class CLUSTER_POOL


class CLUSTER(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, HOSTS=None, DATASTORES=None, VNETS=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.NAME = NAME
        self.HOSTS = HOSTS
        self.DATASTORES = DATASTORES
        self.VNETS = VNETS
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTER.subclass:
            return CLUSTER.subclass(*args_, **kwargs_)
        else:
            return CLUSTER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_HOSTS(self): return self.HOSTS
    def set_HOSTS(self, HOSTS): self.HOSTS = HOSTS
    def get_DATASTORES(self): return self.DATASTORES
    def set_DATASTORES(self, DATASTORES): self.DATASTORES = DATASTORES
    def get_VNETS(self): return self.VNETS
    def set_VNETS(self, VNETS): self.VNETS = VNETS
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.HOSTS is not None or
            self.DATASTORES is not None or
            self.VNETS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CLUSTER', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTER')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLUSTER')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CLUSTER', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLUSTER'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLUSTER', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.HOSTS is not None:
            self.HOSTS.export(outfile, level, namespace_, name_='HOSTS', pretty_print=pretty_print)
        if self.DATASTORES is not None:
            self.DATASTORES.export(outfile, level, namespace_, name_='DATASTORES', pretty_print=pretty_print)
        if self.VNETS is not None:
            self.VNETS.export(outfile, level, namespace_, name_='VNETS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'HOSTS':
            obj_ = HOSTSType.factory()
            obj_.build(child_)
            self.HOSTS = obj_
            obj_.original_tagname_ = 'HOSTS'
        elif nodeName_ == 'DATASTORES':
            obj_ = DATASTORESType.factory()
            obj_.build(child_)
            self.DATASTORES = obj_
            obj_.original_tagname_ = 'DATASTORES'
        elif nodeName_ == 'VNETS':
            obj_ = VNETSType.factory()
            obj_.build(child_)
            self.VNETS = obj_
            obj_.original_tagname_ = 'VNETS'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class CLUSTER


class DATASTORE_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_POOL.subclass:
            return DATASTORE_POOL.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTORE.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_POOL


class DATASTORE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, DS_MAD=None, TM_MAD=None, BASE_PATH=None, TYPE=None, DISK_TYPE=None, STATE=None, CLUSTERS=None, TOTAL_MB=None, FREE_MB=None, USED_MB=None, IMAGES=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.PERMISSIONS = PERMISSIONS
        self.DS_MAD = DS_MAD
        self.TM_MAD = TM_MAD
        self.BASE_PATH = BASE_PATH
        self.TYPE = TYPE
        self.DISK_TYPE = DISK_TYPE
        self.STATE = STATE
        self.CLUSTERS = CLUSTERS
        self.TOTAL_MB = TOTAL_MB
        self.FREE_MB = FREE_MB
        self.USED_MB = USED_MB
        self.IMAGES = IMAGES
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE.subclass:
            return DATASTORE.subclass(*args_, **kwargs_)
        else:
            return DATASTORE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_DS_MAD(self): return self.DS_MAD
    def set_DS_MAD(self, DS_MAD): self.DS_MAD = DS_MAD
    def get_TM_MAD(self): return self.TM_MAD
    def set_TM_MAD(self, TM_MAD): self.TM_MAD = TM_MAD
    def get_BASE_PATH(self): return self.BASE_PATH
    def set_BASE_PATH(self, BASE_PATH): self.BASE_PATH = BASE_PATH
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_DISK_TYPE(self): return self.DISK_TYPE
    def set_DISK_TYPE(self, DISK_TYPE): self.DISK_TYPE = DISK_TYPE
    def get_STATE(self): return self.STATE
    def set_STATE(self, STATE): self.STATE = STATE
    def get_CLUSTERS(self): return self.CLUSTERS
    def set_CLUSTERS(self, CLUSTERS): self.CLUSTERS = CLUSTERS
    def get_TOTAL_MB(self): return self.TOTAL_MB
    def set_TOTAL_MB(self, TOTAL_MB): self.TOTAL_MB = TOTAL_MB
    def get_FREE_MB(self): return self.FREE_MB
    def set_FREE_MB(self, FREE_MB): self.FREE_MB = FREE_MB
    def get_USED_MB(self): return self.USED_MB
    def set_USED_MB(self, USED_MB): self.USED_MB = USED_MB
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.DS_MAD is not None or
            self.TM_MAD is not None or
            self.BASE_PATH is not None or
            self.TYPE is not None or
            self.DISK_TYPE is not None or
            self.STATE is not None or
            self.CLUSTERS is not None or
            self.TOTAL_MB is not None or
            self.FREE_MB is not None or
            self.USED_MB is not None or
            self.IMAGES is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.DS_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DS_MAD>%s</DS_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DS_MAD), input_name='DS_MAD')), eol_))
        if self.TM_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TM_MAD>%s</TM_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD), input_name='TM_MAD')), eol_))
        if self.BASE_PATH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BASE_PATH>%s</BASE_PATH>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BASE_PATH), input_name='BASE_PATH')), eol_))
        if self.TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TYPE>%s</TYPE>%s' % (self.gds_format_integer(self.TYPE, input_name='TYPE'), eol_))
        if self.DISK_TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DISK_TYPE>%s</DISK_TYPE>%s' % (self.gds_format_integer(self.DISK_TYPE, input_name='DISK_TYPE'), eol_))
        if self.STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE>%s</STATE>%s' % (self.gds_format_integer(self.STATE, input_name='STATE'), eol_))
        if self.CLUSTERS is not None:
            self.CLUSTERS.export(outfile, level, namespace_, name_='CLUSTERS', pretty_print=pretty_print)
        if self.TOTAL_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TOTAL_MB>%s</TOTAL_MB>%s' % (self.gds_format_integer(self.TOTAL_MB, input_name='TOTAL_MB'), eol_))
        if self.FREE_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FREE_MB>%s</FREE_MB>%s' % (self.gds_format_integer(self.FREE_MB, input_name='FREE_MB'), eol_))
        if self.USED_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_MB>%s</USED_MB>%s' % (self.gds_format_integer(self.USED_MB, input_name='USED_MB'), eol_))
        if self.IMAGES is not None:
            self.IMAGES.export(outfile, level, namespace_, name_='IMAGES', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType1.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'DS_MAD':
            DS_MAD_ = child_.text
            DS_MAD_ = self.gds_validate_string(DS_MAD_, node, 'DS_MAD')
            self.DS_MAD = DS_MAD_
        elif nodeName_ == 'TM_MAD':
            TM_MAD_ = child_.text
            TM_MAD_ = self.gds_validate_string(TM_MAD_, node, 'TM_MAD')
            self.TM_MAD = TM_MAD_
        elif nodeName_ == 'BASE_PATH':
            BASE_PATH_ = child_.text
            BASE_PATH_ = self.gds_validate_string(BASE_PATH_, node, 'BASE_PATH')
            self.BASE_PATH = BASE_PATH_
        elif nodeName_ == 'TYPE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TYPE')
            self.TYPE = ival_
        elif nodeName_ == 'DISK_TYPE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_TYPE')
            self.DISK_TYPE = ival_
        elif nodeName_ == 'STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
        elif nodeName_ == 'CLUSTERS':
            obj_ = CLUSTERSType.factory()
            obj_.build(child_)
            self.CLUSTERS = obj_
            obj_.original_tagname_ = 'CLUSTERS'
        elif nodeName_ == 'TOTAL_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_MB')
            self.TOTAL_MB = ival_
        elif nodeName_ == 'FREE_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_MB')
            self.FREE_MB = ival_
        elif nodeName_ == 'USED_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'USED_MB')
            self.USED_MB = ival_
        elif nodeName_ == 'IMAGES':
            obj_ = IMAGESType.factory()
            obj_.build(child_)
            self.IMAGES = obj_
            obj_.original_tagname_ = 'IMAGES'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class DATASTORE


class GROUP_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GROUP=None, QUOTAS=None, DEFAULT_GROUP_QUOTAS=None):
        self.original_tagname_ = None
        if GROUP is None:
            self.GROUP = []
        else:
            self.GROUP = GROUP
        if QUOTAS is None:
            self.QUOTAS = []
        else:
            self.QUOTAS = QUOTAS
        self.DEFAULT_GROUP_QUOTAS = DEFAULT_GROUP_QUOTAS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUP_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUP_POOL.subclass:
            return GROUP_POOL.subclass(*args_, **kwargs_)
        else:
            return GROUP_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GROUP(self): return self.GROUP
    def set_GROUP(self, GROUP): self.GROUP = GROUP
    def add_GROUP(self, value): self.GROUP.append(value)
    def insert_GROUP_at(self, index, value): self.GROUP.insert(index, value)
    def replace_GROUP_at(self, index, value): self.GROUP[index] = value
    def get_QUOTAS(self): return self.QUOTAS
    def set_QUOTAS(self, QUOTAS): self.QUOTAS = QUOTAS
    def add_QUOTAS(self, value): self.QUOTAS.append(value)
    def insert_QUOTAS_at(self, index, value): self.QUOTAS.insert(index, value)
    def replace_QUOTAS_at(self, index, value): self.QUOTAS[index] = value
    def get_DEFAULT_GROUP_QUOTAS(self): return self.DEFAULT_GROUP_QUOTAS
    def set_DEFAULT_GROUP_QUOTAS(self, DEFAULT_GROUP_QUOTAS): self.DEFAULT_GROUP_QUOTAS = DEFAULT_GROUP_QUOTAS
    def hasContent_(self):
        if (
            self.GROUP or
            self.QUOTAS or
            self.DEFAULT_GROUP_QUOTAS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GROUP_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUP_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GROUP_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GROUP_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GROUP_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GROUP_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GROUP_ in self.GROUP:
            GROUP_.export(outfile, level, namespace_, name_='GROUP', pretty_print=pretty_print)
        for QUOTAS_ in self.QUOTAS:
            QUOTAS_.export(outfile, level, namespace_, name_='QUOTAS', pretty_print=pretty_print)
        if self.DEFAULT_GROUP_QUOTAS is not None:
            self.DEFAULT_GROUP_QUOTAS.export(outfile, level, namespace_, name_='DEFAULT_GROUP_QUOTAS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GROUP':
            obj_ = GROUPType.factory()
            obj_.build(child_)
            self.GROUP.append(obj_)
            obj_.original_tagname_ = 'GROUP'
        elif nodeName_ == 'QUOTAS':
            obj_ = QUOTASType.factory()
            obj_.build(child_)
            self.QUOTAS.append(obj_)
            obj_.original_tagname_ = 'QUOTAS'
        elif nodeName_ == 'DEFAULT_GROUP_QUOTAS':
            obj_ = DEFAULT_GROUP_QUOTASType.factory()
            obj_.build(child_)
            self.DEFAULT_GROUP_QUOTAS = obj_
            obj_.original_tagname_ = 'DEFAULT_GROUP_QUOTAS'
# end class GROUP_POOL


class GROUP(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, TEMPLATE=None, USERS=None, ADMINS=None, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, DEFAULT_GROUP_QUOTAS=None):
        self.original_tagname_ = None
        self.ID = ID
        self.NAME = NAME
        self.TEMPLATE = TEMPLATE
        self.USERS = USERS
        self.ADMINS = ADMINS
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.VM_QUOTA = VM_QUOTA
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.DEFAULT_GROUP_QUOTAS = DEFAULT_GROUP_QUOTAS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUP.subclass:
            return GROUP.subclass(*args_, **kwargs_)
        else:
            return GROUP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def get_USERS(self): return self.USERS
    def set_USERS(self, USERS): self.USERS = USERS
    def get_ADMINS(self): return self.ADMINS
    def set_ADMINS(self, ADMINS): self.ADMINS = ADMINS
    def get_DATASTORE_QUOTA(self): return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA): self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self): return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA): self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self): return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA): self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self): return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA): self.IMAGE_QUOTA = IMAGE_QUOTA
    def get_DEFAULT_GROUP_QUOTAS(self): return self.DEFAULT_GROUP_QUOTAS
    def set_DEFAULT_GROUP_QUOTAS(self, DEFAULT_GROUP_QUOTAS): self.DEFAULT_GROUP_QUOTAS = DEFAULT_GROUP_QUOTAS
    def hasContent_(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.TEMPLATE is not None or
            self.USERS is not None or
            self.ADMINS is not None or
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None or
            self.DEFAULT_GROUP_QUOTAS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GROUP', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GROUP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GROUP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GROUP'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GROUP', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
        if self.USERS is not None:
            self.USERS.export(outfile, level, namespace_, name_='USERS', pretty_print=pretty_print)
        if self.ADMINS is not None:
            self.ADMINS.export(outfile, level, namespace_, name_='ADMINS', pretty_print=pretty_print)
        if self.DATASTORE_QUOTA is not None:
            self.DATASTORE_QUOTA.export(outfile, level, namespace_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            self.NETWORK_QUOTA.export(outfile, level, namespace_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            self.VM_QUOTA.export(outfile, level, namespace_, name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            self.IMAGE_QUOTA.export(outfile, level, namespace_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
        if self.DEFAULT_GROUP_QUOTAS is not None:
            self.DEFAULT_GROUP_QUOTAS.export(outfile, level, namespace_, name_='DEFAULT_GROUP_QUOTAS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
        elif nodeName_ == 'USERS':
            obj_ = USERSType11.factory()
            obj_.build(child_)
            self.USERS = obj_
            obj_.original_tagname_ = 'USERS'
        elif nodeName_ == 'ADMINS':
            obj_ = ADMINSType12.factory()
            obj_.build(child_)
            self.ADMINS = obj_
            obj_.original_tagname_ = 'ADMINS'
        elif nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTAType13.factory()
            obj_.build(child_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTAType15.factory()
            obj_.build(child_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType17.factory()
            obj_.build(child_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTAType19.factory()
            obj_.build(child_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
        elif nodeName_ == 'DEFAULT_GROUP_QUOTAS':
            obj_ = DEFAULT_GROUP_QUOTASType21.factory()
            obj_.build(child_)
            self.DEFAULT_GROUP_QUOTAS = obj_
            obj_.original_tagname_ = 'DEFAULT_GROUP_QUOTAS'
# end class GROUP


class HOST_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HOST=None):
        self.original_tagname_ = None
        if HOST is None:
            self.HOST = []
        else:
            self.HOST = HOST
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOST_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOST_POOL.subclass:
            return HOST_POOL.subclass(*args_, **kwargs_)
        else:
            return HOST_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HOST(self): return self.HOST
    def set_HOST(self, HOST): self.HOST = HOST
    def add_HOST(self, value): self.HOST.append(value)
    def insert_HOST_at(self, index, value): self.HOST.insert(index, value)
    def replace_HOST_at(self, index, value): self.HOST[index] = value
    def hasContent_(self):
        if (
            self.HOST
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HOST_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOST_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HOST_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HOST_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HOST_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HOST_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HOST_ in self.HOST:
            HOST_.export(outfile, level, namespace_, name_='HOST', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HOST':
            obj_ = HOST.factory()
            obj_.build(child_)
            self.HOST.append(obj_)
            obj_.original_tagname_ = 'HOST'
# end class HOST_POOL


class HOST(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, STATE=None, IM_MAD=None, VM_MAD=None, LAST_MON_TIME=None, CLUSTER_ID=None, CLUSTER=None, HOST_SHARE=None, VMS=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.NAME = NAME
        self.STATE = STATE
        self.IM_MAD = IM_MAD
        self.VM_MAD = VM_MAD
        self.LAST_MON_TIME = LAST_MON_TIME
        self.CLUSTER_ID = CLUSTER_ID
        self.CLUSTER = CLUSTER
        self.HOST_SHARE = HOST_SHARE
        self.VMS = VMS
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOST.subclass:
            return HOST.subclass(*args_, **kwargs_)
        else:
            return HOST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_STATE(self): return self.STATE
    def set_STATE(self, STATE): self.STATE = STATE
    def get_IM_MAD(self): return self.IM_MAD
    def set_IM_MAD(self, IM_MAD): self.IM_MAD = IM_MAD
    def get_VM_MAD(self): return self.VM_MAD
    def set_VM_MAD(self, VM_MAD): self.VM_MAD = VM_MAD
    def get_LAST_MON_TIME(self): return self.LAST_MON_TIME
    def set_LAST_MON_TIME(self, LAST_MON_TIME): self.LAST_MON_TIME = LAST_MON_TIME
    def get_CLUSTER_ID(self): return self.CLUSTER_ID
    def set_CLUSTER_ID(self, CLUSTER_ID): self.CLUSTER_ID = CLUSTER_ID
    def get_CLUSTER(self): return self.CLUSTER
    def set_CLUSTER(self, CLUSTER): self.CLUSTER = CLUSTER
    def get_HOST_SHARE(self): return self.HOST_SHARE
    def set_HOST_SHARE(self, HOST_SHARE): self.HOST_SHARE = HOST_SHARE
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.STATE is not None or
            self.IM_MAD is not None or
            self.VM_MAD is not None or
            self.LAST_MON_TIME is not None or
            self.CLUSTER_ID is not None or
            self.CLUSTER is not None or
            self.HOST_SHARE is not None or
            self.VMS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HOST', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HOST')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HOST', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HOST'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HOST', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE>%s</STATE>%s' % (self.gds_format_integer(self.STATE, input_name='STATE'), eol_))
        if self.IM_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IM_MAD>%s</IM_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IM_MAD), input_name='IM_MAD')), eol_))
        if self.VM_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VM_MAD>%s</VM_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VM_MAD), input_name='VM_MAD')), eol_))
        if self.LAST_MON_TIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LAST_MON_TIME>%s</LAST_MON_TIME>%s' % (self.gds_format_integer(self.LAST_MON_TIME, input_name='LAST_MON_TIME'), eol_))
        if self.CLUSTER_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CLUSTER_ID>%s</CLUSTER_ID>%s' % (self.gds_format_integer(self.CLUSTER_ID, input_name='CLUSTER_ID'), eol_))
        if self.CLUSTER is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CLUSTER>%s</CLUSTER>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CLUSTER), input_name='CLUSTER')), eol_))
        if self.HOST_SHARE is not None:
            self.HOST_SHARE.export(outfile, level, namespace_, name_='HOST_SHARE', pretty_print=pretty_print)
        if self.VMS is not None:
            self.VMS.export(outfile, level, namespace_, name_='VMS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
        elif nodeName_ == 'IM_MAD':
            IM_MAD_ = child_.text
            IM_MAD_ = self.gds_validate_string(IM_MAD_, node, 'IM_MAD')
            self.IM_MAD = IM_MAD_
        elif nodeName_ == 'VM_MAD':
            VM_MAD_ = child_.text
            VM_MAD_ = self.gds_validate_string(VM_MAD_, node, 'VM_MAD')
            self.VM_MAD = VM_MAD_
        elif nodeName_ == 'LAST_MON_TIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LAST_MON_TIME')
            self.LAST_MON_TIME = ival_
        elif nodeName_ == 'CLUSTER_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CLUSTER_ID')
            self.CLUSTER_ID = ival_
        elif nodeName_ == 'CLUSTER':
            CLUSTER_ = child_.text
            CLUSTER_ = self.gds_validate_string(CLUSTER_, node, 'CLUSTER')
            self.CLUSTER = CLUSTER_
        elif nodeName_ == 'HOST_SHARE':
            obj_ = HOST_SHAREType.factory()
            obj_.build(child_)
            self.HOST_SHARE = obj_
            obj_.original_tagname_ = 'HOST_SHARE'
        elif nodeName_ == 'VMS':
            obj_ = VMSType.factory()
            obj_.build(child_)
            self.VMS = obj_
            obj_.original_tagname_ = 'VMS'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class HOST


class IMAGE_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_POOL.subclass:
            return IMAGE_POOL.subclass(*args_, **kwargs_)
        else:
            return IMAGE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGE.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_POOL


class IMAGE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, TYPE=None, DISK_TYPE=None, PERSISTENT=None, REGTIME=None, SOURCE=None, PATH=None, FSTYPE=None, SIZE=None, STATE=None, RUNNING_VMS=None, CLONING_OPS=None, CLONING_ID=None, TARGET_SNAPSHOT=None, DATASTORE_ID=None, DATASTORE=None, VMS=None, CLONES=None, APP_CLONES=None, TEMPLATE=None, SNAPSHOTS=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.PERMISSIONS = PERMISSIONS
        self.TYPE = TYPE
        self.DISK_TYPE = DISK_TYPE
        self.PERSISTENT = PERSISTENT
        self.REGTIME = REGTIME
        self.SOURCE = SOURCE
        self.PATH = PATH
        self.FSTYPE = FSTYPE
        self.SIZE = SIZE
        self.STATE = STATE
        self.RUNNING_VMS = RUNNING_VMS
        self.CLONING_OPS = CLONING_OPS
        self.CLONING_ID = CLONING_ID
        self.TARGET_SNAPSHOT = TARGET_SNAPSHOT
        self.DATASTORE_ID = DATASTORE_ID
        self.DATASTORE = DATASTORE
        self.VMS = VMS
        self.CLONES = CLONES
        self.APP_CLONES = APP_CLONES
        self.TEMPLATE = TEMPLATE
        self.SNAPSHOTS = SNAPSHOTS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE.subclass:
            return IMAGE.subclass(*args_, **kwargs_)
        else:
            return IMAGE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_DISK_TYPE(self): return self.DISK_TYPE
    def set_DISK_TYPE(self, DISK_TYPE): self.DISK_TYPE = DISK_TYPE
    def get_PERSISTENT(self): return self.PERSISTENT
    def set_PERSISTENT(self, PERSISTENT): self.PERSISTENT = PERSISTENT
    def get_REGTIME(self): return self.REGTIME
    def set_REGTIME(self, REGTIME): self.REGTIME = REGTIME
    def get_SOURCE(self): return self.SOURCE
    def set_SOURCE(self, SOURCE): self.SOURCE = SOURCE
    def get_PATH(self): return self.PATH
    def set_PATH(self, PATH): self.PATH = PATH
    def get_FSTYPE(self): return self.FSTYPE
    def set_FSTYPE(self, FSTYPE): self.FSTYPE = FSTYPE
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_STATE(self): return self.STATE
    def set_STATE(self, STATE): self.STATE = STATE
    def get_RUNNING_VMS(self): return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS): self.RUNNING_VMS = RUNNING_VMS
    def get_CLONING_OPS(self): return self.CLONING_OPS
    def set_CLONING_OPS(self, CLONING_OPS): self.CLONING_OPS = CLONING_OPS
    def get_CLONING_ID(self): return self.CLONING_ID
    def set_CLONING_ID(self, CLONING_ID): self.CLONING_ID = CLONING_ID
    def get_TARGET_SNAPSHOT(self): return self.TARGET_SNAPSHOT
    def set_TARGET_SNAPSHOT(self, TARGET_SNAPSHOT): self.TARGET_SNAPSHOT = TARGET_SNAPSHOT
    def get_DATASTORE_ID(self): return self.DATASTORE_ID
    def set_DATASTORE_ID(self, DATASTORE_ID): self.DATASTORE_ID = DATASTORE_ID
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_CLONES(self): return self.CLONES
    def set_CLONES(self, CLONES): self.CLONES = CLONES
    def get_APP_CLONES(self): return self.APP_CLONES
    def set_APP_CLONES(self, APP_CLONES): self.APP_CLONES = APP_CLONES
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def get_SNAPSHOTS(self): return self.SNAPSHOTS
    def set_SNAPSHOTS(self, SNAPSHOTS): self.SNAPSHOTS = SNAPSHOTS
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.TYPE is not None or
            self.DISK_TYPE is not None or
            self.PERSISTENT is not None or
            self.REGTIME is not None or
            self.SOURCE is not None or
            self.PATH is not None or
            self.FSTYPE is not None or
            self.SIZE is not None or
            self.STATE is not None or
            self.RUNNING_VMS is not None or
            self.CLONING_OPS is not None or
            self.CLONING_ID is not None or
            self.TARGET_SNAPSHOT is not None or
            self.DATASTORE_ID is not None or
            self.DATASTORE is not None or
            self.VMS is not None or
            self.CLONES is not None or
            self.APP_CLONES is not None or
            self.TEMPLATE is not None or
            self.SNAPSHOTS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TYPE>%s</TYPE>%s' % (self.gds_format_integer(self.TYPE, input_name='TYPE'), eol_))
        if self.DISK_TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DISK_TYPE>%s</DISK_TYPE>%s' % (self.gds_format_integer(self.DISK_TYPE, input_name='DISK_TYPE'), eol_))
        if self.PERSISTENT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PERSISTENT>%s</PERSISTENT>%s' % (self.gds_format_integer(self.PERSISTENT, input_name='PERSISTENT'), eol_))
        if self.REGTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<REGTIME>%s</REGTIME>%s' % (self.gds_format_integer(self.REGTIME, input_name='REGTIME'), eol_))
        if self.SOURCE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SOURCE>%s</SOURCE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SOURCE), input_name='SOURCE')), eol_))
        if self.PATH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PATH>%s</PATH>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PATH), input_name='PATH')), eol_))
        if self.FSTYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FSTYPE>%s</FSTYPE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FSTYPE), input_name='FSTYPE')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_format_integer(self.SIZE, input_name='SIZE'), eol_))
        if self.STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE>%s</STATE>%s' % (self.gds_format_integer(self.STATE, input_name='STATE'), eol_))
        if self.RUNNING_VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RUNNING_VMS>%s</RUNNING_VMS>%s' % (self.gds_format_integer(self.RUNNING_VMS, input_name='RUNNING_VMS'), eol_))
        if self.CLONING_OPS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CLONING_OPS>%s</CLONING_OPS>%s' % (self.gds_format_integer(self.CLONING_OPS, input_name='CLONING_OPS'), eol_))
        if self.CLONING_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CLONING_ID>%s</CLONING_ID>%s' % (self.gds_format_integer(self.CLONING_ID, input_name='CLONING_ID'), eol_))
        if self.TARGET_SNAPSHOT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TARGET_SNAPSHOT>%s</TARGET_SNAPSHOT>%s' % (self.gds_format_integer(self.TARGET_SNAPSHOT, input_name='TARGET_SNAPSHOT'), eol_))
        if self.DATASTORE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATASTORE_ID>%s</DATASTORE_ID>%s' % (self.gds_format_integer(self.DATASTORE_ID, input_name='DATASTORE_ID'), eol_))
        if self.DATASTORE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATASTORE>%s</DATASTORE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DATASTORE), input_name='DATASTORE')), eol_))
        if self.VMS is not None:
            self.VMS.export(outfile, level, namespace_, name_='VMS', pretty_print=pretty_print)
        if self.CLONES is not None:
            self.CLONES.export(outfile, level, namespace_, name_='CLONES', pretty_print=pretty_print)
        if self.APP_CLONES is not None:
            self.APP_CLONES.export(outfile, level, namespace_, name_='APP_CLONES', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
        if self.SNAPSHOTS is not None:
            self.SNAPSHOTS.export(outfile, level, namespace_, name_='SNAPSHOTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType31.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'TYPE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TYPE')
            self.TYPE = ival_
        elif nodeName_ == 'DISK_TYPE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_TYPE')
            self.DISK_TYPE = ival_
        elif nodeName_ == 'PERSISTENT':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PERSISTENT')
            self.PERSISTENT = ival_
        elif nodeName_ == 'REGTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'REGTIME')
            self.REGTIME = ival_
        elif nodeName_ == 'SOURCE':
            SOURCE_ = child_.text
            SOURCE_ = self.gds_validate_string(SOURCE_, node, 'SOURCE')
            self.SOURCE = SOURCE_
        elif nodeName_ == 'PATH':
            PATH_ = child_.text
            PATH_ = self.gds_validate_string(PATH_, node, 'PATH')
            self.PATH = PATH_
        elif nodeName_ == 'FSTYPE':
            FSTYPE_ = child_.text
            FSTYPE_ = self.gds_validate_string(FSTYPE_, node, 'FSTYPE')
            self.FSTYPE = FSTYPE_
        elif nodeName_ == 'SIZE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
        elif nodeName_ == 'STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
        elif nodeName_ == 'RUNNING_VMS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = ival_
        elif nodeName_ == 'CLONING_OPS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CLONING_OPS')
            self.CLONING_OPS = ival_
        elif nodeName_ == 'CLONING_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CLONING_ID')
            self.CLONING_ID = ival_
        elif nodeName_ == 'TARGET_SNAPSHOT':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TARGET_SNAPSHOT')
            self.TARGET_SNAPSHOT = ival_
        elif nodeName_ == 'DATASTORE_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DATASTORE_ID')
            self.DATASTORE_ID = ival_
        elif nodeName_ == 'DATASTORE':
            DATASTORE_ = child_.text
            DATASTORE_ = self.gds_validate_string(DATASTORE_, node, 'DATASTORE')
            self.DATASTORE = DATASTORE_
        elif nodeName_ == 'VMS':
            obj_ = VMSType32.factory()
            obj_.build(child_)
            self.VMS = obj_
            obj_.original_tagname_ = 'VMS'
        elif nodeName_ == 'CLONES':
            obj_ = CLONESType.factory()
            obj_.build(child_)
            self.CLONES = obj_
            obj_.original_tagname_ = 'CLONES'
        elif nodeName_ == 'APP_CLONES':
            obj_ = APP_CLONESType.factory()
            obj_.build(child_)
            self.APP_CLONES = obj_
            obj_.original_tagname_ = 'APP_CLONES'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
        elif nodeName_ == 'SNAPSHOTS':
            obj_ = SNAPSHOTSType33.factory()
            obj_.build(child_)
            self.SNAPSHOTS = obj_
            obj_.original_tagname_ = 'SNAPSHOTS'
# end class IMAGE


class MARKETPLACEAPP_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MARKETPLACEAPP=None):
        self.original_tagname_ = None
        if MARKETPLACEAPP is None:
            self.MARKETPLACEAPP = []
        else:
            self.MARKETPLACEAPP = MARKETPLACEAPP
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACEAPP_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACEAPP_POOL.subclass:
            return MARKETPLACEAPP_POOL.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACEAPP_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MARKETPLACEAPP(self): return self.MARKETPLACEAPP
    def set_MARKETPLACEAPP(self, MARKETPLACEAPP): self.MARKETPLACEAPP = MARKETPLACEAPP
    def add_MARKETPLACEAPP(self, value): self.MARKETPLACEAPP.append(value)
    def insert_MARKETPLACEAPP_at(self, index, value): self.MARKETPLACEAPP.insert(index, value)
    def replace_MARKETPLACEAPP_at(self, index, value): self.MARKETPLACEAPP[index] = value
    def hasContent_(self):
        if (
            self.MARKETPLACEAPP
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MARKETPLACEAPP_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACEAPP_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MARKETPLACEAPP_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MARKETPLACEAPP_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MARKETPLACEAPP_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MARKETPLACEAPP_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MARKETPLACEAPP_ in self.MARKETPLACEAPP:
            MARKETPLACEAPP_.export(outfile, level, namespace_, name_='MARKETPLACEAPP', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MARKETPLACEAPP':
            obj_ = MARKETPLACEAPP.factory()
            obj_.build(child_)
            self.MARKETPLACEAPP.append(obj_)
            obj_.original_tagname_ = 'MARKETPLACEAPP'
# end class MARKETPLACEAPP_POOL


class MARKETPLACEAPP(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, REGTIME=None, NAME=None, ZONE_ID=None, ORIGIN_ID=None, SOURCE=None, MD5=None, SIZE=None, DESCRIPTION=None, VERSION=None, FORMAT=None, APPTEMPLATE64=None, MARKETPLACE_ID=None, MARKETPLACE=None, STATE=None, TYPE=None, PERMISSIONS=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.REGTIME = REGTIME
        self.NAME = NAME
        self.ZONE_ID = ZONE_ID
        self.ORIGIN_ID = ORIGIN_ID
        self.SOURCE = SOURCE
        self.MD5 = MD5
        self.SIZE = SIZE
        self.DESCRIPTION = DESCRIPTION
        self.VERSION = VERSION
        self.FORMAT = FORMAT
        self.APPTEMPLATE64 = APPTEMPLATE64
        self.MARKETPLACE_ID = MARKETPLACE_ID
        self.MARKETPLACE = MARKETPLACE
        self.STATE = STATE
        self.TYPE = TYPE
        self.PERMISSIONS = PERMISSIONS
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACEAPP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACEAPP.subclass:
            return MARKETPLACEAPP.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACEAPP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_REGTIME(self): return self.REGTIME
    def set_REGTIME(self, REGTIME): self.REGTIME = REGTIME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_ZONE_ID(self): return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID): self.ZONE_ID = ZONE_ID
    def get_ORIGIN_ID(self): return self.ORIGIN_ID
    def set_ORIGIN_ID(self, ORIGIN_ID): self.ORIGIN_ID = ORIGIN_ID
    def get_SOURCE(self): return self.SOURCE
    def set_SOURCE(self, SOURCE): self.SOURCE = SOURCE
    def get_MD5(self): return self.MD5
    def set_MD5(self, MD5): self.MD5 = MD5
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_VERSION(self): return self.VERSION
    def set_VERSION(self, VERSION): self.VERSION = VERSION
    def get_FORMAT(self): return self.FORMAT
    def set_FORMAT(self, FORMAT): self.FORMAT = FORMAT
    def get_APPTEMPLATE64(self): return self.APPTEMPLATE64
    def set_APPTEMPLATE64(self, APPTEMPLATE64): self.APPTEMPLATE64 = APPTEMPLATE64
    def get_MARKETPLACE_ID(self): return self.MARKETPLACE_ID
    def set_MARKETPLACE_ID(self, MARKETPLACE_ID): self.MARKETPLACE_ID = MARKETPLACE_ID
    def get_MARKETPLACE(self): return self.MARKETPLACE
    def set_MARKETPLACE(self, MARKETPLACE): self.MARKETPLACE = MARKETPLACE
    def get_STATE(self): return self.STATE
    def set_STATE(self, STATE): self.STATE = STATE
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.REGTIME is not None or
            self.NAME is not None or
            self.ZONE_ID is not None or
            self.ORIGIN_ID is not None or
            self.SOURCE is not None or
            self.MD5 is not None or
            self.SIZE is not None or
            self.DESCRIPTION is not None or
            self.VERSION is not None or
            self.FORMAT is not None or
            self.APPTEMPLATE64 is not None or
            self.MARKETPLACE_ID is not None or
            self.MARKETPLACE is not None or
            self.STATE is not None or
            self.TYPE is not None or
            self.PERMISSIONS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MARKETPLACEAPP', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACEAPP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MARKETPLACEAPP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MARKETPLACEAPP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MARKETPLACEAPP'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MARKETPLACEAPP', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.REGTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<REGTIME>%s</REGTIME>%s' % (self.gds_format_integer(self.REGTIME, input_name='REGTIME'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.ZONE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ZONE_ID>%s</ZONE_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZONE_ID), input_name='ZONE_ID')), eol_))
        if self.ORIGIN_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ORIGIN_ID>%s</ORIGIN_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ORIGIN_ID), input_name='ORIGIN_ID')), eol_))
        if self.SOURCE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SOURCE>%s</SOURCE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SOURCE), input_name='SOURCE')), eol_))
        if self.MD5 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MD5>%s</MD5>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MD5), input_name='MD5')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_format_integer(self.SIZE, input_name='SIZE'), eol_))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DESCRIPTION>%s</DESCRIPTION>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), eol_))
        if self.VERSION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VERSION>%s</VERSION>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VERSION), input_name='VERSION')), eol_))
        if self.FORMAT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FORMAT>%s</FORMAT>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FORMAT), input_name='FORMAT')), eol_))
        if self.APPTEMPLATE64 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<APPTEMPLATE64>%s</APPTEMPLATE64>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.APPTEMPLATE64), input_name='APPTEMPLATE64')), eol_))
        if self.MARKETPLACE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MARKETPLACE_ID>%s</MARKETPLACE_ID>%s' % (self.gds_format_integer(self.MARKETPLACE_ID, input_name='MARKETPLACE_ID'), eol_))
        if self.MARKETPLACE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MARKETPLACE>%s</MARKETPLACE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MARKETPLACE), input_name='MARKETPLACE')), eol_))
        if self.STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE>%s</STATE>%s' % (self.gds_format_integer(self.STATE, input_name='STATE'), eol_))
        if self.TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TYPE>%s</TYPE>%s' % (self.gds_format_integer(self.TYPE, input_name='TYPE'), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'REGTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'REGTIME')
            self.REGTIME = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'ZONE_ID':
            ZONE_ID_ = child_.text
            ZONE_ID_ = self.gds_validate_string(ZONE_ID_, node, 'ZONE_ID')
            self.ZONE_ID = ZONE_ID_
        elif nodeName_ == 'ORIGIN_ID':
            ORIGIN_ID_ = child_.text
            ORIGIN_ID_ = self.gds_validate_string(ORIGIN_ID_, node, 'ORIGIN_ID')
            self.ORIGIN_ID = ORIGIN_ID_
        elif nodeName_ == 'SOURCE':
            SOURCE_ = child_.text
            SOURCE_ = self.gds_validate_string(SOURCE_, node, 'SOURCE')
            self.SOURCE = SOURCE_
        elif nodeName_ == 'MD5':
            MD5_ = child_.text
            MD5_ = self.gds_validate_string(MD5_, node, 'MD5')
            self.MD5 = MD5_
        elif nodeName_ == 'SIZE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
        elif nodeName_ == 'VERSION':
            VERSION_ = child_.text
            VERSION_ = self.gds_validate_string(VERSION_, node, 'VERSION')
            self.VERSION = VERSION_
        elif nodeName_ == 'FORMAT':
            FORMAT_ = child_.text
            FORMAT_ = self.gds_validate_string(FORMAT_, node, 'FORMAT')
            self.FORMAT = FORMAT_
        elif nodeName_ == 'APPTEMPLATE64':
            APPTEMPLATE64_ = child_.text
            APPTEMPLATE64_ = self.gds_validate_string(APPTEMPLATE64_, node, 'APPTEMPLATE64')
            self.APPTEMPLATE64 = APPTEMPLATE64_
        elif nodeName_ == 'MARKETPLACE_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MARKETPLACE_ID')
            self.MARKETPLACE_ID = ival_
        elif nodeName_ == 'MARKETPLACE':
            MARKETPLACE_ = child_.text
            MARKETPLACE_ = self.gds_validate_string(MARKETPLACE_, node, 'MARKETPLACE')
            self.MARKETPLACE = MARKETPLACE_
        elif nodeName_ == 'STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
        elif nodeName_ == 'TYPE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TYPE')
            self.TYPE = ival_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType35.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class MARKETPLACEAPP


class MARKETPLACE_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MARKETPLACE=None):
        self.original_tagname_ = None
        if MARKETPLACE is None:
            self.MARKETPLACE = []
        else:
            self.MARKETPLACE = MARKETPLACE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACE_POOL.subclass:
            return MARKETPLACE_POOL.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MARKETPLACE(self): return self.MARKETPLACE
    def set_MARKETPLACE(self, MARKETPLACE): self.MARKETPLACE = MARKETPLACE
    def add_MARKETPLACE(self, value): self.MARKETPLACE.append(value)
    def insert_MARKETPLACE_at(self, index, value): self.MARKETPLACE.insert(index, value)
    def replace_MARKETPLACE_at(self, index, value): self.MARKETPLACE[index] = value
    def hasContent_(self):
        if (
            self.MARKETPLACE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MARKETPLACE_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MARKETPLACE_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MARKETPLACE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MARKETPLACE_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MARKETPLACE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MARKETPLACE_ in self.MARKETPLACE:
            MARKETPLACE_.export(outfile, level, namespace_, name_='MARKETPLACE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MARKETPLACE':
            obj_ = MARKETPLACE.factory()
            obj_.build(child_)
            self.MARKETPLACE.append(obj_)
            obj_.original_tagname_ = 'MARKETPLACE'
# end class MARKETPLACE_POOL


class MARKETPLACE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, MARKET_MAD=None, ZONE_ID=None, TOTAL_MB=None, FREE_MB=None, USED_MB=None, MARKETPLACEAPPS=None, PERMISSIONS=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.MARKET_MAD = MARKET_MAD
        self.ZONE_ID = ZONE_ID
        self.TOTAL_MB = TOTAL_MB
        self.FREE_MB = FREE_MB
        self.USED_MB = USED_MB
        self.MARKETPLACEAPPS = MARKETPLACEAPPS
        self.PERMISSIONS = PERMISSIONS
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACE.subclass:
            return MARKETPLACE.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_MARKET_MAD(self): return self.MARKET_MAD
    def set_MARKET_MAD(self, MARKET_MAD): self.MARKET_MAD = MARKET_MAD
    def get_ZONE_ID(self): return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID): self.ZONE_ID = ZONE_ID
    def get_TOTAL_MB(self): return self.TOTAL_MB
    def set_TOTAL_MB(self, TOTAL_MB): self.TOTAL_MB = TOTAL_MB
    def get_FREE_MB(self): return self.FREE_MB
    def set_FREE_MB(self, FREE_MB): self.FREE_MB = FREE_MB
    def get_USED_MB(self): return self.USED_MB
    def set_USED_MB(self, USED_MB): self.USED_MB = USED_MB
    def get_MARKETPLACEAPPS(self): return self.MARKETPLACEAPPS
    def set_MARKETPLACEAPPS(self, MARKETPLACEAPPS): self.MARKETPLACEAPPS = MARKETPLACEAPPS
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.MARKET_MAD is not None or
            self.ZONE_ID is not None or
            self.TOTAL_MB is not None or
            self.FREE_MB is not None or
            self.USED_MB is not None or
            self.MARKETPLACEAPPS is not None or
            self.PERMISSIONS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MARKETPLACE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MARKETPLACE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MARKETPLACE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MARKETPLACE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MARKETPLACE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.MARKET_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MARKET_MAD>%s</MARKET_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MARKET_MAD), input_name='MARKET_MAD')), eol_))
        if self.ZONE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ZONE_ID>%s</ZONE_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZONE_ID), input_name='ZONE_ID')), eol_))
        if self.TOTAL_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TOTAL_MB>%s</TOTAL_MB>%s' % (self.gds_format_integer(self.TOTAL_MB, input_name='TOTAL_MB'), eol_))
        if self.FREE_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FREE_MB>%s</FREE_MB>%s' % (self.gds_format_integer(self.FREE_MB, input_name='FREE_MB'), eol_))
        if self.USED_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_MB>%s</USED_MB>%s' % (self.gds_format_integer(self.USED_MB, input_name='USED_MB'), eol_))
        if self.MARKETPLACEAPPS is not None:
            self.MARKETPLACEAPPS.export(outfile, level, namespace_, name_='MARKETPLACEAPPS', pretty_print=pretty_print)
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'MARKET_MAD':
            MARKET_MAD_ = child_.text
            MARKET_MAD_ = self.gds_validate_string(MARKET_MAD_, node, 'MARKET_MAD')
            self.MARKET_MAD = MARKET_MAD_
        elif nodeName_ == 'ZONE_ID':
            ZONE_ID_ = child_.text
            ZONE_ID_ = self.gds_validate_string(ZONE_ID_, node, 'ZONE_ID')
            self.ZONE_ID = ZONE_ID_
        elif nodeName_ == 'TOTAL_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_MB')
            self.TOTAL_MB = ival_
        elif nodeName_ == 'FREE_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_MB')
            self.FREE_MB = ival_
        elif nodeName_ == 'USED_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'USED_MB')
            self.USED_MB = ival_
        elif nodeName_ == 'MARKETPLACEAPPS':
            obj_ = MARKETPLACEAPPSType.factory()
            obj_.build(child_)
            self.MARKETPLACEAPPS = obj_
            obj_.original_tagname_ = 'MARKETPLACEAPPS'
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType36.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class MARKETPLACE


class USER_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, USER=None, QUOTAS=None, DEFAULT_USER_QUOTAS=None):
        self.original_tagname_ = None
        if USER is None:
            self.USER = []
        else:
            self.USER = USER
        if QUOTAS is None:
            self.QUOTAS = []
        else:
            self.QUOTAS = QUOTAS
        self.DEFAULT_USER_QUOTAS = DEFAULT_USER_QUOTAS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USER_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USER_POOL.subclass:
            return USER_POOL.subclass(*args_, **kwargs_)
        else:
            return USER_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USER(self): return self.USER
    def set_USER(self, USER): self.USER = USER
    def add_USER(self, value): self.USER.append(value)
    def insert_USER_at(self, index, value): self.USER.insert(index, value)
    def replace_USER_at(self, index, value): self.USER[index] = value
    def get_QUOTAS(self): return self.QUOTAS
    def set_QUOTAS(self, QUOTAS): self.QUOTAS = QUOTAS
    def add_QUOTAS(self, value): self.QUOTAS.append(value)
    def insert_QUOTAS_at(self, index, value): self.QUOTAS.insert(index, value)
    def replace_QUOTAS_at(self, index, value): self.QUOTAS[index] = value
    def get_DEFAULT_USER_QUOTAS(self): return self.DEFAULT_USER_QUOTAS
    def set_DEFAULT_USER_QUOTAS(self, DEFAULT_USER_QUOTAS): self.DEFAULT_USER_QUOTAS = DEFAULT_USER_QUOTAS
    def hasContent_(self):
        if (
            self.USER or
            self.QUOTAS or
            self.DEFAULT_USER_QUOTAS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='USER_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USER_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='USER_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='USER_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='USER_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='USER_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for USER_ in self.USER:
            USER_.export(outfile, level, namespace_, name_='USER', pretty_print=pretty_print)
        for QUOTAS_ in self.QUOTAS:
            QUOTAS_.export(outfile, level, namespace_, name_='QUOTAS', pretty_print=pretty_print)
        if self.DEFAULT_USER_QUOTAS is not None:
            self.DEFAULT_USER_QUOTAS.export(outfile, level, namespace_, name_='DEFAULT_USER_QUOTAS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USER':
            obj_ = USERType.factory()
            obj_.build(child_)
            self.USER.append(obj_)
            obj_.original_tagname_ = 'USER'
        elif nodeName_ == 'QUOTAS':
            obj_ = QUOTASType37.factory()
            obj_.build(child_)
            self.QUOTAS.append(obj_)
            obj_.original_tagname_ = 'QUOTAS'
        elif nodeName_ == 'DEFAULT_USER_QUOTAS':
            obj_ = DEFAULT_USER_QUOTASType.factory()
            obj_.build(child_)
            self.DEFAULT_USER_QUOTAS = obj_
            obj_.original_tagname_ = 'DEFAULT_USER_QUOTAS'
# end class USER_POOL


class USER(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, GID=None, GROUPS=None, GNAME=None, NAME=None, PASSWORD=None, AUTH_DRIVER=None, ENABLED=None, LOGIN_TOKEN=None, TEMPLATE=None, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None, DEFAULT_USER_QUOTAS=None):
        self.original_tagname_ = None
        self.ID = ID
        self.GID = GID
        self.GROUPS = GROUPS
        self.GNAME = GNAME
        self.NAME = NAME
        self.PASSWORD = PASSWORD
        self.AUTH_DRIVER = AUTH_DRIVER
        self.ENABLED = ENABLED
        if LOGIN_TOKEN is None:
            self.LOGIN_TOKEN = []
        else:
            self.LOGIN_TOKEN = LOGIN_TOKEN
        self.TEMPLATE = TEMPLATE
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.VM_QUOTA = VM_QUOTA
        self.IMAGE_QUOTA = IMAGE_QUOTA
        self.DEFAULT_USER_QUOTAS = DEFAULT_USER_QUOTAS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USER.subclass:
            return USER.subclass(*args_, **kwargs_)
        else:
            return USER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_GROUPS(self): return self.GROUPS
    def set_GROUPS(self, GROUPS): self.GROUPS = GROUPS
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PASSWORD(self): return self.PASSWORD
    def set_PASSWORD(self, PASSWORD): self.PASSWORD = PASSWORD
    def get_AUTH_DRIVER(self): return self.AUTH_DRIVER
    def set_AUTH_DRIVER(self, AUTH_DRIVER): self.AUTH_DRIVER = AUTH_DRIVER
    def get_ENABLED(self): return self.ENABLED
    def set_ENABLED(self, ENABLED): self.ENABLED = ENABLED
    def get_LOGIN_TOKEN(self): return self.LOGIN_TOKEN
    def set_LOGIN_TOKEN(self, LOGIN_TOKEN): self.LOGIN_TOKEN = LOGIN_TOKEN
    def add_LOGIN_TOKEN(self, value): self.LOGIN_TOKEN.append(value)
    def insert_LOGIN_TOKEN_at(self, index, value): self.LOGIN_TOKEN.insert(index, value)
    def replace_LOGIN_TOKEN_at(self, index, value): self.LOGIN_TOKEN[index] = value
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def get_DATASTORE_QUOTA(self): return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA): self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self): return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA): self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self): return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA): self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self): return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA): self.IMAGE_QUOTA = IMAGE_QUOTA
    def get_DEFAULT_USER_QUOTAS(self): return self.DEFAULT_USER_QUOTAS
    def set_DEFAULT_USER_QUOTAS(self, DEFAULT_USER_QUOTAS): self.DEFAULT_USER_QUOTAS = DEFAULT_USER_QUOTAS
    def hasContent_(self):
        if (
            self.ID is not None or
            self.GID is not None or
            self.GROUPS is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PASSWORD is not None or
            self.AUTH_DRIVER is not None or
            self.ENABLED is not None or
            self.LOGIN_TOKEN or
            self.TEMPLATE is not None or
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None or
            self.DEFAULT_USER_QUOTAS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='USER', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USER')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='USER')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='USER', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='USER'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='USER', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.GROUPS is not None:
            self.GROUPS.export(outfile, level, namespace_, name_='GROUPS', pretty_print=pretty_print)
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PASSWORD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PASSWORD>%s</PASSWORD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PASSWORD), input_name='PASSWORD')), eol_))
        if self.AUTH_DRIVER is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AUTH_DRIVER>%s</AUTH_DRIVER>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AUTH_DRIVER), input_name='AUTH_DRIVER')), eol_))
        if self.ENABLED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ENABLED>%s</ENABLED>%s' % (self.gds_format_integer(self.ENABLED, input_name='ENABLED'), eol_))
        for LOGIN_TOKEN_ in self.LOGIN_TOKEN:
            LOGIN_TOKEN_.export(outfile, level, namespace_, name_='LOGIN_TOKEN', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
        if self.DATASTORE_QUOTA is not None:
            self.DATASTORE_QUOTA.export(outfile, level, namespace_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            self.NETWORK_QUOTA.export(outfile, level, namespace_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            self.VM_QUOTA.export(outfile, level, namespace_, name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            self.IMAGE_QUOTA.export(outfile, level, namespace_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
        if self.DEFAULT_USER_QUOTAS is not None:
            self.DEFAULT_USER_QUOTAS.export(outfile, level, namespace_, name_='DEFAULT_USER_QUOTAS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'GROUPS':
            obj_ = GROUPSType54.factory()
            obj_.build(child_)
            self.GROUPS = obj_
            obj_.original_tagname_ = 'GROUPS'
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PASSWORD':
            PASSWORD_ = child_.text
            PASSWORD_ = self.gds_validate_string(PASSWORD_, node, 'PASSWORD')
            self.PASSWORD = PASSWORD_
        elif nodeName_ == 'AUTH_DRIVER':
            AUTH_DRIVER_ = child_.text
            AUTH_DRIVER_ = self.gds_validate_string(AUTH_DRIVER_, node, 'AUTH_DRIVER')
            self.AUTH_DRIVER = AUTH_DRIVER_
        elif nodeName_ == 'ENABLED':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ENABLED')
            self.ENABLED = ival_
        elif nodeName_ == 'LOGIN_TOKEN':
            obj_ = LOGIN_TOKENType55.factory()
            obj_.build(child_)
            self.LOGIN_TOKEN.append(obj_)
            obj_.original_tagname_ = 'LOGIN_TOKEN'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
        elif nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTAType56.factory()
            obj_.build(child_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTAType58.factory()
            obj_.build(child_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType60.factory()
            obj_.build(child_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTAType62.factory()
            obj_.build(child_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
        elif nodeName_ == 'DEFAULT_USER_QUOTAS':
            obj_ = DEFAULT_USER_QUOTASType64.factory()
            obj_.build(child_)
            self.DEFAULT_USER_QUOTAS = obj_
            obj_.original_tagname_ = 'DEFAULT_USER_QUOTAS'
# end class USER


class VDC_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VDC=None):
        self.original_tagname_ = None
        if VDC is None:
            self.VDC = []
        else:
            self.VDC = VDC
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VDC_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VDC_POOL.subclass:
            return VDC_POOL.subclass(*args_, **kwargs_)
        else:
            return VDC_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VDC(self): return self.VDC
    def set_VDC(self, VDC): self.VDC = VDC
    def add_VDC(self, value): self.VDC.append(value)
    def insert_VDC_at(self, index, value): self.VDC.insert(index, value)
    def replace_VDC_at(self, index, value): self.VDC[index] = value
    def hasContent_(self):
        if (
            self.VDC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VDC_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VDC_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VDC_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VDC_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VDC_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VDC_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VDC_ in self.VDC:
            VDC_.export(outfile, level, namespace_, name_='VDC', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VDC':
            obj_ = VDC.factory()
            obj_.build(child_)
            self.VDC.append(obj_)
            obj_.original_tagname_ = 'VDC'
# end class VDC_POOL


class VDC(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, GROUPS=None, CLUSTERS=None, HOSTS=None, DATASTORES=None, VNETS=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.NAME = NAME
        self.GROUPS = GROUPS
        self.CLUSTERS = CLUSTERS
        self.HOSTS = HOSTS
        self.DATASTORES = DATASTORES
        self.VNETS = VNETS
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VDC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VDC.subclass:
            return VDC.subclass(*args_, **kwargs_)
        else:
            return VDC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_GROUPS(self): return self.GROUPS
    def set_GROUPS(self, GROUPS): self.GROUPS = GROUPS
    def get_CLUSTERS(self): return self.CLUSTERS
    def set_CLUSTERS(self, CLUSTERS): self.CLUSTERS = CLUSTERS
    def get_HOSTS(self): return self.HOSTS
    def set_HOSTS(self, HOSTS): self.HOSTS = HOSTS
    def get_DATASTORES(self): return self.DATASTORES
    def set_DATASTORES(self, DATASTORES): self.DATASTORES = DATASTORES
    def get_VNETS(self): return self.VNETS
    def set_VNETS(self, VNETS): self.VNETS = VNETS
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.GROUPS is not None or
            self.CLUSTERS is not None or
            self.HOSTS is not None or
            self.DATASTORES is not None or
            self.VNETS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VDC', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VDC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VDC')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VDC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VDC'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VDC', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.GROUPS is not None:
            self.GROUPS.export(outfile, level, namespace_, name_='GROUPS', pretty_print=pretty_print)
        if self.CLUSTERS is not None:
            self.CLUSTERS.export(outfile, level, namespace_, name_='CLUSTERS', pretty_print=pretty_print)
        if self.HOSTS is not None:
            self.HOSTS.export(outfile, level, namespace_, name_='HOSTS', pretty_print=pretty_print)
        if self.DATASTORES is not None:
            self.DATASTORES.export(outfile, level, namespace_, name_='DATASTORES', pretty_print=pretty_print)
        if self.VNETS is not None:
            self.VNETS.export(outfile, level, namespace_, name_='VNETS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'GROUPS':
            obj_ = GROUPSType73.factory()
            obj_.build(child_)
            self.GROUPS = obj_
            obj_.original_tagname_ = 'GROUPS'
        elif nodeName_ == 'CLUSTERS':
            obj_ = CLUSTERSType74.factory()
            obj_.build(child_)
            self.CLUSTERS = obj_
            obj_.original_tagname_ = 'CLUSTERS'
        elif nodeName_ == 'HOSTS':
            obj_ = HOSTSType75.factory()
            obj_.build(child_)
            self.HOSTS = obj_
            obj_.original_tagname_ = 'HOSTS'
        elif nodeName_ == 'DATASTORES':
            obj_ = DATASTORESType76.factory()
            obj_.build(child_)
            self.DATASTORES = obj_
            obj_.original_tagname_ = 'DATASTORES'
        elif nodeName_ == 'VNETS':
            obj_ = VNETSType78.factory()
            obj_.build(child_)
            self.VNETS = obj_
            obj_.original_tagname_ = 'VNETS'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class VDC


class VM_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        if VM is None:
            self.VM = []
        else:
            self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_POOL.subclass:
            return VM_POOL.subclass(*args_, **kwargs_)
        else:
            return VM_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def add_VM(self, value): self.VM.append(value)
    def insert_VM_at(self, index, value): self.VM.insert(index, value)
    def replace_VM_at(self, index, value): self.VM[index] = value
    def hasContent_(self):
        if (
            self.VM
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VM_ in self.VM:
            VM_.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VM.factory()
            obj_.build(child_)
            self.VM.append(obj_)
            obj_.original_tagname_ = 'VM'
# end class VM_POOL


class VM(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, LAST_POLL=None, STATE=None, LCM_STATE=None, PREV_STATE=None, PREV_LCM_STATE=None, RESCHED=None, STIME=None, ETIME=None, DEPLOY_ID=None, MONITORING=None, TEMPLATE=None, USER_TEMPLATE=None, HISTORY_RECORDS=None, SNAPSHOTS=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.PERMISSIONS = PERMISSIONS
        self.LAST_POLL = LAST_POLL
        self.STATE = STATE
        self.LCM_STATE = LCM_STATE
        self.PREV_STATE = PREV_STATE
        self.PREV_LCM_STATE = PREV_LCM_STATE
        self.RESCHED = RESCHED
        self.STIME = STIME
        self.ETIME = ETIME
        self.DEPLOY_ID = DEPLOY_ID
        self.MONITORING = MONITORING
        self.TEMPLATE = TEMPLATE
        self.USER_TEMPLATE = USER_TEMPLATE
        self.HISTORY_RECORDS = HISTORY_RECORDS
        if SNAPSHOTS is None:
            self.SNAPSHOTS = []
        else:
            self.SNAPSHOTS = SNAPSHOTS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM.subclass:
            return VM.subclass(*args_, **kwargs_)
        else:
            return VM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_LAST_POLL(self): return self.LAST_POLL
    def set_LAST_POLL(self, LAST_POLL): self.LAST_POLL = LAST_POLL
    def get_STATE(self): return self.STATE
    def set_STATE(self, STATE): self.STATE = STATE
    def get_LCM_STATE(self): return self.LCM_STATE
    def set_LCM_STATE(self, LCM_STATE): self.LCM_STATE = LCM_STATE
    def get_PREV_STATE(self): return self.PREV_STATE
    def set_PREV_STATE(self, PREV_STATE): self.PREV_STATE = PREV_STATE
    def get_PREV_LCM_STATE(self): return self.PREV_LCM_STATE
    def set_PREV_LCM_STATE(self, PREV_LCM_STATE): self.PREV_LCM_STATE = PREV_LCM_STATE
    def get_RESCHED(self): return self.RESCHED
    def set_RESCHED(self, RESCHED): self.RESCHED = RESCHED
    def get_STIME(self): return self.STIME
    def set_STIME(self, STIME): self.STIME = STIME
    def get_ETIME(self): return self.ETIME
    def set_ETIME(self, ETIME): self.ETIME = ETIME
    def get_DEPLOY_ID(self): return self.DEPLOY_ID
    def set_DEPLOY_ID(self, DEPLOY_ID): self.DEPLOY_ID = DEPLOY_ID
    def get_MONITORING(self): return self.MONITORING
    def set_MONITORING(self, MONITORING): self.MONITORING = MONITORING
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def get_USER_TEMPLATE(self): return self.USER_TEMPLATE
    def set_USER_TEMPLATE(self, USER_TEMPLATE): self.USER_TEMPLATE = USER_TEMPLATE
    def get_HISTORY_RECORDS(self): return self.HISTORY_RECORDS
    def set_HISTORY_RECORDS(self, HISTORY_RECORDS): self.HISTORY_RECORDS = HISTORY_RECORDS
    def get_SNAPSHOTS(self): return self.SNAPSHOTS
    def set_SNAPSHOTS(self, SNAPSHOTS): self.SNAPSHOTS = SNAPSHOTS
    def add_SNAPSHOTS(self, value): self.SNAPSHOTS.append(value)
    def insert_SNAPSHOTS_at(self, index, value): self.SNAPSHOTS.insert(index, value)
    def replace_SNAPSHOTS_at(self, index, value): self.SNAPSHOTS[index] = value
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.LAST_POLL is not None or
            self.STATE is not None or
            self.LCM_STATE is not None or
            self.PREV_STATE is not None or
            self.PREV_LCM_STATE is not None or
            self.RESCHED is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.DEPLOY_ID is not None or
            self.MONITORING is not None or
            self.TEMPLATE is not None or
            self.USER_TEMPLATE is not None or
            self.HISTORY_RECORDS is not None or
            self.SNAPSHOTS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.LAST_POLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LAST_POLL>%s</LAST_POLL>%s' % (self.gds_format_integer(self.LAST_POLL, input_name='LAST_POLL'), eol_))
        if self.STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE>%s</STATE>%s' % (self.gds_format_integer(self.STATE, input_name='STATE'), eol_))
        if self.LCM_STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LCM_STATE>%s</LCM_STATE>%s' % (self.gds_format_integer(self.LCM_STATE, input_name='LCM_STATE'), eol_))
        if self.PREV_STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PREV_STATE>%s</PREV_STATE>%s' % (self.gds_format_integer(self.PREV_STATE, input_name='PREV_STATE'), eol_))
        if self.PREV_LCM_STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PREV_LCM_STATE>%s</PREV_LCM_STATE>%s' % (self.gds_format_integer(self.PREV_LCM_STATE, input_name='PREV_LCM_STATE'), eol_))
        if self.RESCHED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RESCHED>%s</RESCHED>%s' % (self.gds_format_integer(self.RESCHED, input_name='RESCHED'), eol_))
        if self.STIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STIME>%s</STIME>%s' % (self.gds_format_integer(self.STIME, input_name='STIME'), eol_))
        if self.ETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ETIME>%s</ETIME>%s' % (self.gds_format_integer(self.ETIME, input_name='ETIME'), eol_))
        if self.DEPLOY_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DEPLOY_ID>%s</DEPLOY_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DEPLOY_ID), input_name='DEPLOY_ID')), eol_))
        if self.MONITORING is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MONITORING>%s</MONITORING>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MONITORING), input_name='MONITORING')), eol_))
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
        if self.USER_TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USER_TEMPLATE>%s</USER_TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USER_TEMPLATE), input_name='USER_TEMPLATE')), eol_))
        if self.HISTORY_RECORDS is not None:
            self.HISTORY_RECORDS.export(outfile, level, namespace_, name_='HISTORY_RECORDS', pretty_print=pretty_print)
        for SNAPSHOTS_ in self.SNAPSHOTS:
            SNAPSHOTS_.export(outfile, level, namespace_, name_='SNAPSHOTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType79.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'LAST_POLL':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LAST_POLL')
            self.LAST_POLL = ival_
        elif nodeName_ == 'STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
        elif nodeName_ == 'LCM_STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LCM_STATE')
            self.LCM_STATE = ival_
        elif nodeName_ == 'PREV_STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_STATE')
            self.PREV_STATE = ival_
        elif nodeName_ == 'PREV_LCM_STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_LCM_STATE')
            self.PREV_LCM_STATE = ival_
        elif nodeName_ == 'RESCHED':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RESCHED')
            self.RESCHED = ival_
        elif nodeName_ == 'STIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
        elif nodeName_ == 'ETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
        elif nodeName_ == 'DEPLOY_ID':
            DEPLOY_ID_ = child_.text
            DEPLOY_ID_ = self.gds_validate_string(DEPLOY_ID_, node, 'DEPLOY_ID')
            self.DEPLOY_ID = DEPLOY_ID_
        elif nodeName_ == 'MONITORING':
            MONITORING_ = child_.text
            MONITORING_ = self.gds_validate_string(MONITORING_, node, 'MONITORING')
            self.MONITORING = MONITORING_
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
        elif nodeName_ == 'USER_TEMPLATE':
            USER_TEMPLATE_ = child_.text
            USER_TEMPLATE_ = self.gds_validate_string(USER_TEMPLATE_, node, 'USER_TEMPLATE')
            self.USER_TEMPLATE = USER_TEMPLATE_
        elif nodeName_ == 'HISTORY_RECORDS':
            obj_ = HISTORY_RECORDSType.factory()
            obj_.build(child_)
            self.HISTORY_RECORDS = obj_
            obj_.original_tagname_ = 'HISTORY_RECORDS'
        elif nodeName_ == 'SNAPSHOTS':
            obj_ = SNAPSHOTSType80.factory()
            obj_.build(child_)
            self.SNAPSHOTS.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOTS'
# end class VM


class MONITORING(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MONITORING)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MONITORING.subclass:
            return MONITORING.subclass(*args_, **kwargs_)
        else:
            return MONITORING(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MONITORING', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MONITORING')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MONITORING')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MONITORING', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MONITORING'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MONITORING', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MONITORING


class VMTEMPLATE_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VMTEMPLATE=None):
        self.original_tagname_ = None
        if VMTEMPLATE is None:
            self.VMTEMPLATE = []
        else:
            self.VMTEMPLATE = VMTEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMTEMPLATE_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMTEMPLATE_POOL.subclass:
            return VMTEMPLATE_POOL.subclass(*args_, **kwargs_)
        else:
            return VMTEMPLATE_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VMTEMPLATE(self): return self.VMTEMPLATE
    def set_VMTEMPLATE(self, VMTEMPLATE): self.VMTEMPLATE = VMTEMPLATE
    def add_VMTEMPLATE(self, value): self.VMTEMPLATE.append(value)
    def insert_VMTEMPLATE_at(self, index, value): self.VMTEMPLATE.insert(index, value)
    def replace_VMTEMPLATE_at(self, index, value): self.VMTEMPLATE[index] = value
    def hasContent_(self):
        if (
            self.VMTEMPLATE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMTEMPLATE_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMTEMPLATE_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMTEMPLATE_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMTEMPLATE_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMTEMPLATE_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMTEMPLATE_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VMTEMPLATE_ in self.VMTEMPLATE:
            VMTEMPLATE_.export(outfile, level, namespace_, name_='VMTEMPLATE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VMTEMPLATE':
            obj_ = VMTEMPLATE.factory()
            obj_.build(child_)
            self.VMTEMPLATE.append(obj_)
            obj_.original_tagname_ = 'VMTEMPLATE'
# end class VMTEMPLATE_POOL


class VMTEMPLATE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, REGTIME=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.PERMISSIONS = PERMISSIONS
        self.REGTIME = REGTIME
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMTEMPLATE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMTEMPLATE.subclass:
            return VMTEMPLATE.subclass(*args_, **kwargs_)
        else:
            return VMTEMPLATE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_REGTIME(self): return self.REGTIME
    def set_REGTIME(self, REGTIME): self.REGTIME = REGTIME
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.REGTIME is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMTEMPLATE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMTEMPLATE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMTEMPLATE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMTEMPLATE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMTEMPLATE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMTEMPLATE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.REGTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<REGTIME>%s</REGTIME>%s' % (self.gds_format_integer(self.REGTIME, input_name='REGTIME'), eol_))
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType82.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'REGTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'REGTIME')
            self.REGTIME = ival_
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class VMTEMPLATE


class VNET_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VNET=None):
        self.original_tagname_ = None
        if VNET is None:
            self.VNET = []
        else:
            self.VNET = VNET
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNET_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNET_POOL.subclass:
            return VNET_POOL.subclass(*args_, **kwargs_)
        else:
            return VNET_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VNET(self): return self.VNET
    def set_VNET(self, VNET): self.VNET = VNET
    def add_VNET(self, value): self.VNET.append(value)
    def insert_VNET_at(self, index, value): self.VNET.insert(index, value)
    def replace_VNET_at(self, index, value): self.VNET[index] = value
    def hasContent_(self):
        if (
            self.VNET
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VNET_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNET_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VNET_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VNET_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VNET_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VNET_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VNET_ in self.VNET:
            VNET_.export(outfile, level, namespace_, name_='VNET', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VNET':
            obj_ = VNETType83.factory()
            obj_.build(child_)
            self.VNET.append(obj_)
            obj_.original_tagname_ = 'VNET'
# end class VNET_POOL


class VNET(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, CLUSTERS=None, BRIDGE=None, PARENT_NETWORK_ID=None, VN_MAD=None, PHYDEV=None, VLAN_ID=None, VLAN_ID_AUTOMATIC=None, USED_LEASES=None, VROUTERS=None, TEMPLATE=None, AR_POOL=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.PERMISSIONS = PERMISSIONS
        self.CLUSTERS = CLUSTERS
        self.BRIDGE = BRIDGE
        self.PARENT_NETWORK_ID = PARENT_NETWORK_ID
        self.VN_MAD = VN_MAD
        self.PHYDEV = PHYDEV
        self.VLAN_ID = VLAN_ID
        self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC
        self.USED_LEASES = USED_LEASES
        self.VROUTERS = VROUTERS
        self.TEMPLATE = TEMPLATE
        self.AR_POOL = AR_POOL
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNET)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNET.subclass:
            return VNET.subclass(*args_, **kwargs_)
        else:
            return VNET(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_CLUSTERS(self): return self.CLUSTERS
    def set_CLUSTERS(self, CLUSTERS): self.CLUSTERS = CLUSTERS
    def get_BRIDGE(self): return self.BRIDGE
    def set_BRIDGE(self, BRIDGE): self.BRIDGE = BRIDGE
    def get_PARENT_NETWORK_ID(self): return self.PARENT_NETWORK_ID
    def set_PARENT_NETWORK_ID(self, PARENT_NETWORK_ID): self.PARENT_NETWORK_ID = PARENT_NETWORK_ID
    def get_VN_MAD(self): return self.VN_MAD
    def set_VN_MAD(self, VN_MAD): self.VN_MAD = VN_MAD
    def get_PHYDEV(self): return self.PHYDEV
    def set_PHYDEV(self, PHYDEV): self.PHYDEV = PHYDEV
    def get_VLAN_ID(self): return self.VLAN_ID
    def set_VLAN_ID(self, VLAN_ID): self.VLAN_ID = VLAN_ID
    def get_VLAN_ID_AUTOMATIC(self): return self.VLAN_ID_AUTOMATIC
    def set_VLAN_ID_AUTOMATIC(self, VLAN_ID_AUTOMATIC): self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC
    def get_USED_LEASES(self): return self.USED_LEASES
    def set_USED_LEASES(self, USED_LEASES): self.USED_LEASES = USED_LEASES
    def get_VROUTERS(self): return self.VROUTERS
    def set_VROUTERS(self, VROUTERS): self.VROUTERS = VROUTERS
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def get_AR_POOL(self): return self.AR_POOL
    def set_AR_POOL(self, AR_POOL): self.AR_POOL = AR_POOL
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.CLUSTERS is not None or
            self.BRIDGE is not None or
            self.PARENT_NETWORK_ID is not None or
            self.VN_MAD is not None or
            self.PHYDEV is not None or
            self.VLAN_ID is not None or
            self.VLAN_ID_AUTOMATIC is not None or
            self.USED_LEASES is not None or
            self.VROUTERS is not None or
            self.TEMPLATE is not None or
            self.AR_POOL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VNET', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNET')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VNET')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VNET', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VNET'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VNET', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.CLUSTERS is not None:
            self.CLUSTERS.export(outfile, level, namespace_, name_='CLUSTERS', pretty_print=pretty_print)
        if self.BRIDGE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BRIDGE>%s</BRIDGE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BRIDGE), input_name='BRIDGE')), eol_))
        if self.PARENT_NETWORK_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PARENT_NETWORK_ID>%s</PARENT_NETWORK_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_NETWORK_ID), input_name='PARENT_NETWORK_ID')), eol_))
        if self.VN_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VN_MAD>%s</VN_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), eol_))
        if self.PHYDEV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PHYDEV>%s</PHYDEV>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PHYDEV), input_name='PHYDEV')), eol_))
        if self.VLAN_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VLAN_ID>%s</VLAN_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VLAN_ID), input_name='VLAN_ID')), eol_))
        if self.VLAN_ID_AUTOMATIC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VLAN_ID_AUTOMATIC>%s</VLAN_ID_AUTOMATIC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VLAN_ID_AUTOMATIC), input_name='VLAN_ID_AUTOMATIC')), eol_))
        if self.USED_LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_LEASES>%s</USED_LEASES>%s' % (self.gds_format_integer(self.USED_LEASES, input_name='USED_LEASES'), eol_))
        if self.VROUTERS is not None:
            self.VROUTERS.export(outfile, level, namespace_, name_='VROUTERS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
        if self.AR_POOL is not None:
            self.AR_POOL.export(outfile, level, namespace_, name_='AR_POOL', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType86.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'CLUSTERS':
            obj_ = CLUSTERSType87.factory()
            obj_.build(child_)
            self.CLUSTERS = obj_
            obj_.original_tagname_ = 'CLUSTERS'
        elif nodeName_ == 'BRIDGE':
            BRIDGE_ = child_.text
            BRIDGE_ = self.gds_validate_string(BRIDGE_, node, 'BRIDGE')
            self.BRIDGE = BRIDGE_
        elif nodeName_ == 'PARENT_NETWORK_ID':
            PARENT_NETWORK_ID_ = child_.text
            PARENT_NETWORK_ID_ = self.gds_validate_string(PARENT_NETWORK_ID_, node, 'PARENT_NETWORK_ID')
            self.PARENT_NETWORK_ID = PARENT_NETWORK_ID_
        elif nodeName_ == 'VN_MAD':
            VN_MAD_ = child_.text
            VN_MAD_ = self.gds_validate_string(VN_MAD_, node, 'VN_MAD')
            self.VN_MAD = VN_MAD_
        elif nodeName_ == 'PHYDEV':
            PHYDEV_ = child_.text
            PHYDEV_ = self.gds_validate_string(PHYDEV_, node, 'PHYDEV')
            self.PHYDEV = PHYDEV_
        elif nodeName_ == 'VLAN_ID':
            VLAN_ID_ = child_.text
            VLAN_ID_ = self.gds_validate_string(VLAN_ID_, node, 'VLAN_ID')
            self.VLAN_ID = VLAN_ID_
        elif nodeName_ == 'VLAN_ID_AUTOMATIC':
            VLAN_ID_AUTOMATIC_ = child_.text
            VLAN_ID_AUTOMATIC_ = self.gds_validate_string(VLAN_ID_AUTOMATIC_, node, 'VLAN_ID_AUTOMATIC')
            self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC_
        elif nodeName_ == 'USED_LEASES':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'USED_LEASES')
            self.USED_LEASES = ival_
        elif nodeName_ == 'VROUTERS':
            obj_ = VROUTERSType88.factory()
            obj_.build(child_)
            self.VROUTERS = obj_
            obj_.original_tagname_ = 'VROUTERS'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
        elif nodeName_ == 'AR_POOL':
            obj_ = AR_POOLType89.factory()
            obj_.build(child_)
            self.AR_POOL = obj_
            obj_.original_tagname_ = 'AR_POOL'
# end class VNET


class VROUTER_POOL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VROUTER=None):
        self.original_tagname_ = None
        if VROUTER is None:
            self.VROUTER = []
        else:
            self.VROUTER = VROUTER
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VROUTER_POOL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VROUTER_POOL.subclass:
            return VROUTER_POOL.subclass(*args_, **kwargs_)
        else:
            return VROUTER_POOL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VROUTER(self): return self.VROUTER
    def set_VROUTER(self, VROUTER): self.VROUTER = VROUTER
    def add_VROUTER(self, value): self.VROUTER.append(value)
    def insert_VROUTER_at(self, index, value): self.VROUTER.insert(index, value)
    def replace_VROUTER_at(self, index, value): self.VROUTER[index] = value
    def hasContent_(self):
        if (
            self.VROUTER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VROUTER_POOL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VROUTER_POOL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VROUTER_POOL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VROUTER_POOL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VROUTER_POOL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VROUTER_POOL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VROUTER_ in self.VROUTER:
            VROUTER_.export(outfile, level, namespace_, name_='VROUTER', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VROUTER':
            obj_ = VROUTER.factory()
            obj_.build(child_)
            self.VROUTER.append(obj_)
            obj_.original_tagname_ = 'VROUTER'
# end class VROUTER_POOL


class VROUTER(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, VMS=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.PERMISSIONS = PERMISSIONS
        self.VMS = VMS
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VROUTER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VROUTER.subclass:
            return VROUTER.subclass(*args_, **kwargs_)
        else:
            return VROUTER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.VMS is not None or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VROUTER', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VROUTER')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VROUTER')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VROUTER', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VROUTER'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VROUTER', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.VMS is not None:
            self.VMS.export(outfile, level, namespace_, name_='VMS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType91.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'VMS':
            obj_ = VMSType92.factory()
            obj_.build(child_)
            self.VMS = obj_
            obj_.original_tagname_ = 'VMS'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class VROUTER


class VMType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, LAST_POLL=None, STATE=None, LCM_STATE=None, PREV_STATE=None, PREV_LCM_STATE=None, RESCHED=None, STIME=None, ETIME=None, DEPLOY_ID=None, MONITORING=None, TEMPLATE=None, USER_TEMPLATE=None, HISTORY_RECORDS=None, SNAPSHOTS=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.PERMISSIONS = PERMISSIONS
        self.LAST_POLL = LAST_POLL
        self.STATE = STATE
        self.LCM_STATE = LCM_STATE
        self.PREV_STATE = PREV_STATE
        self.PREV_LCM_STATE = PREV_LCM_STATE
        self.RESCHED = RESCHED
        self.STIME = STIME
        self.ETIME = ETIME
        self.DEPLOY_ID = DEPLOY_ID
        self.MONITORING = MONITORING
        self.TEMPLATE = TEMPLATE
        self.USER_TEMPLATE = USER_TEMPLATE
        self.HISTORY_RECORDS = HISTORY_RECORDS
        if SNAPSHOTS is None:
            self.SNAPSHOTS = []
        else:
            self.SNAPSHOTS = SNAPSHOTS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType.subclass:
            return VMType.subclass(*args_, **kwargs_)
        else:
            return VMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_LAST_POLL(self): return self.LAST_POLL
    def set_LAST_POLL(self, LAST_POLL): self.LAST_POLL = LAST_POLL
    def get_STATE(self): return self.STATE
    def set_STATE(self, STATE): self.STATE = STATE
    def get_LCM_STATE(self): return self.LCM_STATE
    def set_LCM_STATE(self, LCM_STATE): self.LCM_STATE = LCM_STATE
    def get_PREV_STATE(self): return self.PREV_STATE
    def set_PREV_STATE(self, PREV_STATE): self.PREV_STATE = PREV_STATE
    def get_PREV_LCM_STATE(self): return self.PREV_LCM_STATE
    def set_PREV_LCM_STATE(self, PREV_LCM_STATE): self.PREV_LCM_STATE = PREV_LCM_STATE
    def get_RESCHED(self): return self.RESCHED
    def set_RESCHED(self, RESCHED): self.RESCHED = RESCHED
    def get_STIME(self): return self.STIME
    def set_STIME(self, STIME): self.STIME = STIME
    def get_ETIME(self): return self.ETIME
    def set_ETIME(self, ETIME): self.ETIME = ETIME
    def get_DEPLOY_ID(self): return self.DEPLOY_ID
    def set_DEPLOY_ID(self, DEPLOY_ID): self.DEPLOY_ID = DEPLOY_ID
    def get_MONITORING(self): return self.MONITORING
    def set_MONITORING(self, MONITORING): self.MONITORING = MONITORING
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def get_USER_TEMPLATE(self): return self.USER_TEMPLATE
    def set_USER_TEMPLATE(self, USER_TEMPLATE): self.USER_TEMPLATE = USER_TEMPLATE
    def get_HISTORY_RECORDS(self): return self.HISTORY_RECORDS
    def set_HISTORY_RECORDS(self, HISTORY_RECORDS): self.HISTORY_RECORDS = HISTORY_RECORDS
    def get_SNAPSHOTS(self): return self.SNAPSHOTS
    def set_SNAPSHOTS(self, SNAPSHOTS): self.SNAPSHOTS = SNAPSHOTS
    def add_SNAPSHOTS(self, value): self.SNAPSHOTS.append(value)
    def insert_SNAPSHOTS_at(self, index, value): self.SNAPSHOTS.insert(index, value)
    def replace_SNAPSHOTS_at(self, index, value): self.SNAPSHOTS[index] = value
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.LAST_POLL is not None or
            self.STATE is not None or
            self.LCM_STATE is not None or
            self.PREV_STATE is not None or
            self.PREV_LCM_STATE is not None or
            self.RESCHED is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.DEPLOY_ID is not None or
            self.MONITORING is not None or
            self.TEMPLATE is not None or
            self.USER_TEMPLATE is not None or
            self.HISTORY_RECORDS is not None or
            self.SNAPSHOTS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.LAST_POLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LAST_POLL>%s</LAST_POLL>%s' % (self.gds_format_integer(self.LAST_POLL, input_name='LAST_POLL'), eol_))
        if self.STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE>%s</STATE>%s' % (self.gds_format_integer(self.STATE, input_name='STATE'), eol_))
        if self.LCM_STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LCM_STATE>%s</LCM_STATE>%s' % (self.gds_format_integer(self.LCM_STATE, input_name='LCM_STATE'), eol_))
        if self.PREV_STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PREV_STATE>%s</PREV_STATE>%s' % (self.gds_format_integer(self.PREV_STATE, input_name='PREV_STATE'), eol_))
        if self.PREV_LCM_STATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PREV_LCM_STATE>%s</PREV_LCM_STATE>%s' % (self.gds_format_integer(self.PREV_LCM_STATE, input_name='PREV_LCM_STATE'), eol_))
        if self.RESCHED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RESCHED>%s</RESCHED>%s' % (self.gds_format_integer(self.RESCHED, input_name='RESCHED'), eol_))
        if self.STIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STIME>%s</STIME>%s' % (self.gds_format_integer(self.STIME, input_name='STIME'), eol_))
        if self.ETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ETIME>%s</ETIME>%s' % (self.gds_format_integer(self.ETIME, input_name='ETIME'), eol_))
        if self.DEPLOY_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DEPLOY_ID>%s</DEPLOY_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DEPLOY_ID), input_name='DEPLOY_ID')), eol_))
        if self.MONITORING is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MONITORING>%s</MONITORING>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MONITORING), input_name='MONITORING')), eol_))
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
        if self.USER_TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USER_TEMPLATE>%s</USER_TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USER_TEMPLATE), input_name='USER_TEMPLATE')), eol_))
        if self.HISTORY_RECORDS is not None:
            self.HISTORY_RECORDS.export(outfile, level, namespace_, name_='HISTORY_RECORDS', pretty_print=pretty_print)
        for SNAPSHOTS_ in self.SNAPSHOTS:
            SNAPSHOTS_.export(outfile, level, namespace_, name_='SNAPSHOTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'LAST_POLL':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LAST_POLL')
            self.LAST_POLL = ival_
        elif nodeName_ == 'STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STATE')
            self.STATE = ival_
        elif nodeName_ == 'LCM_STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LCM_STATE')
            self.LCM_STATE = ival_
        elif nodeName_ == 'PREV_STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_STATE')
            self.PREV_STATE = ival_
        elif nodeName_ == 'PREV_LCM_STATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PREV_LCM_STATE')
            self.PREV_LCM_STATE = ival_
        elif nodeName_ == 'RESCHED':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RESCHED')
            self.RESCHED = ival_
        elif nodeName_ == 'STIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
        elif nodeName_ == 'ETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
        elif nodeName_ == 'DEPLOY_ID':
            DEPLOY_ID_ = child_.text
            DEPLOY_ID_ = self.gds_validate_string(DEPLOY_ID_, node, 'DEPLOY_ID')
            self.DEPLOY_ID = DEPLOY_ID_
        elif nodeName_ == 'MONITORING':
            MONITORING_ = child_.text
            MONITORING_ = self.gds_validate_string(MONITORING_, node, 'MONITORING')
            self.MONITORING = MONITORING_
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
        elif nodeName_ == 'USER_TEMPLATE':
            USER_TEMPLATE_ = child_.text
            USER_TEMPLATE_ = self.gds_validate_string(USER_TEMPLATE_, node, 'USER_TEMPLATE')
            self.USER_TEMPLATE = USER_TEMPLATE_
        elif nodeName_ == 'HISTORY_RECORDS':
            obj_ = HISTORY_RECORDS.factory()
            obj_.build(child_)
            self.HISTORY_RECORDS = obj_
            obj_.original_tagname_ = 'HISTORY_RECORDS'
        elif nodeName_ == 'SNAPSHOTS':
            obj_ = SNAPSHOTSType.factory()
            obj_.build(child_)
            self.SNAPSHOTS.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOTS'
# end class VMType


class PERMISSIONSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType.subclass:
            return PERMISSIONSType.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType


class SNAPSHOTSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DISK_ID=None, SNAPSHOT=None):
        self.original_tagname_ = None
        self.DISK_ID = DISK_ID
        if SNAPSHOT is None:
            self.SNAPSHOT = []
        else:
            self.SNAPSHOT = SNAPSHOT
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTSType.subclass:
            return SNAPSHOTSType.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DISK_ID(self): return self.DISK_ID
    def set_DISK_ID(self, DISK_ID): self.DISK_ID = DISK_ID
    def get_SNAPSHOT(self): return self.SNAPSHOT
    def set_SNAPSHOT(self, SNAPSHOT): self.SNAPSHOT = SNAPSHOT
    def add_SNAPSHOT(self, value): self.SNAPSHOT.append(value)
    def insert_SNAPSHOT_at(self, index, value): self.SNAPSHOT.insert(index, value)
    def replace_SNAPSHOT_at(self, index, value): self.SNAPSHOT[index] = value
    def hasContent_(self):
        if (
            self.DISK_ID is not None or
            self.SNAPSHOT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SNAPSHOTSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SNAPSHOTSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SNAPSHOTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SNAPSHOTSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SNAPSHOTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DISK_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DISK_ID>%s</DISK_ID>%s' % (self.gds_format_integer(self.DISK_ID, input_name='DISK_ID'), eol_))
        for SNAPSHOT_ in self.SNAPSHOT:
            SNAPSHOT_.export(outfile, level, namespace_, name_='SNAPSHOT', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DISK_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_ID')
            self.DISK_ID = ival_
        elif nodeName_ == 'SNAPSHOT':
            obj_ = SNAPSHOTType.factory()
            obj_.build(child_)
            self.SNAPSHOT.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOT'
# end class SNAPSHOTSType


class SNAPSHOTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ACTIVE=None, CHILDREN=None, DATE=None, ID=None, NAME=None, PARENT=None, SIZE=None):
        self.original_tagname_ = None
        self.ACTIVE = ACTIVE
        self.CHILDREN = CHILDREN
        self.DATE = DATE
        self.ID = ID
        self.NAME = NAME
        self.PARENT = PARENT
        self.SIZE = SIZE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTType.subclass:
            return SNAPSHOTType.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ACTIVE(self): return self.ACTIVE
    def set_ACTIVE(self, ACTIVE): self.ACTIVE = ACTIVE
    def get_CHILDREN(self): return self.CHILDREN
    def set_CHILDREN(self, CHILDREN): self.CHILDREN = CHILDREN
    def get_DATE(self): return self.DATE
    def set_DATE(self, DATE): self.DATE = DATE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PARENT(self): return self.PARENT
    def set_PARENT(self, PARENT): self.PARENT = PARENT
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def hasContent_(self):
        if (
            self.ACTIVE is not None or
            self.CHILDREN is not None or
            self.DATE is not None or
            self.ID is not None or
            self.NAME is not None or
            self.PARENT is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SNAPSHOTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SNAPSHOTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SNAPSHOTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SNAPSHOTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SNAPSHOTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ACTIVE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ACTIVE>%s</ACTIVE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ACTIVE), input_name='ACTIVE')), eol_))
        if self.CHILDREN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CHILDREN>%s</CHILDREN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CHILDREN), input_name='CHILDREN')), eol_))
        if self.DATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATE>%s</DATE>%s' % (self.gds_format_integer(self.DATE, input_name='DATE'), eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PARENT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PARENT>%s</PARENT>%s' % (self.gds_format_integer(self.PARENT, input_name='PARENT'), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_format_integer(self.SIZE, input_name='SIZE'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ACTIVE':
            ACTIVE_ = child_.text
            ACTIVE_ = self.gds_validate_string(ACTIVE_, node, 'ACTIVE')
            self.ACTIVE = ACTIVE_
        elif nodeName_ == 'CHILDREN':
            CHILDREN_ = child_.text
            CHILDREN_ = self.gds_validate_string(CHILDREN_, node, 'CHILDREN')
            self.CHILDREN = CHILDREN_
        elif nodeName_ == 'DATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DATE')
            self.DATE = ival_
        elif nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PARENT':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PARENT')
            self.PARENT = ival_
        elif nodeName_ == 'SIZE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
# end class SNAPSHOTType


class HOSTSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOSTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOSTSType.subclass:
            return HOSTSType.subclass(*args_, **kwargs_)
        else:
            return HOSTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HOSTSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOSTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HOSTSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HOSTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HOSTSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HOSTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class HOSTSType


class DATASTORESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORESType.subclass:
            return DATASTORESType.subclass(*args_, **kwargs_)
        else:
            return DATASTORESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORESType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class DATASTORESType


class VNETSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNETSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNETSType.subclass:
            return VNETSType.subclass(*args_, **kwargs_)
        else:
            return VNETSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VNETSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNETSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VNETSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VNETSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VNETSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VNETSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class VNETSType


class PERMISSIONSType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType1.subclass:
            return PERMISSIONSType1.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType1


class CLUSTERSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERSType.subclass:
            return CLUSTERSType.subclass(*args_, **kwargs_)
        else:
            return CLUSTERSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CLUSTERSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLUSTERSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CLUSTERSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLUSTERSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLUSTERSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class CLUSTERSType


class IMAGESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGESType.subclass:
            return IMAGESType.subclass(*args_, **kwargs_)
        else:
            return IMAGESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGESType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class IMAGESType


class GROUPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, NAME=None, TEMPLATE=None, USERS=None, ADMINS=None):
        self.original_tagname_ = None
        self.ID = ID
        self.NAME = NAME
        self.TEMPLATE = TEMPLATE
        self.USERS = USERS
        self.ADMINS = ADMINS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUPType.subclass:
            return GROUPType.subclass(*args_, **kwargs_)
        else:
            return GROUPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def get_USERS(self): return self.USERS
    def set_USERS(self, USERS): self.USERS = USERS
    def get_ADMINS(self): return self.ADMINS
    def set_ADMINS(self, ADMINS): self.ADMINS = ADMINS
    def hasContent_(self):
        if (
            self.ID is not None or
            self.NAME is not None or
            self.TEMPLATE is not None or
            self.USERS is not None or
            self.ADMINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GROUPType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GROUPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GROUPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GROUPType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GROUPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
        if self.USERS is not None:
            self.USERS.export(outfile, level, namespace_, name_='USERS', pretty_print=pretty_print)
        if self.ADMINS is not None:
            self.ADMINS.export(outfile, level, namespace_, name_='ADMINS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
        elif nodeName_ == 'USERS':
            obj_ = USERSType.factory()
            obj_.build(child_)
            self.USERS = obj_
            obj_.original_tagname_ = 'USERS'
        elif nodeName_ == 'ADMINS':
            obj_ = ADMINSType.factory()
            obj_.build(child_)
            self.ADMINS = obj_
            obj_.original_tagname_ = 'ADMINS'
# end class GROUPType


class USERSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USERSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USERSType.subclass:
            return USERSType.subclass(*args_, **kwargs_)
        else:
            return USERSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='USERSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USERSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='USERSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='USERSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='USERSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='USERSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class USERSType


class ADMINSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADMINSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADMINSType.subclass:
            return ADMINSType.subclass(*args_, **kwargs_)
        else:
            return ADMINSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ADMINSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADMINSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ADMINSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ADMINSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ADMINSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ADMINSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class ADMINSType


class QUOTASType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None):
        self.original_tagname_ = None
        self.ID = ID
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.VM_QUOTA = VM_QUOTA
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QUOTASType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QUOTASType.subclass:
            return QUOTASType.subclass(*args_, **kwargs_)
        else:
            return QUOTASType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DATASTORE_QUOTA(self): return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA): self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self): return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA): self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self): return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA): self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self): return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA): self.IMAGE_QUOTA = IMAGE_QUOTA
    def hasContent_(self):
        if (
            self.ID is not None or
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUOTASType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUOTASType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUOTASType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUOTASType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUOTASType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QUOTASType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.DATASTORE_QUOTA is not None:
            self.DATASTORE_QUOTA.export(outfile, level, namespace_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            self.NETWORK_QUOTA.export(outfile, level, namespace_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            self.VM_QUOTA.export(outfile, level, namespace_, name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            self.IMAGE_QUOTA.export(outfile, level, namespace_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTAType.factory()
            obj_.build(child_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTAType.factory()
            obj_.build(child_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType.factory()
            obj_.build(child_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTAType.factory()
            obj_.build(child_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class QUOTASType


class DATASTORE_QUOTAType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTAType.subclass:
            return DATASTORE_QUOTAType.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTAType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_QUOTAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_QUOTAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_QUOTAType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTAType


class DATASTOREType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.IMAGES = IMAGES
        self.IMAGES_USED = IMAGES_USED
        self.SIZE = SIZE
        self.SIZE_USED = SIZE_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType.subclass:
            return DATASTOREType.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_IMAGES_USED(self): return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED): self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_SIZE_USED(self): return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED): self.SIZE_USED = SIZE_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.IMAGES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES>%s</IMAGES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), eol_))
        if self.IMAGES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES_USED>%s</IMAGES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), eol_))
        if self.SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE_USED>%s</SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'IMAGES':
            IMAGES_ = child_.text
            IMAGES_ = self.gds_validate_string(IMAGES_, node, 'IMAGES')
            self.IMAGES = IMAGES_
        elif nodeName_ == 'IMAGES_USED':
            IMAGES_USED_ = child_.text
            IMAGES_USED_ = self.gds_validate_string(IMAGES_USED_, node, 'IMAGES_USED')
            self.IMAGES_USED = IMAGES_USED_
        elif nodeName_ == 'SIZE':
            SIZE_ = child_.text
            SIZE_ = self.gds_validate_string(SIZE_, node, 'SIZE')
            self.SIZE = SIZE_
        elif nodeName_ == 'SIZE_USED':
            SIZE_USED_ = child_.text
            SIZE_USED_ = self.gds_validate_string(SIZE_USED_, node, 'SIZE_USED')
            self.SIZE_USED = SIZE_USED_
# end class DATASTOREType


class NETWORK_QUOTAType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None):
        self.original_tagname_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTAType.subclass:
            return NETWORK_QUOTAType.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NETWORK(self): return self.NETWORK
    def set_NETWORK(self, NETWORK): self.NETWORK = NETWORK
    def add_NETWORK(self, value): self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value): self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value): self.NETWORK[index] = value
    def hasContent_(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTAType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORK_QUOTAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORK_QUOTAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORK_QUOTAType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            NETWORK_.export(outfile, level, namespace_, name_='NETWORK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType.factory()
            obj_.build(child_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTAType


class NETWORKType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.LEASES = LEASES
        self.LEASES_USED = LEASES_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType.subclass:
            return NETWORKType.subclass(*args_, **kwargs_)
        else:
            return NETWORKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def get_LEASES_USED(self): return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED): self.LEASES_USED = LEASES_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORKType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORKType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES>%s</LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), eol_))
        if self.LEASES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES_USED>%s</LEASES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LEASES':
            LEASES_ = child_.text
            LEASES_ = self.gds_validate_string(LEASES_, node, 'LEASES')
            self.LEASES = LEASES_
        elif nodeName_ == 'LEASES_USED':
            LEASES_USED_ = child_.text
            LEASES_USED_ = self.gds_validate_string(LEASES_USED_, node, 'LEASES_USED')
            self.LEASES_USED = LEASES_USED_
# end class NETWORKType


class VM_QUOTAType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType.subclass:
            return VM_QUOTAType.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_QUOTAType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_QUOTAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_QUOTAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_QUOTAType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_QUOTAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VMType2.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType


class VMType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None):
        self.original_tagname_ = None
        self.CPU = CPU
        self.CPU_USED = CPU_USED
        self.MEMORY = MEMORY
        self.MEMORY_USED = MEMORY_USED
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.VMS = VMS
        self.VMS_USED = VMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType2.subclass:
            return VMType2.subclass(*args_, **kwargs_)
        else:
            return VMType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPU(self): return self.CPU
    def set_CPU(self, CPU): self.CPU = CPU
    def get_CPU_USED(self): return self.CPU_USED
    def set_CPU_USED(self, CPU_USED): self.CPU_USED = CPU_USED
    def get_MEMORY(self): return self.MEMORY
    def set_MEMORY(self, MEMORY): self.MEMORY = MEMORY
    def get_MEMORY_USED(self): return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED): self.MEMORY_USED = MEMORY_USED
    def get_SYSTEM_DISK_SIZE(self): return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE): self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self): return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED): self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_VMS_USED(self): return self.VMS_USED
    def set_VMS_USED(self, VMS_USED): self.VMS_USED = VMS_USED
    def hasContent_(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU>%s</CPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), eol_))
        if self.CPU_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USED>%s</CPU_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), eol_))
        if self.MEMORY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY>%s</MEMORY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), eol_))
        if self.MEMORY_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY_USED>%s</MEMORY_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE>%s</SYSTEM_DISK_SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE_USED>%s</SYSTEM_DISK_SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), eol_))
        if self.VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS>%s</VMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), eol_))
        if self.VMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS_USED>%s</VMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPU':
            CPU_ = child_.text
            CPU_ = self.gds_validate_string(CPU_, node, 'CPU')
            self.CPU = CPU_
        elif nodeName_ == 'CPU_USED':
            CPU_USED_ = child_.text
            CPU_USED_ = self.gds_validate_string(CPU_USED_, node, 'CPU_USED')
            self.CPU_USED = CPU_USED_
        elif nodeName_ == 'MEMORY':
            MEMORY_ = child_.text
            MEMORY_ = self.gds_validate_string(MEMORY_, node, 'MEMORY')
            self.MEMORY = MEMORY_
        elif nodeName_ == 'MEMORY_USED':
            MEMORY_USED_ = child_.text
            MEMORY_USED_ = self.gds_validate_string(MEMORY_USED_, node, 'MEMORY_USED')
            self.MEMORY_USED = MEMORY_USED_
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            SYSTEM_DISK_SIZE_ = child_.text
            SYSTEM_DISK_SIZE_ = self.gds_validate_string(SYSTEM_DISK_SIZE_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE_
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            SYSTEM_DISK_SIZE_USED_ = child_.text
            SYSTEM_DISK_SIZE_USED_ = self.gds_validate_string(SYSTEM_DISK_SIZE_USED_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED_
        elif nodeName_ == 'VMS':
            VMS_ = child_.text
            VMS_ = self.gds_validate_string(VMS_, node, 'VMS')
            self.VMS = VMS_
        elif nodeName_ == 'VMS_USED':
            VMS_USED_ = child_.text
            VMS_USED_ = self.gds_validate_string(VMS_USED_, node, 'VMS_USED')
            self.VMS_USED = VMS_USED_
# end class VMType2


class IMAGE_QUOTAType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTAType.subclass:
            return IMAGE_QUOTAType.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTAType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_QUOTAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_QUOTAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_QUOTAType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTAType


class IMAGEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.RVMS = RVMS
        self.RVMS_USED = RVMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType.subclass:
            return IMAGEType.subclass(*args_, **kwargs_)
        else:
            return IMAGEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_RVMS(self): return self.RVMS
    def set_RVMS(self, RVMS): self.RVMS = RVMS
    def get_RVMS_USED(self): return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED): self.RVMS_USED = RVMS_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGEType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.RVMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS>%s</RVMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), eol_))
        if self.RVMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS_USED>%s</RVMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'RVMS':
            RVMS_ = child_.text
            RVMS_ = self.gds_validate_string(RVMS_, node, 'RVMS')
            self.RVMS = RVMS_
        elif nodeName_ == 'RVMS_USED':
            RVMS_USED_ = child_.text
            RVMS_USED_ = self.gds_validate_string(RVMS_USED_, node, 'RVMS_USED')
            self.RVMS_USED = RVMS_USED_
# end class IMAGEType


class DEFAULT_GROUP_QUOTASType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None):
        self.original_tagname_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.VM_QUOTA = VM_QUOTA
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_GROUP_QUOTASType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_GROUP_QUOTASType.subclass:
            return DEFAULT_GROUP_QUOTASType.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_GROUP_QUOTASType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE_QUOTA(self): return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA): self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self): return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA): self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self): return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA): self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self): return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA): self.IMAGE_QUOTA = IMAGE_QUOTA
    def hasContent_(self):
        if (
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DEFAULT_GROUP_QUOTASType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_GROUP_QUOTASType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DEFAULT_GROUP_QUOTASType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DEFAULT_GROUP_QUOTASType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DEFAULT_GROUP_QUOTASType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DEFAULT_GROUP_QUOTASType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATASTORE_QUOTA is not None:
            self.DATASTORE_QUOTA.export(outfile, level, namespace_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            self.NETWORK_QUOTA.export(outfile, level, namespace_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            self.VM_QUOTA.export(outfile, level, namespace_, name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            self.IMAGE_QUOTA.export(outfile, level, namespace_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTAType3.factory()
            obj_.build(child_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTAType5.factory()
            obj_.build(child_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType7.factory()
            obj_.build(child_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTAType9.factory()
            obj_.build(child_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class DEFAULT_GROUP_QUOTASType


class DATASTORE_QUOTAType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTAType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTAType3.subclass:
            return DATASTORE_QUOTAType3.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTAType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTAType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_QUOTAType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_QUOTAType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_QUOTAType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType4.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTAType3


class DATASTOREType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.IMAGES = IMAGES
        self.IMAGES_USED = IMAGES_USED
        self.SIZE = SIZE
        self.SIZE_USED = SIZE_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType4.subclass:
            return DATASTOREType4.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_IMAGES_USED(self): return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED): self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_SIZE_USED(self): return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED): self.SIZE_USED = SIZE_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.IMAGES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES>%s</IMAGES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), eol_))
        if self.IMAGES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES_USED>%s</IMAGES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), eol_))
        if self.SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE_USED>%s</SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'IMAGES':
            IMAGES_ = child_.text
            IMAGES_ = self.gds_validate_string(IMAGES_, node, 'IMAGES')
            self.IMAGES = IMAGES_
        elif nodeName_ == 'IMAGES_USED':
            IMAGES_USED_ = child_.text
            IMAGES_USED_ = self.gds_validate_string(IMAGES_USED_, node, 'IMAGES_USED')
            self.IMAGES_USED = IMAGES_USED_
        elif nodeName_ == 'SIZE':
            SIZE_ = child_.text
            SIZE_ = self.gds_validate_string(SIZE_, node, 'SIZE')
            self.SIZE = SIZE_
        elif nodeName_ == 'SIZE_USED':
            SIZE_USED_ = child_.text
            SIZE_USED_ = self.gds_validate_string(SIZE_USED_, node, 'SIZE_USED')
            self.SIZE_USED = SIZE_USED_
# end class DATASTOREType4


class NETWORK_QUOTAType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None):
        self.original_tagname_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTAType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTAType5.subclass:
            return NETWORK_QUOTAType5.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTAType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NETWORK(self): return self.NETWORK
    def set_NETWORK(self, NETWORK): self.NETWORK = NETWORK
    def add_NETWORK(self, value): self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value): self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value): self.NETWORK[index] = value
    def hasContent_(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTAType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORK_QUOTAType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORK_QUOTAType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORK_QUOTAType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            NETWORK_.export(outfile, level, namespace_, name_='NETWORK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType6.factory()
            obj_.build(child_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTAType5


class NETWORKType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.LEASES = LEASES
        self.LEASES_USED = LEASES_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType6.subclass:
            return NETWORKType6.subclass(*args_, **kwargs_)
        else:
            return NETWORKType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def get_LEASES_USED(self): return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED): self.LEASES_USED = LEASES_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORKType6', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORKType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORKType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORKType6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORKType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES>%s</LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), eol_))
        if self.LEASES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES_USED>%s</LEASES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LEASES':
            LEASES_ = child_.text
            LEASES_ = self.gds_validate_string(LEASES_, node, 'LEASES')
            self.LEASES = LEASES_
        elif nodeName_ == 'LEASES_USED':
            LEASES_USED_ = child_.text
            LEASES_USED_ = self.gds_validate_string(LEASES_USED_, node, 'LEASES_USED')
            self.LEASES_USED = LEASES_USED_
# end class NETWORKType6


class VM_QUOTAType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType7.subclass:
            return VM_QUOTAType7.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_QUOTAType7', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_QUOTAType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_QUOTAType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_QUOTAType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_QUOTAType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VMType8.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType7


class VMType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None):
        self.original_tagname_ = None
        self.CPU = CPU
        self.CPU_USED = CPU_USED
        self.MEMORY = MEMORY
        self.MEMORY_USED = MEMORY_USED
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.VMS = VMS
        self.VMS_USED = VMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType8.subclass:
            return VMType8.subclass(*args_, **kwargs_)
        else:
            return VMType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPU(self): return self.CPU
    def set_CPU(self, CPU): self.CPU = CPU
    def get_CPU_USED(self): return self.CPU_USED
    def set_CPU_USED(self, CPU_USED): self.CPU_USED = CPU_USED
    def get_MEMORY(self): return self.MEMORY
    def set_MEMORY(self, MEMORY): self.MEMORY = MEMORY
    def get_MEMORY_USED(self): return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED): self.MEMORY_USED = MEMORY_USED
    def get_SYSTEM_DISK_SIZE(self): return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE): self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self): return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED): self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_VMS_USED(self): return self.VMS_USED
    def set_VMS_USED(self, VMS_USED): self.VMS_USED = VMS_USED
    def hasContent_(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType8', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU>%s</CPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), eol_))
        if self.CPU_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USED>%s</CPU_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), eol_))
        if self.MEMORY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY>%s</MEMORY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), eol_))
        if self.MEMORY_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY_USED>%s</MEMORY_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE>%s</SYSTEM_DISK_SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE_USED>%s</SYSTEM_DISK_SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), eol_))
        if self.VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS>%s</VMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), eol_))
        if self.VMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS_USED>%s</VMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPU':
            CPU_ = child_.text
            CPU_ = self.gds_validate_string(CPU_, node, 'CPU')
            self.CPU = CPU_
        elif nodeName_ == 'CPU_USED':
            CPU_USED_ = child_.text
            CPU_USED_ = self.gds_validate_string(CPU_USED_, node, 'CPU_USED')
            self.CPU_USED = CPU_USED_
        elif nodeName_ == 'MEMORY':
            MEMORY_ = child_.text
            MEMORY_ = self.gds_validate_string(MEMORY_, node, 'MEMORY')
            self.MEMORY = MEMORY_
        elif nodeName_ == 'MEMORY_USED':
            MEMORY_USED_ = child_.text
            MEMORY_USED_ = self.gds_validate_string(MEMORY_USED_, node, 'MEMORY_USED')
            self.MEMORY_USED = MEMORY_USED_
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            SYSTEM_DISK_SIZE_ = child_.text
            SYSTEM_DISK_SIZE_ = self.gds_validate_string(SYSTEM_DISK_SIZE_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE_
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            SYSTEM_DISK_SIZE_USED_ = child_.text
            SYSTEM_DISK_SIZE_USED_ = self.gds_validate_string(SYSTEM_DISK_SIZE_USED_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED_
        elif nodeName_ == 'VMS':
            VMS_ = child_.text
            VMS_ = self.gds_validate_string(VMS_, node, 'VMS')
            self.VMS = VMS_
        elif nodeName_ == 'VMS_USED':
            VMS_USED_ = child_.text
            VMS_USED_ = self.gds_validate_string(VMS_USED_, node, 'VMS_USED')
            self.VMS_USED = VMS_USED_
# end class VMType8


class IMAGE_QUOTAType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTAType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTAType9.subclass:
            return IMAGE_QUOTAType9.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTAType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType9', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTAType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_QUOTAType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_QUOTAType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_QUOTAType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType10.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTAType9


class IMAGEType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.RVMS = RVMS
        self.RVMS_USED = RVMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType10.subclass:
            return IMAGEType10.subclass(*args_, **kwargs_)
        else:
            return IMAGEType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_RVMS(self): return self.RVMS
    def set_RVMS(self, RVMS): self.RVMS = RVMS
    def get_RVMS_USED(self): return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED): self.RVMS_USED = RVMS_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGEType10', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGEType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGEType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGEType10'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGEType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.RVMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS>%s</RVMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), eol_))
        if self.RVMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS_USED>%s</RVMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'RVMS':
            RVMS_ = child_.text
            RVMS_ = self.gds_validate_string(RVMS_, node, 'RVMS')
            self.RVMS = RVMS_
        elif nodeName_ == 'RVMS_USED':
            RVMS_USED_ = child_.text
            RVMS_USED_ = self.gds_validate_string(RVMS_USED_, node, 'RVMS_USED')
            self.RVMS_USED = RVMS_USED_
# end class IMAGEType10


class USERSType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USERSType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USERSType11.subclass:
            return USERSType11.subclass(*args_, **kwargs_)
        else:
            return USERSType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='USERSType11', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USERSType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='USERSType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='USERSType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='USERSType11'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='USERSType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class USERSType11


class ADMINSType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADMINSType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADMINSType12.subclass:
            return ADMINSType12.subclass(*args_, **kwargs_)
        else:
            return ADMINSType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ADMINSType12', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADMINSType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ADMINSType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ADMINSType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ADMINSType12'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ADMINSType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class ADMINSType12


class DATASTORE_QUOTAType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTAType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTAType13.subclass:
            return DATASTORE_QUOTAType13.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTAType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType13', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTAType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_QUOTAType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_QUOTAType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_QUOTAType13'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType14.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTAType13


class DATASTOREType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.IMAGES = IMAGES
        self.IMAGES_USED = IMAGES_USED
        self.SIZE = SIZE
        self.SIZE_USED = SIZE_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType14.subclass:
            return DATASTOREType14.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_IMAGES_USED(self): return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED): self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_SIZE_USED(self): return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED): self.SIZE_USED = SIZE_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType14', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType14'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.IMAGES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES>%s</IMAGES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), eol_))
        if self.IMAGES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES_USED>%s</IMAGES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), eol_))
        if self.SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE_USED>%s</SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'IMAGES':
            IMAGES_ = child_.text
            IMAGES_ = self.gds_validate_string(IMAGES_, node, 'IMAGES')
            self.IMAGES = IMAGES_
        elif nodeName_ == 'IMAGES_USED':
            IMAGES_USED_ = child_.text
            IMAGES_USED_ = self.gds_validate_string(IMAGES_USED_, node, 'IMAGES_USED')
            self.IMAGES_USED = IMAGES_USED_
        elif nodeName_ == 'SIZE':
            SIZE_ = child_.text
            SIZE_ = self.gds_validate_string(SIZE_, node, 'SIZE')
            self.SIZE = SIZE_
        elif nodeName_ == 'SIZE_USED':
            SIZE_USED_ = child_.text
            SIZE_USED_ = self.gds_validate_string(SIZE_USED_, node, 'SIZE_USED')
            self.SIZE_USED = SIZE_USED_
# end class DATASTOREType14


class NETWORK_QUOTAType15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None):
        self.original_tagname_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTAType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTAType15.subclass:
            return NETWORK_QUOTAType15.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTAType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NETWORK(self): return self.NETWORK
    def set_NETWORK(self, NETWORK): self.NETWORK = NETWORK
    def add_NETWORK(self, value): self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value): self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value): self.NETWORK[index] = value
    def hasContent_(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType15', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTAType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORK_QUOTAType15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORK_QUOTAType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORK_QUOTAType15'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            NETWORK_.export(outfile, level, namespace_, name_='NETWORK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType16.factory()
            obj_.build(child_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTAType15


class NETWORKType16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.LEASES = LEASES
        self.LEASES_USED = LEASES_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType16.subclass:
            return NETWORKType16.subclass(*args_, **kwargs_)
        else:
            return NETWORKType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def get_LEASES_USED(self): return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED): self.LEASES_USED = LEASES_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORKType16', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORKType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORKType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORKType16'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORKType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES>%s</LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), eol_))
        if self.LEASES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES_USED>%s</LEASES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LEASES':
            LEASES_ = child_.text
            LEASES_ = self.gds_validate_string(LEASES_, node, 'LEASES')
            self.LEASES = LEASES_
        elif nodeName_ == 'LEASES_USED':
            LEASES_USED_ = child_.text
            LEASES_USED_ = self.gds_validate_string(LEASES_USED_, node, 'LEASES_USED')
            self.LEASES_USED = LEASES_USED_
# end class NETWORKType16


class VM_QUOTAType17(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType17.subclass:
            return VM_QUOTAType17.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_QUOTAType17', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_QUOTAType17')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_QUOTAType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_QUOTAType17'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_QUOTAType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VMType18.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType17


class VMType18(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None):
        self.original_tagname_ = None
        self.CPU = CPU
        self.CPU_USED = CPU_USED
        self.MEMORY = MEMORY
        self.MEMORY_USED = MEMORY_USED
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.VMS = VMS
        self.VMS_USED = VMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType18.subclass:
            return VMType18.subclass(*args_, **kwargs_)
        else:
            return VMType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPU(self): return self.CPU
    def set_CPU(self, CPU): self.CPU = CPU
    def get_CPU_USED(self): return self.CPU_USED
    def set_CPU_USED(self, CPU_USED): self.CPU_USED = CPU_USED
    def get_MEMORY(self): return self.MEMORY
    def set_MEMORY(self, MEMORY): self.MEMORY = MEMORY
    def get_MEMORY_USED(self): return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED): self.MEMORY_USED = MEMORY_USED
    def get_SYSTEM_DISK_SIZE(self): return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE): self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self): return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED): self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_VMS_USED(self): return self.VMS_USED
    def set_VMS_USED(self, VMS_USED): self.VMS_USED = VMS_USED
    def hasContent_(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType18', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType18')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType18'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU>%s</CPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), eol_))
        if self.CPU_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USED>%s</CPU_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), eol_))
        if self.MEMORY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY>%s</MEMORY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), eol_))
        if self.MEMORY_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY_USED>%s</MEMORY_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE>%s</SYSTEM_DISK_SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE_USED>%s</SYSTEM_DISK_SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), eol_))
        if self.VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS>%s</VMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), eol_))
        if self.VMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS_USED>%s</VMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPU':
            CPU_ = child_.text
            CPU_ = self.gds_validate_string(CPU_, node, 'CPU')
            self.CPU = CPU_
        elif nodeName_ == 'CPU_USED':
            CPU_USED_ = child_.text
            CPU_USED_ = self.gds_validate_string(CPU_USED_, node, 'CPU_USED')
            self.CPU_USED = CPU_USED_
        elif nodeName_ == 'MEMORY':
            MEMORY_ = child_.text
            MEMORY_ = self.gds_validate_string(MEMORY_, node, 'MEMORY')
            self.MEMORY = MEMORY_
        elif nodeName_ == 'MEMORY_USED':
            MEMORY_USED_ = child_.text
            MEMORY_USED_ = self.gds_validate_string(MEMORY_USED_, node, 'MEMORY_USED')
            self.MEMORY_USED = MEMORY_USED_
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            SYSTEM_DISK_SIZE_ = child_.text
            SYSTEM_DISK_SIZE_ = self.gds_validate_string(SYSTEM_DISK_SIZE_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE_
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            SYSTEM_DISK_SIZE_USED_ = child_.text
            SYSTEM_DISK_SIZE_USED_ = self.gds_validate_string(SYSTEM_DISK_SIZE_USED_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED_
        elif nodeName_ == 'VMS':
            VMS_ = child_.text
            VMS_ = self.gds_validate_string(VMS_, node, 'VMS')
            self.VMS = VMS_
        elif nodeName_ == 'VMS_USED':
            VMS_USED_ = child_.text
            VMS_USED_ = self.gds_validate_string(VMS_USED_, node, 'VMS_USED')
            self.VMS_USED = VMS_USED_
# end class VMType18


class IMAGE_QUOTAType19(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTAType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTAType19.subclass:
            return IMAGE_QUOTAType19.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTAType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType19', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTAType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_QUOTAType19')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_QUOTAType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_QUOTAType19'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType19', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType20.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTAType19


class IMAGEType20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.RVMS = RVMS
        self.RVMS_USED = RVMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType20.subclass:
            return IMAGEType20.subclass(*args_, **kwargs_)
        else:
            return IMAGEType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_RVMS(self): return self.RVMS
    def set_RVMS(self, RVMS): self.RVMS = RVMS
    def get_RVMS_USED(self): return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED): self.RVMS_USED = RVMS_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGEType20', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGEType20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGEType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGEType20'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGEType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.RVMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS>%s</RVMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), eol_))
        if self.RVMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS_USED>%s</RVMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'RVMS':
            RVMS_ = child_.text
            RVMS_ = self.gds_validate_string(RVMS_, node, 'RVMS')
            self.RVMS = RVMS_
        elif nodeName_ == 'RVMS_USED':
            RVMS_USED_ = child_.text
            RVMS_USED_ = self.gds_validate_string(RVMS_USED_, node, 'RVMS_USED')
            self.RVMS_USED = RVMS_USED_
# end class IMAGEType20


class DEFAULT_GROUP_QUOTASType21(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None):
        self.original_tagname_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.VM_QUOTA = VM_QUOTA
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_GROUP_QUOTASType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_GROUP_QUOTASType21.subclass:
            return DEFAULT_GROUP_QUOTASType21.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_GROUP_QUOTASType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE_QUOTA(self): return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA): self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self): return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA): self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self): return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA): self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self): return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA): self.IMAGE_QUOTA = IMAGE_QUOTA
    def hasContent_(self):
        if (
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DEFAULT_GROUP_QUOTASType21', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_GROUP_QUOTASType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DEFAULT_GROUP_QUOTASType21')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DEFAULT_GROUP_QUOTASType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DEFAULT_GROUP_QUOTASType21'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DEFAULT_GROUP_QUOTASType21', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATASTORE_QUOTA is not None:
            self.DATASTORE_QUOTA.export(outfile, level, namespace_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            self.NETWORK_QUOTA.export(outfile, level, namespace_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            self.VM_QUOTA.export(outfile, level, namespace_, name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            self.IMAGE_QUOTA.export(outfile, level, namespace_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTAType22.factory()
            obj_.build(child_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTAType24.factory()
            obj_.build(child_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType26.factory()
            obj_.build(child_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTAType28.factory()
            obj_.build(child_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class DEFAULT_GROUP_QUOTASType21


class DATASTORE_QUOTAType22(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTAType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTAType22.subclass:
            return DATASTORE_QUOTAType22.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTAType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType22', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTAType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_QUOTAType22')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_QUOTAType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_QUOTAType22'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType23.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTAType22


class DATASTOREType23(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.IMAGES = IMAGES
        self.IMAGES_USED = IMAGES_USED
        self.SIZE = SIZE
        self.SIZE_USED = SIZE_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType23.subclass:
            return DATASTOREType23.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_IMAGES_USED(self): return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED): self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_SIZE_USED(self): return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED): self.SIZE_USED = SIZE_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType23', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType23')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType23', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType23'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType23', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.IMAGES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES>%s</IMAGES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), eol_))
        if self.IMAGES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES_USED>%s</IMAGES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), eol_))
        if self.SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE_USED>%s</SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'IMAGES':
            IMAGES_ = child_.text
            IMAGES_ = self.gds_validate_string(IMAGES_, node, 'IMAGES')
            self.IMAGES = IMAGES_
        elif nodeName_ == 'IMAGES_USED':
            IMAGES_USED_ = child_.text
            IMAGES_USED_ = self.gds_validate_string(IMAGES_USED_, node, 'IMAGES_USED')
            self.IMAGES_USED = IMAGES_USED_
        elif nodeName_ == 'SIZE':
            SIZE_ = child_.text
            SIZE_ = self.gds_validate_string(SIZE_, node, 'SIZE')
            self.SIZE = SIZE_
        elif nodeName_ == 'SIZE_USED':
            SIZE_USED_ = child_.text
            SIZE_USED_ = self.gds_validate_string(SIZE_USED_, node, 'SIZE_USED')
            self.SIZE_USED = SIZE_USED_
# end class DATASTOREType23


class NETWORK_QUOTAType24(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None):
        self.original_tagname_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTAType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTAType24.subclass:
            return NETWORK_QUOTAType24.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTAType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NETWORK(self): return self.NETWORK
    def set_NETWORK(self, NETWORK): self.NETWORK = NETWORK
    def add_NETWORK(self, value): self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value): self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value): self.NETWORK[index] = value
    def hasContent_(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType24', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTAType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORK_QUOTAType24')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORK_QUOTAType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORK_QUOTAType24'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            NETWORK_.export(outfile, level, namespace_, name_='NETWORK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType25.factory()
            obj_.build(child_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTAType24


class NETWORKType25(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.LEASES = LEASES
        self.LEASES_USED = LEASES_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType25.subclass:
            return NETWORKType25.subclass(*args_, **kwargs_)
        else:
            return NETWORKType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def get_LEASES_USED(self): return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED): self.LEASES_USED = LEASES_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORKType25', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORKType25')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORKType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORKType25'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORKType25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES>%s</LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), eol_))
        if self.LEASES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES_USED>%s</LEASES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LEASES':
            LEASES_ = child_.text
            LEASES_ = self.gds_validate_string(LEASES_, node, 'LEASES')
            self.LEASES = LEASES_
        elif nodeName_ == 'LEASES_USED':
            LEASES_USED_ = child_.text
            LEASES_USED_ = self.gds_validate_string(LEASES_USED_, node, 'LEASES_USED')
            self.LEASES_USED = LEASES_USED_
# end class NETWORKType25


class VM_QUOTAType26(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType26.subclass:
            return VM_QUOTAType26.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_QUOTAType26', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_QUOTAType26')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_QUOTAType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_QUOTAType26'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_QUOTAType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VMType27.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType26


class VMType27(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None):
        self.original_tagname_ = None
        self.CPU = CPU
        self.CPU_USED = CPU_USED
        self.MEMORY = MEMORY
        self.MEMORY_USED = MEMORY_USED
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.VMS = VMS
        self.VMS_USED = VMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType27.subclass:
            return VMType27.subclass(*args_, **kwargs_)
        else:
            return VMType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPU(self): return self.CPU
    def set_CPU(self, CPU): self.CPU = CPU
    def get_CPU_USED(self): return self.CPU_USED
    def set_CPU_USED(self, CPU_USED): self.CPU_USED = CPU_USED
    def get_MEMORY(self): return self.MEMORY
    def set_MEMORY(self, MEMORY): self.MEMORY = MEMORY
    def get_MEMORY_USED(self): return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED): self.MEMORY_USED = MEMORY_USED
    def get_SYSTEM_DISK_SIZE(self): return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE): self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self): return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED): self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_VMS_USED(self): return self.VMS_USED
    def set_VMS_USED(self, VMS_USED): self.VMS_USED = VMS_USED
    def hasContent_(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType27', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType27')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType27')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType27', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType27'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType27', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU>%s</CPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), eol_))
        if self.CPU_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USED>%s</CPU_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), eol_))
        if self.MEMORY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY>%s</MEMORY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), eol_))
        if self.MEMORY_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY_USED>%s</MEMORY_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE>%s</SYSTEM_DISK_SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE_USED>%s</SYSTEM_DISK_SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), eol_))
        if self.VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS>%s</VMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), eol_))
        if self.VMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS_USED>%s</VMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPU':
            CPU_ = child_.text
            CPU_ = self.gds_validate_string(CPU_, node, 'CPU')
            self.CPU = CPU_
        elif nodeName_ == 'CPU_USED':
            CPU_USED_ = child_.text
            CPU_USED_ = self.gds_validate_string(CPU_USED_, node, 'CPU_USED')
            self.CPU_USED = CPU_USED_
        elif nodeName_ == 'MEMORY':
            MEMORY_ = child_.text
            MEMORY_ = self.gds_validate_string(MEMORY_, node, 'MEMORY')
            self.MEMORY = MEMORY_
        elif nodeName_ == 'MEMORY_USED':
            MEMORY_USED_ = child_.text
            MEMORY_USED_ = self.gds_validate_string(MEMORY_USED_, node, 'MEMORY_USED')
            self.MEMORY_USED = MEMORY_USED_
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            SYSTEM_DISK_SIZE_ = child_.text
            SYSTEM_DISK_SIZE_ = self.gds_validate_string(SYSTEM_DISK_SIZE_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE_
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            SYSTEM_DISK_SIZE_USED_ = child_.text
            SYSTEM_DISK_SIZE_USED_ = self.gds_validate_string(SYSTEM_DISK_SIZE_USED_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED_
        elif nodeName_ == 'VMS':
            VMS_ = child_.text
            VMS_ = self.gds_validate_string(VMS_, node, 'VMS')
            self.VMS = VMS_
        elif nodeName_ == 'VMS_USED':
            VMS_USED_ = child_.text
            VMS_USED_ = self.gds_validate_string(VMS_USED_, node, 'VMS_USED')
            self.VMS_USED = VMS_USED_
# end class VMType27


class IMAGE_QUOTAType28(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTAType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTAType28.subclass:
            return IMAGE_QUOTAType28.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTAType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType28', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTAType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_QUOTAType28')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_QUOTAType28', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_QUOTAType28'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType28', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType29.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTAType28


class IMAGEType29(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.RVMS = RVMS
        self.RVMS_USED = RVMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType29.subclass:
            return IMAGEType29.subclass(*args_, **kwargs_)
        else:
            return IMAGEType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_RVMS(self): return self.RVMS
    def set_RVMS(self, RVMS): self.RVMS = RVMS
    def get_RVMS_USED(self): return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED): self.RVMS_USED = RVMS_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGEType29', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGEType29')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGEType29', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGEType29'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGEType29', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.RVMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS>%s</RVMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), eol_))
        if self.RVMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS_USED>%s</RVMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'RVMS':
            RVMS_ = child_.text
            RVMS_ = self.gds_validate_string(RVMS_, node, 'RVMS')
            self.RVMS = RVMS_
        elif nodeName_ == 'RVMS_USED':
            RVMS_USED_ = child_.text
            RVMS_USED_ = self.gds_validate_string(RVMS_USED_, node, 'RVMS_USED')
            self.RVMS_USED = RVMS_USED_
# end class IMAGEType29


class HOST_SHAREType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DISK_USAGE=None, MEM_USAGE=None, CPU_USAGE=None, TOTAL_MEM=None, TOTAL_CPU=None, MAX_DISK=None, MAX_MEM=None, MAX_CPU=None, FREE_DISK=None, FREE_MEM=None, FREE_CPU=None, USED_DISK=None, USED_MEM=None, USED_CPU=None, RUNNING_VMS=None, DATASTORES=None, PCI_DEVICES=None):
        self.original_tagname_ = None
        self.DISK_USAGE = DISK_USAGE
        self.MEM_USAGE = MEM_USAGE
        self.CPU_USAGE = CPU_USAGE
        self.TOTAL_MEM = TOTAL_MEM
        self.TOTAL_CPU = TOTAL_CPU
        self.MAX_DISK = MAX_DISK
        self.MAX_MEM = MAX_MEM
        self.MAX_CPU = MAX_CPU
        self.FREE_DISK = FREE_DISK
        self.FREE_MEM = FREE_MEM
        self.FREE_CPU = FREE_CPU
        self.USED_DISK = USED_DISK
        self.USED_MEM = USED_MEM
        self.USED_CPU = USED_CPU
        self.RUNNING_VMS = RUNNING_VMS
        self.DATASTORES = DATASTORES
        self.PCI_DEVICES = PCI_DEVICES
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOST_SHAREType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOST_SHAREType.subclass:
            return HOST_SHAREType.subclass(*args_, **kwargs_)
        else:
            return HOST_SHAREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DISK_USAGE(self): return self.DISK_USAGE
    def set_DISK_USAGE(self, DISK_USAGE): self.DISK_USAGE = DISK_USAGE
    def get_MEM_USAGE(self): return self.MEM_USAGE
    def set_MEM_USAGE(self, MEM_USAGE): self.MEM_USAGE = MEM_USAGE
    def get_CPU_USAGE(self): return self.CPU_USAGE
    def set_CPU_USAGE(self, CPU_USAGE): self.CPU_USAGE = CPU_USAGE
    def get_TOTAL_MEM(self): return self.TOTAL_MEM
    def set_TOTAL_MEM(self, TOTAL_MEM): self.TOTAL_MEM = TOTAL_MEM
    def get_TOTAL_CPU(self): return self.TOTAL_CPU
    def set_TOTAL_CPU(self, TOTAL_CPU): self.TOTAL_CPU = TOTAL_CPU
    def get_MAX_DISK(self): return self.MAX_DISK
    def set_MAX_DISK(self, MAX_DISK): self.MAX_DISK = MAX_DISK
    def get_MAX_MEM(self): return self.MAX_MEM
    def set_MAX_MEM(self, MAX_MEM): self.MAX_MEM = MAX_MEM
    def get_MAX_CPU(self): return self.MAX_CPU
    def set_MAX_CPU(self, MAX_CPU): self.MAX_CPU = MAX_CPU
    def get_FREE_DISK(self): return self.FREE_DISK
    def set_FREE_DISK(self, FREE_DISK): self.FREE_DISK = FREE_DISK
    def get_FREE_MEM(self): return self.FREE_MEM
    def set_FREE_MEM(self, FREE_MEM): self.FREE_MEM = FREE_MEM
    def get_FREE_CPU(self): return self.FREE_CPU
    def set_FREE_CPU(self, FREE_CPU): self.FREE_CPU = FREE_CPU
    def get_USED_DISK(self): return self.USED_DISK
    def set_USED_DISK(self, USED_DISK): self.USED_DISK = USED_DISK
    def get_USED_MEM(self): return self.USED_MEM
    def set_USED_MEM(self, USED_MEM): self.USED_MEM = USED_MEM
    def get_USED_CPU(self): return self.USED_CPU
    def set_USED_CPU(self, USED_CPU): self.USED_CPU = USED_CPU
    def get_RUNNING_VMS(self): return self.RUNNING_VMS
    def set_RUNNING_VMS(self, RUNNING_VMS): self.RUNNING_VMS = RUNNING_VMS
    def get_DATASTORES(self): return self.DATASTORES
    def set_DATASTORES(self, DATASTORES): self.DATASTORES = DATASTORES
    def get_PCI_DEVICES(self): return self.PCI_DEVICES
    def set_PCI_DEVICES(self, PCI_DEVICES): self.PCI_DEVICES = PCI_DEVICES
    def hasContent_(self):
        if (
            self.DISK_USAGE is not None or
            self.MEM_USAGE is not None or
            self.CPU_USAGE is not None or
            self.TOTAL_MEM is not None or
            self.TOTAL_CPU is not None or
            self.MAX_DISK is not None or
            self.MAX_MEM is not None or
            self.MAX_CPU is not None or
            self.FREE_DISK is not None or
            self.FREE_MEM is not None or
            self.FREE_CPU is not None or
            self.USED_DISK is not None or
            self.USED_MEM is not None or
            self.USED_CPU is not None or
            self.RUNNING_VMS is not None or
            self.DATASTORES is not None or
            self.PCI_DEVICES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HOST_SHAREType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOST_SHAREType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HOST_SHAREType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HOST_SHAREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HOST_SHAREType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HOST_SHAREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DISK_USAGE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DISK_USAGE>%s</DISK_USAGE>%s' % (self.gds_format_integer(self.DISK_USAGE, input_name='DISK_USAGE'), eol_))
        if self.MEM_USAGE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEM_USAGE>%s</MEM_USAGE>%s' % (self.gds_format_integer(self.MEM_USAGE, input_name='MEM_USAGE'), eol_))
        if self.CPU_USAGE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USAGE>%s</CPU_USAGE>%s' % (self.gds_format_integer(self.CPU_USAGE, input_name='CPU_USAGE'), eol_))
        if self.TOTAL_MEM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TOTAL_MEM>%s</TOTAL_MEM>%s' % (self.gds_format_integer(self.TOTAL_MEM, input_name='TOTAL_MEM'), eol_))
        if self.TOTAL_CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TOTAL_CPU>%s</TOTAL_CPU>%s' % (self.gds_format_integer(self.TOTAL_CPU, input_name='TOTAL_CPU'), eol_))
        if self.MAX_DISK is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MAX_DISK>%s</MAX_DISK>%s' % (self.gds_format_integer(self.MAX_DISK, input_name='MAX_DISK'), eol_))
        if self.MAX_MEM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MAX_MEM>%s</MAX_MEM>%s' % (self.gds_format_integer(self.MAX_MEM, input_name='MAX_MEM'), eol_))
        if self.MAX_CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MAX_CPU>%s</MAX_CPU>%s' % (self.gds_format_integer(self.MAX_CPU, input_name='MAX_CPU'), eol_))
        if self.FREE_DISK is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FREE_DISK>%s</FREE_DISK>%s' % (self.gds_format_integer(self.FREE_DISK, input_name='FREE_DISK'), eol_))
        if self.FREE_MEM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FREE_MEM>%s</FREE_MEM>%s' % (self.gds_format_integer(self.FREE_MEM, input_name='FREE_MEM'), eol_))
        if self.FREE_CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FREE_CPU>%s</FREE_CPU>%s' % (self.gds_format_integer(self.FREE_CPU, input_name='FREE_CPU'), eol_))
        if self.USED_DISK is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_DISK>%s</USED_DISK>%s' % (self.gds_format_integer(self.USED_DISK, input_name='USED_DISK'), eol_))
        if self.USED_MEM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_MEM>%s</USED_MEM>%s' % (self.gds_format_integer(self.USED_MEM, input_name='USED_MEM'), eol_))
        if self.USED_CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_CPU>%s</USED_CPU>%s' % (self.gds_format_integer(self.USED_CPU, input_name='USED_CPU'), eol_))
        if self.RUNNING_VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RUNNING_VMS>%s</RUNNING_VMS>%s' % (self.gds_format_integer(self.RUNNING_VMS, input_name='RUNNING_VMS'), eol_))
        if self.DATASTORES is not None:
            self.DATASTORES.export(outfile, level, namespace_, name_='DATASTORES', pretty_print=pretty_print)
        if self.PCI_DEVICES is not None:
            self.PCI_DEVICES.export(outfile, level, namespace_, name_='PCI_DEVICES', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DISK_USAGE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_USAGE')
            self.DISK_USAGE = ival_
        elif nodeName_ == 'MEM_USAGE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MEM_USAGE')
            self.MEM_USAGE = ival_
        elif nodeName_ == 'CPU_USAGE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CPU_USAGE')
            self.CPU_USAGE = ival_
        elif nodeName_ == 'TOTAL_MEM':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_MEM')
            self.TOTAL_MEM = ival_
        elif nodeName_ == 'TOTAL_CPU':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_CPU')
            self.TOTAL_CPU = ival_
        elif nodeName_ == 'MAX_DISK':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_DISK')
            self.MAX_DISK = ival_
        elif nodeName_ == 'MAX_MEM':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_MEM')
            self.MAX_MEM = ival_
        elif nodeName_ == 'MAX_CPU':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_CPU')
            self.MAX_CPU = ival_
        elif nodeName_ == 'FREE_DISK':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_DISK')
            self.FREE_DISK = ival_
        elif nodeName_ == 'FREE_MEM':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_MEM')
            self.FREE_MEM = ival_
        elif nodeName_ == 'FREE_CPU':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_CPU')
            self.FREE_CPU = ival_
        elif nodeName_ == 'USED_DISK':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'USED_DISK')
            self.USED_DISK = ival_
        elif nodeName_ == 'USED_MEM':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'USED_MEM')
            self.USED_MEM = ival_
        elif nodeName_ == 'USED_CPU':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'USED_CPU')
            self.USED_CPU = ival_
        elif nodeName_ == 'RUNNING_VMS':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RUNNING_VMS')
            self.RUNNING_VMS = ival_
        elif nodeName_ == 'DATASTORES':
            obj_ = DATASTORESType30.factory()
            obj_.build(child_)
            self.DATASTORES = obj_
            obj_.original_tagname_ = 'DATASTORES'
        elif nodeName_ == 'PCI_DEVICES':
            obj_ = PCI_DEVICESType.factory()
            obj_.build(child_)
            self.PCI_DEVICES = obj_
            obj_.original_tagname_ = 'PCI_DEVICES'
# end class HOST_SHAREType


class DATASTORESType30(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DS=None):
        self.original_tagname_ = None
        if DS is None:
            self.DS = []
        else:
            self.DS = DS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORESType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORESType30.subclass:
            return DATASTORESType30.subclass(*args_, **kwargs_)
        else:
            return DATASTORESType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS(self): return self.DS
    def set_DS(self, DS): self.DS = DS
    def add_DS(self, value): self.DS.append(value)
    def insert_DS_at(self, index, value): self.DS.insert(index, value)
    def replace_DS_at(self, index, value): self.DS[index] = value
    def hasContent_(self):
        if (
            self.DS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORESType30', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORESType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORESType30')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORESType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORESType30'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORESType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DS_ in self.DS:
            DS_.export(outfile, level, namespace_, name_='DS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS':
            obj_ = DSType.factory()
            obj_.build(child_)
            self.DS.append(obj_)
            obj_.original_tagname_ = 'DS'
# end class DATASTORESType30


class DSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, FREE_MB=None, TOTAL_MB=None, USED_MB=None):
        self.original_tagname_ = None
        self.ID = ID
        self.FREE_MB = FREE_MB
        self.TOTAL_MB = TOTAL_MB
        self.USED_MB = USED_MB
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DSType.subclass:
            return DSType.subclass(*args_, **kwargs_)
        else:
            return DSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_FREE_MB(self): return self.FREE_MB
    def set_FREE_MB(self, FREE_MB): self.FREE_MB = FREE_MB
    def get_TOTAL_MB(self): return self.TOTAL_MB
    def set_TOTAL_MB(self, TOTAL_MB): self.TOTAL_MB = TOTAL_MB
    def get_USED_MB(self): return self.USED_MB
    def set_USED_MB(self, USED_MB): self.USED_MB = USED_MB
    def hasContent_(self):
        if (
            self.ID is not None or
            self.FREE_MB is not None or
            self.TOTAL_MB is not None or
            self.USED_MB is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.FREE_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FREE_MB>%s</FREE_MB>%s' % (self.gds_format_integer(self.FREE_MB, input_name='FREE_MB'), eol_))
        if self.TOTAL_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TOTAL_MB>%s</TOTAL_MB>%s' % (self.gds_format_integer(self.TOTAL_MB, input_name='TOTAL_MB'), eol_))
        if self.USED_MB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_MB>%s</USED_MB>%s' % (self.gds_format_integer(self.USED_MB, input_name='USED_MB'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'FREE_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FREE_MB')
            self.FREE_MB = ival_
        elif nodeName_ == 'TOTAL_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TOTAL_MB')
            self.TOTAL_MB = ival_
        elif nodeName_ == 'USED_MB':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'USED_MB')
            self.USED_MB = ival_
# end class DSType


class PCI_DEVICESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PCI=None):
        self.original_tagname_ = None
        if PCI is None:
            self.PCI = []
        else:
            self.PCI = PCI
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCI_DEVICESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCI_DEVICESType.subclass:
            return PCI_DEVICESType.subclass(*args_, **kwargs_)
        else:
            return PCI_DEVICESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PCI(self): return self.PCI
    def set_PCI(self, PCI): self.PCI = PCI
    def add_PCI(self, value): self.PCI.append(value)
    def insert_PCI_at(self, index, value): self.PCI.insert(index, value)
    def replace_PCI_at(self, index, value): self.PCI[index] = value
    def hasContent_(self):
        if (
            self.PCI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PCI_DEVICESType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCI_DEVICESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PCI_DEVICESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PCI_DEVICESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PCI_DEVICESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PCI_DEVICESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PCI_ in self.PCI:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PCI>%s</PCI>%s' % (self.gds_encode(self.gds_format_string(quote_xml(PCI_), input_name='PCI')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PCI':
            PCI_ = child_.text
            PCI_ = self.gds_validate_string(PCI_, node, 'PCI')
            self.PCI.append(PCI_)
# end class PCI_DEVICESType


class VMSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMSType.subclass:
            return VMSType.subclass(*args_, **kwargs_)
        else:
            return VMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class VMSType


class PERMISSIONSType31(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType31.subclass:
            return PERMISSIONSType31.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType31', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType31')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType31', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType31'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType31', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType31


class VMSType32(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMSType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMSType32.subclass:
            return VMSType32.subclass(*args_, **kwargs_)
        else:
            return VMSType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMSType32', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMSType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMSType32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMSType32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMSType32'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMSType32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class VMSType32


class CLONESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLONESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLONESType.subclass:
            return CLONESType.subclass(*args_, **kwargs_)
        else:
            return CLONESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CLONESType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLONESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLONESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CLONESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLONESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLONESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class CLONESType


class APP_CLONESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, APP_CLONESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if APP_CLONESType.subclass:
            return APP_CLONESType.subclass(*args_, **kwargs_)
        else:
            return APP_CLONESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='APP_CLONESType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('APP_CLONESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='APP_CLONESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='APP_CLONESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='APP_CLONESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='APP_CLONESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class APP_CLONESType


class SNAPSHOTSType33(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ALLOW_ORPHANS=None, SNAPSHOT=None):
        self.original_tagname_ = None
        self.ALLOW_ORPHANS = ALLOW_ORPHANS
        if SNAPSHOT is None:
            self.SNAPSHOT = []
        else:
            self.SNAPSHOT = SNAPSHOT
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTSType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTSType33.subclass:
            return SNAPSHOTSType33.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTSType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ALLOW_ORPHANS(self): return self.ALLOW_ORPHANS
    def set_ALLOW_ORPHANS(self, ALLOW_ORPHANS): self.ALLOW_ORPHANS = ALLOW_ORPHANS
    def get_SNAPSHOT(self): return self.SNAPSHOT
    def set_SNAPSHOT(self, SNAPSHOT): self.SNAPSHOT = SNAPSHOT
    def add_SNAPSHOT(self, value): self.SNAPSHOT.append(value)
    def insert_SNAPSHOT_at(self, index, value): self.SNAPSHOT.insert(index, value)
    def replace_SNAPSHOT_at(self, index, value): self.SNAPSHOT[index] = value
    def hasContent_(self):
        if (
            self.ALLOW_ORPHANS is not None or
            self.SNAPSHOT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SNAPSHOTSType33', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTSType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SNAPSHOTSType33')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SNAPSHOTSType33', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SNAPSHOTSType33'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SNAPSHOTSType33', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALLOW_ORPHANS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ALLOW_ORPHANS>%s</ALLOW_ORPHANS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ALLOW_ORPHANS), input_name='ALLOW_ORPHANS')), eol_))
        for SNAPSHOT_ in self.SNAPSHOT:
            SNAPSHOT_.export(outfile, level, namespace_, name_='SNAPSHOT', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ALLOW_ORPHANS':
            ALLOW_ORPHANS_ = child_.text
            ALLOW_ORPHANS_ = self.gds_validate_string(ALLOW_ORPHANS_, node, 'ALLOW_ORPHANS')
            self.ALLOW_ORPHANS = ALLOW_ORPHANS_
        elif nodeName_ == 'SNAPSHOT':
            obj_ = SNAPSHOTType34.factory()
            obj_.build(child_)
            self.SNAPSHOT.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOT'
# end class SNAPSHOTSType33


class SNAPSHOTType34(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CHILDREN=None, ACTIVE=None, DATE=None, ID=None, NAME=None, PARENT=None, SIZE=None):
        self.original_tagname_ = None
        self.CHILDREN = CHILDREN
        self.ACTIVE = ACTIVE
        self.DATE = DATE
        self.ID = ID
        self.NAME = NAME
        self.PARENT = PARENT
        self.SIZE = SIZE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTType34.subclass:
            return SNAPSHOTType34.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CHILDREN(self): return self.CHILDREN
    def set_CHILDREN(self, CHILDREN): self.CHILDREN = CHILDREN
    def get_ACTIVE(self): return self.ACTIVE
    def set_ACTIVE(self, ACTIVE): self.ACTIVE = ACTIVE
    def get_DATE(self): return self.DATE
    def set_DATE(self, DATE): self.DATE = DATE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PARENT(self): return self.PARENT
    def set_PARENT(self, PARENT): self.PARENT = PARENT
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def hasContent_(self):
        if (
            self.CHILDREN is not None or
            self.ACTIVE is not None or
            self.DATE is not None or
            self.ID is not None or
            self.NAME is not None or
            self.PARENT is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SNAPSHOTType34', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTType34')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SNAPSHOTType34')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SNAPSHOTType34', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SNAPSHOTType34'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SNAPSHOTType34', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CHILDREN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CHILDREN>%s</CHILDREN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CHILDREN), input_name='CHILDREN')), eol_))
        if self.ACTIVE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ACTIVE>%s</ACTIVE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ACTIVE), input_name='ACTIVE')), eol_))
        if self.DATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATE>%s</DATE>%s' % (self.gds_format_integer(self.DATE, input_name='DATE'), eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PARENT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PARENT>%s</PARENT>%s' % (self.gds_format_integer(self.PARENT, input_name='PARENT'), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_format_integer(self.SIZE, input_name='SIZE'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CHILDREN':
            CHILDREN_ = child_.text
            CHILDREN_ = self.gds_validate_string(CHILDREN_, node, 'CHILDREN')
            self.CHILDREN = CHILDREN_
        elif nodeName_ == 'ACTIVE':
            ACTIVE_ = child_.text
            ACTIVE_ = self.gds_validate_string(ACTIVE_, node, 'ACTIVE')
            self.ACTIVE = ACTIVE_
        elif nodeName_ == 'DATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DATE')
            self.DATE = ival_
        elif nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PARENT':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PARENT')
            self.PARENT = ival_
        elif nodeName_ == 'SIZE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
# end class SNAPSHOTType34


class PERMISSIONSType35(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType35.subclass:
            return PERMISSIONSType35.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType35', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType35')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType35', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType35'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType35', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType35


class MARKETPLACEAPPSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MARKETPLACEAPPSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MARKETPLACEAPPSType.subclass:
            return MARKETPLACEAPPSType.subclass(*args_, **kwargs_)
        else:
            return MARKETPLACEAPPSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MARKETPLACEAPPSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MARKETPLACEAPPSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MARKETPLACEAPPSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MARKETPLACEAPPSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MARKETPLACEAPPSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MARKETPLACEAPPSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class MARKETPLACEAPPSType


class PERMISSIONSType36(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType36.subclass:
            return PERMISSIONSType36.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType36', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType36')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType36', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType36'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType36', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType36


class USERType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, GID=None, GROUPS=None, GNAME=None, NAME=None, PASSWORD=None, AUTH_DRIVER=None, ENABLED=None, LOGIN_TOKEN=None, TEMPLATE=None):
        self.original_tagname_ = None
        self.ID = ID
        self.GID = GID
        self.GROUPS = GROUPS
        self.GNAME = GNAME
        self.NAME = NAME
        self.PASSWORD = PASSWORD
        self.AUTH_DRIVER = AUTH_DRIVER
        self.ENABLED = ENABLED
        if LOGIN_TOKEN is None:
            self.LOGIN_TOKEN = []
        else:
            self.LOGIN_TOKEN = LOGIN_TOKEN
        self.TEMPLATE = TEMPLATE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USERType.subclass:
            return USERType.subclass(*args_, **kwargs_)
        else:
            return USERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_GROUPS(self): return self.GROUPS
    def set_GROUPS(self, GROUPS): self.GROUPS = GROUPS
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PASSWORD(self): return self.PASSWORD
    def set_PASSWORD(self, PASSWORD): self.PASSWORD = PASSWORD
    def get_AUTH_DRIVER(self): return self.AUTH_DRIVER
    def set_AUTH_DRIVER(self, AUTH_DRIVER): self.AUTH_DRIVER = AUTH_DRIVER
    def get_ENABLED(self): return self.ENABLED
    def set_ENABLED(self, ENABLED): self.ENABLED = ENABLED
    def get_LOGIN_TOKEN(self): return self.LOGIN_TOKEN
    def set_LOGIN_TOKEN(self, LOGIN_TOKEN): self.LOGIN_TOKEN = LOGIN_TOKEN
    def add_LOGIN_TOKEN(self, value): self.LOGIN_TOKEN.append(value)
    def insert_LOGIN_TOKEN_at(self, index, value): self.LOGIN_TOKEN.insert(index, value)
    def replace_LOGIN_TOKEN_at(self, index, value): self.LOGIN_TOKEN[index] = value
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def hasContent_(self):
        if (
            self.ID is not None or
            self.GID is not None or
            self.GROUPS is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PASSWORD is not None or
            self.AUTH_DRIVER is not None or
            self.ENABLED is not None or
            self.LOGIN_TOKEN or
            self.TEMPLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='USERType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='USERType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='USERType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='USERType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='USERType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.GROUPS is not None:
            self.GROUPS.export(outfile, level, namespace_, name_='GROUPS', pretty_print=pretty_print)
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PASSWORD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PASSWORD>%s</PASSWORD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PASSWORD), input_name='PASSWORD')), eol_))
        if self.AUTH_DRIVER is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AUTH_DRIVER>%s</AUTH_DRIVER>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AUTH_DRIVER), input_name='AUTH_DRIVER')), eol_))
        if self.ENABLED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ENABLED>%s</ENABLED>%s' % (self.gds_format_integer(self.ENABLED, input_name='ENABLED'), eol_))
        for LOGIN_TOKEN_ in self.LOGIN_TOKEN:
            LOGIN_TOKEN_.export(outfile, level, namespace_, name_='LOGIN_TOKEN', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'GROUPS':
            obj_ = GROUPSType.factory()
            obj_.build(child_)
            self.GROUPS = obj_
            obj_.original_tagname_ = 'GROUPS'
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PASSWORD':
            PASSWORD_ = child_.text
            PASSWORD_ = self.gds_validate_string(PASSWORD_, node, 'PASSWORD')
            self.PASSWORD = PASSWORD_
        elif nodeName_ == 'AUTH_DRIVER':
            AUTH_DRIVER_ = child_.text
            AUTH_DRIVER_ = self.gds_validate_string(AUTH_DRIVER_, node, 'AUTH_DRIVER')
            self.AUTH_DRIVER = AUTH_DRIVER_
        elif nodeName_ == 'ENABLED':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ENABLED')
            self.ENABLED = ival_
        elif nodeName_ == 'LOGIN_TOKEN':
            obj_ = LOGIN_TOKENType.factory()
            obj_.build(child_)
            self.LOGIN_TOKEN.append(obj_)
            obj_.original_tagname_ = 'LOGIN_TOKEN'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
# end class USERType


class GROUPSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUPSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUPSType.subclass:
            return GROUPSType.subclass(*args_, **kwargs_)
        else:
            return GROUPSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GROUPSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUPSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GROUPSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GROUPSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GROUPSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GROUPSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class GROUPSType


class LOGIN_TOKENType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TOKEN=None, EXPIRATION_TIME=None, EGID=None):
        self.original_tagname_ = None
        self.TOKEN = TOKEN
        self.EXPIRATION_TIME = EXPIRATION_TIME
        self.EGID = EGID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOGIN_TOKENType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOGIN_TOKENType.subclass:
            return LOGIN_TOKENType.subclass(*args_, **kwargs_)
        else:
            return LOGIN_TOKENType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TOKEN(self): return self.TOKEN
    def set_TOKEN(self, TOKEN): self.TOKEN = TOKEN
    def get_EXPIRATION_TIME(self): return self.EXPIRATION_TIME
    def set_EXPIRATION_TIME(self, EXPIRATION_TIME): self.EXPIRATION_TIME = EXPIRATION_TIME
    def get_EGID(self): return self.EGID
    def set_EGID(self, EGID): self.EGID = EGID
    def hasContent_(self):
        if (
            self.TOKEN is not None or
            self.EXPIRATION_TIME is not None or
            self.EGID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LOGIN_TOKENType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOGIN_TOKENType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LOGIN_TOKENType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LOGIN_TOKENType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LOGIN_TOKENType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LOGIN_TOKENType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TOKEN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TOKEN>%s</TOKEN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TOKEN), input_name='TOKEN')), eol_))
        if self.EXPIRATION_TIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EXPIRATION_TIME>%s</EXPIRATION_TIME>%s' % (self.gds_format_integer(self.EXPIRATION_TIME, input_name='EXPIRATION_TIME'), eol_))
        if self.EGID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EGID>%s</EGID>%s' % (self.gds_format_integer(self.EGID, input_name='EGID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TOKEN':
            TOKEN_ = child_.text
            TOKEN_ = self.gds_validate_string(TOKEN_, node, 'TOKEN')
            self.TOKEN = TOKEN_
        elif nodeName_ == 'EXPIRATION_TIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EXPIRATION_TIME')
            self.EXPIRATION_TIME = ival_
        elif nodeName_ == 'EGID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EGID')
            self.EGID = ival_
# end class LOGIN_TOKENType


class QUOTASType37(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None):
        self.original_tagname_ = None
        self.ID = ID
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.VM_QUOTA = VM_QUOTA
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QUOTASType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QUOTASType37.subclass:
            return QUOTASType37.subclass(*args_, **kwargs_)
        else:
            return QUOTASType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DATASTORE_QUOTA(self): return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA): self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self): return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA): self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self): return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA): self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self): return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA): self.IMAGE_QUOTA = IMAGE_QUOTA
    def hasContent_(self):
        if (
            self.ID is not None or
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QUOTASType37', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QUOTASType37')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QUOTASType37')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QUOTASType37', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QUOTASType37'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QUOTASType37', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.DATASTORE_QUOTA is not None:
            self.DATASTORE_QUOTA.export(outfile, level, namespace_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            self.NETWORK_QUOTA.export(outfile, level, namespace_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            self.VM_QUOTA.export(outfile, level, namespace_, name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            self.IMAGE_QUOTA.export(outfile, level, namespace_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTAType38.factory()
            obj_.build(child_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTAType40.factory()
            obj_.build(child_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType42.factory()
            obj_.build(child_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTAType44.factory()
            obj_.build(child_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class QUOTASType37


class DATASTORE_QUOTAType38(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTAType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTAType38.subclass:
            return DATASTORE_QUOTAType38.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTAType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType38', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTAType38')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_QUOTAType38')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_QUOTAType38', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_QUOTAType38'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType38', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType39.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTAType38


class DATASTOREType39(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.IMAGES = IMAGES
        self.IMAGES_USED = IMAGES_USED
        self.SIZE = SIZE
        self.SIZE_USED = SIZE_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType39.subclass:
            return DATASTOREType39.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_IMAGES_USED(self): return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED): self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_SIZE_USED(self): return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED): self.SIZE_USED = SIZE_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType39', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType39')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType39')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType39', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType39'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType39', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.IMAGES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES>%s</IMAGES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), eol_))
        if self.IMAGES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES_USED>%s</IMAGES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), eol_))
        if self.SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE_USED>%s</SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'IMAGES':
            IMAGES_ = child_.text
            IMAGES_ = self.gds_validate_string(IMAGES_, node, 'IMAGES')
            self.IMAGES = IMAGES_
        elif nodeName_ == 'IMAGES_USED':
            IMAGES_USED_ = child_.text
            IMAGES_USED_ = self.gds_validate_string(IMAGES_USED_, node, 'IMAGES_USED')
            self.IMAGES_USED = IMAGES_USED_
        elif nodeName_ == 'SIZE':
            SIZE_ = child_.text
            SIZE_ = self.gds_validate_string(SIZE_, node, 'SIZE')
            self.SIZE = SIZE_
        elif nodeName_ == 'SIZE_USED':
            SIZE_USED_ = child_.text
            SIZE_USED_ = self.gds_validate_string(SIZE_USED_, node, 'SIZE_USED')
            self.SIZE_USED = SIZE_USED_
# end class DATASTOREType39


class NETWORK_QUOTAType40(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None):
        self.original_tagname_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTAType40)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTAType40.subclass:
            return NETWORK_QUOTAType40.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTAType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NETWORK(self): return self.NETWORK
    def set_NETWORK(self, NETWORK): self.NETWORK = NETWORK
    def add_NETWORK(self, value): self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value): self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value): self.NETWORK[index] = value
    def hasContent_(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType40', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTAType40')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORK_QUOTAType40')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORK_QUOTAType40', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORK_QUOTAType40'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType40', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            NETWORK_.export(outfile, level, namespace_, name_='NETWORK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType41.factory()
            obj_.build(child_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTAType40


class NETWORKType41(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.LEASES = LEASES
        self.LEASES_USED = LEASES_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType41)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType41.subclass:
            return NETWORKType41.subclass(*args_, **kwargs_)
        else:
            return NETWORKType41(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def get_LEASES_USED(self): return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED): self.LEASES_USED = LEASES_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORKType41', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType41')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORKType41')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORKType41', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORKType41'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORKType41', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES>%s</LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), eol_))
        if self.LEASES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES_USED>%s</LEASES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LEASES':
            LEASES_ = child_.text
            LEASES_ = self.gds_validate_string(LEASES_, node, 'LEASES')
            self.LEASES = LEASES_
        elif nodeName_ == 'LEASES_USED':
            LEASES_USED_ = child_.text
            LEASES_USED_ = self.gds_validate_string(LEASES_USED_, node, 'LEASES_USED')
            self.LEASES_USED = LEASES_USED_
# end class NETWORKType41


class VM_QUOTAType42(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType42.subclass:
            return VM_QUOTAType42.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_QUOTAType42', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType42')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_QUOTAType42')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_QUOTAType42', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_QUOTAType42'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_QUOTAType42', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VMType43.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType42


class VMType43(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None):
        self.original_tagname_ = None
        self.CPU = CPU
        self.CPU_USED = CPU_USED
        self.MEMORY = MEMORY
        self.MEMORY_USED = MEMORY_USED
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.VMS = VMS
        self.VMS_USED = VMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType43.subclass:
            return VMType43.subclass(*args_, **kwargs_)
        else:
            return VMType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPU(self): return self.CPU
    def set_CPU(self, CPU): self.CPU = CPU
    def get_CPU_USED(self): return self.CPU_USED
    def set_CPU_USED(self, CPU_USED): self.CPU_USED = CPU_USED
    def get_MEMORY(self): return self.MEMORY
    def set_MEMORY(self, MEMORY): self.MEMORY = MEMORY
    def get_MEMORY_USED(self): return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED): self.MEMORY_USED = MEMORY_USED
    def get_SYSTEM_DISK_SIZE(self): return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE): self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self): return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED): self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_VMS_USED(self): return self.VMS_USED
    def set_VMS_USED(self, VMS_USED): self.VMS_USED = VMS_USED
    def hasContent_(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType43', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType43')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType43')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType43', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType43'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType43', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU>%s</CPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), eol_))
        if self.CPU_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USED>%s</CPU_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), eol_))
        if self.MEMORY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY>%s</MEMORY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), eol_))
        if self.MEMORY_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY_USED>%s</MEMORY_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE>%s</SYSTEM_DISK_SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE_USED>%s</SYSTEM_DISK_SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), eol_))
        if self.VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS>%s</VMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), eol_))
        if self.VMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS_USED>%s</VMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPU':
            CPU_ = child_.text
            CPU_ = self.gds_validate_string(CPU_, node, 'CPU')
            self.CPU = CPU_
        elif nodeName_ == 'CPU_USED':
            CPU_USED_ = child_.text
            CPU_USED_ = self.gds_validate_string(CPU_USED_, node, 'CPU_USED')
            self.CPU_USED = CPU_USED_
        elif nodeName_ == 'MEMORY':
            MEMORY_ = child_.text
            MEMORY_ = self.gds_validate_string(MEMORY_, node, 'MEMORY')
            self.MEMORY = MEMORY_
        elif nodeName_ == 'MEMORY_USED':
            MEMORY_USED_ = child_.text
            MEMORY_USED_ = self.gds_validate_string(MEMORY_USED_, node, 'MEMORY_USED')
            self.MEMORY_USED = MEMORY_USED_
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            SYSTEM_DISK_SIZE_ = child_.text
            SYSTEM_DISK_SIZE_ = self.gds_validate_string(SYSTEM_DISK_SIZE_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE_
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            SYSTEM_DISK_SIZE_USED_ = child_.text
            SYSTEM_DISK_SIZE_USED_ = self.gds_validate_string(SYSTEM_DISK_SIZE_USED_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED_
        elif nodeName_ == 'VMS':
            VMS_ = child_.text
            VMS_ = self.gds_validate_string(VMS_, node, 'VMS')
            self.VMS = VMS_
        elif nodeName_ == 'VMS_USED':
            VMS_USED_ = child_.text
            VMS_USED_ = self.gds_validate_string(VMS_USED_, node, 'VMS_USED')
            self.VMS_USED = VMS_USED_
# end class VMType43


class IMAGE_QUOTAType44(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTAType44)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTAType44.subclass:
            return IMAGE_QUOTAType44.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTAType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType44', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTAType44')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_QUOTAType44')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_QUOTAType44', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_QUOTAType44'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType44', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType45.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTAType44


class IMAGEType45(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.RVMS = RVMS
        self.RVMS_USED = RVMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType45.subclass:
            return IMAGEType45.subclass(*args_, **kwargs_)
        else:
            return IMAGEType45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_RVMS(self): return self.RVMS
    def set_RVMS(self, RVMS): self.RVMS = RVMS
    def get_RVMS_USED(self): return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED): self.RVMS_USED = RVMS_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGEType45', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType45')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGEType45')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGEType45', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGEType45'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGEType45', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.RVMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS>%s</RVMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), eol_))
        if self.RVMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS_USED>%s</RVMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'RVMS':
            RVMS_ = child_.text
            RVMS_ = self.gds_validate_string(RVMS_, node, 'RVMS')
            self.RVMS = RVMS_
        elif nodeName_ == 'RVMS_USED':
            RVMS_USED_ = child_.text
            RVMS_USED_ = self.gds_validate_string(RVMS_USED_, node, 'RVMS_USED')
            self.RVMS_USED = RVMS_USED_
# end class IMAGEType45


class DEFAULT_USER_QUOTASType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None):
        self.original_tagname_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.VM_QUOTA = VM_QUOTA
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_USER_QUOTASType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_USER_QUOTASType.subclass:
            return DEFAULT_USER_QUOTASType.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_USER_QUOTASType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE_QUOTA(self): return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA): self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self): return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA): self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self): return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA): self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self): return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA): self.IMAGE_QUOTA = IMAGE_QUOTA
    def hasContent_(self):
        if (
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DEFAULT_USER_QUOTASType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_USER_QUOTASType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DEFAULT_USER_QUOTASType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DEFAULT_USER_QUOTASType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DEFAULT_USER_QUOTASType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DEFAULT_USER_QUOTASType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATASTORE_QUOTA is not None:
            self.DATASTORE_QUOTA.export(outfile, level, namespace_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            self.NETWORK_QUOTA.export(outfile, level, namespace_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            self.VM_QUOTA.export(outfile, level, namespace_, name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            self.IMAGE_QUOTA.export(outfile, level, namespace_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTAType46.factory()
            obj_.build(child_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTAType48.factory()
            obj_.build(child_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType50.factory()
            obj_.build(child_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTAType52.factory()
            obj_.build(child_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class DEFAULT_USER_QUOTASType


class DATASTORE_QUOTAType46(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTAType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTAType46.subclass:
            return DATASTORE_QUOTAType46.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTAType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType46', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTAType46')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_QUOTAType46')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_QUOTAType46', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_QUOTAType46'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType46', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType47.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTAType46


class DATASTOREType47(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.IMAGES = IMAGES
        self.IMAGES_USED = IMAGES_USED
        self.SIZE = SIZE
        self.SIZE_USED = SIZE_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType47.subclass:
            return DATASTOREType47.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType47(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_IMAGES_USED(self): return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED): self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_SIZE_USED(self): return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED): self.SIZE_USED = SIZE_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType47', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType47')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType47')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType47', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType47'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType47', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.IMAGES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES>%s</IMAGES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), eol_))
        if self.IMAGES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES_USED>%s</IMAGES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), eol_))
        if self.SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE_USED>%s</SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'IMAGES':
            IMAGES_ = child_.text
            IMAGES_ = self.gds_validate_string(IMAGES_, node, 'IMAGES')
            self.IMAGES = IMAGES_
        elif nodeName_ == 'IMAGES_USED':
            IMAGES_USED_ = child_.text
            IMAGES_USED_ = self.gds_validate_string(IMAGES_USED_, node, 'IMAGES_USED')
            self.IMAGES_USED = IMAGES_USED_
        elif nodeName_ == 'SIZE':
            SIZE_ = child_.text
            SIZE_ = self.gds_validate_string(SIZE_, node, 'SIZE')
            self.SIZE = SIZE_
        elif nodeName_ == 'SIZE_USED':
            SIZE_USED_ = child_.text
            SIZE_USED_ = self.gds_validate_string(SIZE_USED_, node, 'SIZE_USED')
            self.SIZE_USED = SIZE_USED_
# end class DATASTOREType47


class NETWORK_QUOTAType48(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None):
        self.original_tagname_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTAType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTAType48.subclass:
            return NETWORK_QUOTAType48.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTAType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NETWORK(self): return self.NETWORK
    def set_NETWORK(self, NETWORK): self.NETWORK = NETWORK
    def add_NETWORK(self, value): self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value): self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value): self.NETWORK[index] = value
    def hasContent_(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType48', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTAType48')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORK_QUOTAType48')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORK_QUOTAType48', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORK_QUOTAType48'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType48', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            NETWORK_.export(outfile, level, namespace_, name_='NETWORK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType49.factory()
            obj_.build(child_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTAType48


class NETWORKType49(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.LEASES = LEASES
        self.LEASES_USED = LEASES_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType49.subclass:
            return NETWORKType49.subclass(*args_, **kwargs_)
        else:
            return NETWORKType49(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def get_LEASES_USED(self): return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED): self.LEASES_USED = LEASES_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORKType49', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType49')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORKType49')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORKType49', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORKType49'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORKType49', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES>%s</LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), eol_))
        if self.LEASES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES_USED>%s</LEASES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LEASES':
            LEASES_ = child_.text
            LEASES_ = self.gds_validate_string(LEASES_, node, 'LEASES')
            self.LEASES = LEASES_
        elif nodeName_ == 'LEASES_USED':
            LEASES_USED_ = child_.text
            LEASES_USED_ = self.gds_validate_string(LEASES_USED_, node, 'LEASES_USED')
            self.LEASES_USED = LEASES_USED_
# end class NETWORKType49


class VM_QUOTAType50(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType50.subclass:
            return VM_QUOTAType50.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_QUOTAType50', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType50')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_QUOTAType50')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_QUOTAType50', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_QUOTAType50'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_QUOTAType50', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VMType51.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType50


class VMType51(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None):
        self.original_tagname_ = None
        self.CPU = CPU
        self.CPU_USED = CPU_USED
        self.MEMORY = MEMORY
        self.MEMORY_USED = MEMORY_USED
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.VMS = VMS
        self.VMS_USED = VMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType51.subclass:
            return VMType51.subclass(*args_, **kwargs_)
        else:
            return VMType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPU(self): return self.CPU
    def set_CPU(self, CPU): self.CPU = CPU
    def get_CPU_USED(self): return self.CPU_USED
    def set_CPU_USED(self, CPU_USED): self.CPU_USED = CPU_USED
    def get_MEMORY(self): return self.MEMORY
    def set_MEMORY(self, MEMORY): self.MEMORY = MEMORY
    def get_MEMORY_USED(self): return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED): self.MEMORY_USED = MEMORY_USED
    def get_SYSTEM_DISK_SIZE(self): return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE): self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self): return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED): self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_VMS_USED(self): return self.VMS_USED
    def set_VMS_USED(self, VMS_USED): self.VMS_USED = VMS_USED
    def hasContent_(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType51', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType51')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType51')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType51', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType51'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType51', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU>%s</CPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), eol_))
        if self.CPU_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USED>%s</CPU_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), eol_))
        if self.MEMORY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY>%s</MEMORY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), eol_))
        if self.MEMORY_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY_USED>%s</MEMORY_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE>%s</SYSTEM_DISK_SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE_USED>%s</SYSTEM_DISK_SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), eol_))
        if self.VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS>%s</VMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), eol_))
        if self.VMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS_USED>%s</VMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPU':
            CPU_ = child_.text
            CPU_ = self.gds_validate_string(CPU_, node, 'CPU')
            self.CPU = CPU_
        elif nodeName_ == 'CPU_USED':
            CPU_USED_ = child_.text
            CPU_USED_ = self.gds_validate_string(CPU_USED_, node, 'CPU_USED')
            self.CPU_USED = CPU_USED_
        elif nodeName_ == 'MEMORY':
            MEMORY_ = child_.text
            MEMORY_ = self.gds_validate_string(MEMORY_, node, 'MEMORY')
            self.MEMORY = MEMORY_
        elif nodeName_ == 'MEMORY_USED':
            MEMORY_USED_ = child_.text
            MEMORY_USED_ = self.gds_validate_string(MEMORY_USED_, node, 'MEMORY_USED')
            self.MEMORY_USED = MEMORY_USED_
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            SYSTEM_DISK_SIZE_ = child_.text
            SYSTEM_DISK_SIZE_ = self.gds_validate_string(SYSTEM_DISK_SIZE_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE_
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            SYSTEM_DISK_SIZE_USED_ = child_.text
            SYSTEM_DISK_SIZE_USED_ = self.gds_validate_string(SYSTEM_DISK_SIZE_USED_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED_
        elif nodeName_ == 'VMS':
            VMS_ = child_.text
            VMS_ = self.gds_validate_string(VMS_, node, 'VMS')
            self.VMS = VMS_
        elif nodeName_ == 'VMS_USED':
            VMS_USED_ = child_.text
            VMS_USED_ = self.gds_validate_string(VMS_USED_, node, 'VMS_USED')
            self.VMS_USED = VMS_USED_
# end class VMType51


class IMAGE_QUOTAType52(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTAType52)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTAType52.subclass:
            return IMAGE_QUOTAType52.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTAType52(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType52', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTAType52')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_QUOTAType52')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_QUOTAType52', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_QUOTAType52'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType52', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType53.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTAType52


class IMAGEType53(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.RVMS = RVMS
        self.RVMS_USED = RVMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType53)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType53.subclass:
            return IMAGEType53.subclass(*args_, **kwargs_)
        else:
            return IMAGEType53(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_RVMS(self): return self.RVMS
    def set_RVMS(self, RVMS): self.RVMS = RVMS
    def get_RVMS_USED(self): return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED): self.RVMS_USED = RVMS_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGEType53', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType53')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGEType53')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGEType53', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGEType53'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGEType53', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.RVMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS>%s</RVMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), eol_))
        if self.RVMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS_USED>%s</RVMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'RVMS':
            RVMS_ = child_.text
            RVMS_ = self.gds_validate_string(RVMS_, node, 'RVMS')
            self.RVMS = RVMS_
        elif nodeName_ == 'RVMS_USED':
            RVMS_USED_ = child_.text
            RVMS_USED_ = self.gds_validate_string(RVMS_USED_, node, 'RVMS_USED')
            self.RVMS_USED = RVMS_USED_
# end class IMAGEType53


class GROUPSType54(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUPSType54)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUPSType54.subclass:
            return GROUPSType54.subclass(*args_, **kwargs_)
        else:
            return GROUPSType54(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GROUPSType54', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUPSType54')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GROUPSType54')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GROUPSType54', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GROUPSType54'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GROUPSType54', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class GROUPSType54


class LOGIN_TOKENType55(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TOKEN=None, EXPIRATION_TIME=None, EGID=None):
        self.original_tagname_ = None
        self.TOKEN = TOKEN
        self.EXPIRATION_TIME = EXPIRATION_TIME
        self.EGID = EGID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOGIN_TOKENType55)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOGIN_TOKENType55.subclass:
            return LOGIN_TOKENType55.subclass(*args_, **kwargs_)
        else:
            return LOGIN_TOKENType55(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TOKEN(self): return self.TOKEN
    def set_TOKEN(self, TOKEN): self.TOKEN = TOKEN
    def get_EXPIRATION_TIME(self): return self.EXPIRATION_TIME
    def set_EXPIRATION_TIME(self, EXPIRATION_TIME): self.EXPIRATION_TIME = EXPIRATION_TIME
    def get_EGID(self): return self.EGID
    def set_EGID(self, EGID): self.EGID = EGID
    def hasContent_(self):
        if (
            self.TOKEN is not None or
            self.EXPIRATION_TIME is not None or
            self.EGID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LOGIN_TOKENType55', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOGIN_TOKENType55')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LOGIN_TOKENType55')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LOGIN_TOKENType55', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LOGIN_TOKENType55'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LOGIN_TOKENType55', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TOKEN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TOKEN>%s</TOKEN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TOKEN), input_name='TOKEN')), eol_))
        if self.EXPIRATION_TIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EXPIRATION_TIME>%s</EXPIRATION_TIME>%s' % (self.gds_format_integer(self.EXPIRATION_TIME, input_name='EXPIRATION_TIME'), eol_))
        if self.EGID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EGID>%s</EGID>%s' % (self.gds_format_integer(self.EGID, input_name='EGID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TOKEN':
            TOKEN_ = child_.text
            TOKEN_ = self.gds_validate_string(TOKEN_, node, 'TOKEN')
            self.TOKEN = TOKEN_
        elif nodeName_ == 'EXPIRATION_TIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EXPIRATION_TIME')
            self.EXPIRATION_TIME = ival_
        elif nodeName_ == 'EGID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EGID')
            self.EGID = ival_
# end class LOGIN_TOKENType55


class DATASTORE_QUOTAType56(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTAType56)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTAType56.subclass:
            return DATASTORE_QUOTAType56.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTAType56(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType56', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTAType56')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_QUOTAType56')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_QUOTAType56', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_QUOTAType56'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType56', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType57.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTAType56


class DATASTOREType57(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.IMAGES = IMAGES
        self.IMAGES_USED = IMAGES_USED
        self.SIZE = SIZE
        self.SIZE_USED = SIZE_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType57)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType57.subclass:
            return DATASTOREType57.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType57(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_IMAGES_USED(self): return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED): self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_SIZE_USED(self): return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED): self.SIZE_USED = SIZE_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType57', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType57')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType57')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType57', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType57'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType57', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.IMAGES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES>%s</IMAGES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), eol_))
        if self.IMAGES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES_USED>%s</IMAGES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), eol_))
        if self.SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE_USED>%s</SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'IMAGES':
            IMAGES_ = child_.text
            IMAGES_ = self.gds_validate_string(IMAGES_, node, 'IMAGES')
            self.IMAGES = IMAGES_
        elif nodeName_ == 'IMAGES_USED':
            IMAGES_USED_ = child_.text
            IMAGES_USED_ = self.gds_validate_string(IMAGES_USED_, node, 'IMAGES_USED')
            self.IMAGES_USED = IMAGES_USED_
        elif nodeName_ == 'SIZE':
            SIZE_ = child_.text
            SIZE_ = self.gds_validate_string(SIZE_, node, 'SIZE')
            self.SIZE = SIZE_
        elif nodeName_ == 'SIZE_USED':
            SIZE_USED_ = child_.text
            SIZE_USED_ = self.gds_validate_string(SIZE_USED_, node, 'SIZE_USED')
            self.SIZE_USED = SIZE_USED_
# end class DATASTOREType57


class NETWORK_QUOTAType58(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None):
        self.original_tagname_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTAType58)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTAType58.subclass:
            return NETWORK_QUOTAType58.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTAType58(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NETWORK(self): return self.NETWORK
    def set_NETWORK(self, NETWORK): self.NETWORK = NETWORK
    def add_NETWORK(self, value): self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value): self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value): self.NETWORK[index] = value
    def hasContent_(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType58', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTAType58')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORK_QUOTAType58')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORK_QUOTAType58', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORK_QUOTAType58'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType58', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            NETWORK_.export(outfile, level, namespace_, name_='NETWORK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType59.factory()
            obj_.build(child_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTAType58


class NETWORKType59(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.LEASES = LEASES
        self.LEASES_USED = LEASES_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType59)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType59.subclass:
            return NETWORKType59.subclass(*args_, **kwargs_)
        else:
            return NETWORKType59(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def get_LEASES_USED(self): return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED): self.LEASES_USED = LEASES_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORKType59', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType59')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORKType59')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORKType59', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORKType59'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORKType59', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES>%s</LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), eol_))
        if self.LEASES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES_USED>%s</LEASES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LEASES':
            LEASES_ = child_.text
            LEASES_ = self.gds_validate_string(LEASES_, node, 'LEASES')
            self.LEASES = LEASES_
        elif nodeName_ == 'LEASES_USED':
            LEASES_USED_ = child_.text
            LEASES_USED_ = self.gds_validate_string(LEASES_USED_, node, 'LEASES_USED')
            self.LEASES_USED = LEASES_USED_
# end class NETWORKType59


class VM_QUOTAType60(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType60)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType60.subclass:
            return VM_QUOTAType60.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType60(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_QUOTAType60', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType60')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_QUOTAType60')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_QUOTAType60', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_QUOTAType60'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_QUOTAType60', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VMType61.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType60


class VMType61(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None):
        self.original_tagname_ = None
        self.CPU = CPU
        self.CPU_USED = CPU_USED
        self.MEMORY = MEMORY
        self.MEMORY_USED = MEMORY_USED
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.VMS = VMS
        self.VMS_USED = VMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType61)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType61.subclass:
            return VMType61.subclass(*args_, **kwargs_)
        else:
            return VMType61(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPU(self): return self.CPU
    def set_CPU(self, CPU): self.CPU = CPU
    def get_CPU_USED(self): return self.CPU_USED
    def set_CPU_USED(self, CPU_USED): self.CPU_USED = CPU_USED
    def get_MEMORY(self): return self.MEMORY
    def set_MEMORY(self, MEMORY): self.MEMORY = MEMORY
    def get_MEMORY_USED(self): return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED): self.MEMORY_USED = MEMORY_USED
    def get_SYSTEM_DISK_SIZE(self): return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE): self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self): return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED): self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_VMS_USED(self): return self.VMS_USED
    def set_VMS_USED(self, VMS_USED): self.VMS_USED = VMS_USED
    def hasContent_(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType61', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType61')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType61')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType61', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType61'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType61', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU>%s</CPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), eol_))
        if self.CPU_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USED>%s</CPU_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), eol_))
        if self.MEMORY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY>%s</MEMORY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), eol_))
        if self.MEMORY_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY_USED>%s</MEMORY_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE>%s</SYSTEM_DISK_SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE_USED>%s</SYSTEM_DISK_SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), eol_))
        if self.VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS>%s</VMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), eol_))
        if self.VMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS_USED>%s</VMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPU':
            CPU_ = child_.text
            CPU_ = self.gds_validate_string(CPU_, node, 'CPU')
            self.CPU = CPU_
        elif nodeName_ == 'CPU_USED':
            CPU_USED_ = child_.text
            CPU_USED_ = self.gds_validate_string(CPU_USED_, node, 'CPU_USED')
            self.CPU_USED = CPU_USED_
        elif nodeName_ == 'MEMORY':
            MEMORY_ = child_.text
            MEMORY_ = self.gds_validate_string(MEMORY_, node, 'MEMORY')
            self.MEMORY = MEMORY_
        elif nodeName_ == 'MEMORY_USED':
            MEMORY_USED_ = child_.text
            MEMORY_USED_ = self.gds_validate_string(MEMORY_USED_, node, 'MEMORY_USED')
            self.MEMORY_USED = MEMORY_USED_
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            SYSTEM_DISK_SIZE_ = child_.text
            SYSTEM_DISK_SIZE_ = self.gds_validate_string(SYSTEM_DISK_SIZE_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE_
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            SYSTEM_DISK_SIZE_USED_ = child_.text
            SYSTEM_DISK_SIZE_USED_ = self.gds_validate_string(SYSTEM_DISK_SIZE_USED_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED_
        elif nodeName_ == 'VMS':
            VMS_ = child_.text
            VMS_ = self.gds_validate_string(VMS_, node, 'VMS')
            self.VMS = VMS_
        elif nodeName_ == 'VMS_USED':
            VMS_USED_ = child_.text
            VMS_USED_ = self.gds_validate_string(VMS_USED_, node, 'VMS_USED')
            self.VMS_USED = VMS_USED_
# end class VMType61


class IMAGE_QUOTAType62(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTAType62)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTAType62.subclass:
            return IMAGE_QUOTAType62.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTAType62(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType62', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTAType62')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_QUOTAType62')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_QUOTAType62', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_QUOTAType62'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType62', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType63.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTAType62


class IMAGEType63(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.RVMS = RVMS
        self.RVMS_USED = RVMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType63)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType63.subclass:
            return IMAGEType63.subclass(*args_, **kwargs_)
        else:
            return IMAGEType63(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_RVMS(self): return self.RVMS
    def set_RVMS(self, RVMS): self.RVMS = RVMS
    def get_RVMS_USED(self): return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED): self.RVMS_USED = RVMS_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGEType63', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType63')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGEType63')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGEType63', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGEType63'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGEType63', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.RVMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS>%s</RVMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), eol_))
        if self.RVMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS_USED>%s</RVMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'RVMS':
            RVMS_ = child_.text
            RVMS_ = self.gds_validate_string(RVMS_, node, 'RVMS')
            self.RVMS = RVMS_
        elif nodeName_ == 'RVMS_USED':
            RVMS_USED_ = child_.text
            RVMS_USED_ = self.gds_validate_string(RVMS_USED_, node, 'RVMS_USED')
            self.RVMS_USED = RVMS_USED_
# end class IMAGEType63


class DEFAULT_USER_QUOTASType64(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE_QUOTA=None, NETWORK_QUOTA=None, VM_QUOTA=None, IMAGE_QUOTA=None):
        self.original_tagname_ = None
        self.DATASTORE_QUOTA = DATASTORE_QUOTA
        self.NETWORK_QUOTA = NETWORK_QUOTA
        self.VM_QUOTA = VM_QUOTA
        self.IMAGE_QUOTA = IMAGE_QUOTA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DEFAULT_USER_QUOTASType64)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DEFAULT_USER_QUOTASType64.subclass:
            return DEFAULT_USER_QUOTASType64.subclass(*args_, **kwargs_)
        else:
            return DEFAULT_USER_QUOTASType64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE_QUOTA(self): return self.DATASTORE_QUOTA
    def set_DATASTORE_QUOTA(self, DATASTORE_QUOTA): self.DATASTORE_QUOTA = DATASTORE_QUOTA
    def get_NETWORK_QUOTA(self): return self.NETWORK_QUOTA
    def set_NETWORK_QUOTA(self, NETWORK_QUOTA): self.NETWORK_QUOTA = NETWORK_QUOTA
    def get_VM_QUOTA(self): return self.VM_QUOTA
    def set_VM_QUOTA(self, VM_QUOTA): self.VM_QUOTA = VM_QUOTA
    def get_IMAGE_QUOTA(self): return self.IMAGE_QUOTA
    def set_IMAGE_QUOTA(self, IMAGE_QUOTA): self.IMAGE_QUOTA = IMAGE_QUOTA
    def hasContent_(self):
        if (
            self.DATASTORE_QUOTA is not None or
            self.NETWORK_QUOTA is not None or
            self.VM_QUOTA is not None or
            self.IMAGE_QUOTA is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DEFAULT_USER_QUOTASType64', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DEFAULT_USER_QUOTASType64')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DEFAULT_USER_QUOTASType64')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DEFAULT_USER_QUOTASType64', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DEFAULT_USER_QUOTASType64'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DEFAULT_USER_QUOTASType64', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATASTORE_QUOTA is not None:
            self.DATASTORE_QUOTA.export(outfile, level, namespace_, name_='DATASTORE_QUOTA', pretty_print=pretty_print)
        if self.NETWORK_QUOTA is not None:
            self.NETWORK_QUOTA.export(outfile, level, namespace_, name_='NETWORK_QUOTA', pretty_print=pretty_print)
        if self.VM_QUOTA is not None:
            self.VM_QUOTA.export(outfile, level, namespace_, name_='VM_QUOTA', pretty_print=pretty_print)
        if self.IMAGE_QUOTA is not None:
            self.IMAGE_QUOTA.export(outfile, level, namespace_, name_='IMAGE_QUOTA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE_QUOTA':
            obj_ = DATASTORE_QUOTAType65.factory()
            obj_.build(child_)
            self.DATASTORE_QUOTA = obj_
            obj_.original_tagname_ = 'DATASTORE_QUOTA'
        elif nodeName_ == 'NETWORK_QUOTA':
            obj_ = NETWORK_QUOTAType67.factory()
            obj_.build(child_)
            self.NETWORK_QUOTA = obj_
            obj_.original_tagname_ = 'NETWORK_QUOTA'
        elif nodeName_ == 'VM_QUOTA':
            obj_ = VM_QUOTAType69.factory()
            obj_.build(child_)
            self.VM_QUOTA = obj_
            obj_.original_tagname_ = 'VM_QUOTA'
        elif nodeName_ == 'IMAGE_QUOTA':
            obj_ = IMAGE_QUOTAType71.factory()
            obj_.build(child_)
            self.IMAGE_QUOTA = obj_
            obj_.original_tagname_ = 'IMAGE_QUOTA'
# end class DEFAULT_USER_QUOTASType64


class DATASTORE_QUOTAType65(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORE_QUOTAType65)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORE_QUOTAType65.subclass:
            return DATASTORE_QUOTAType65.subclass(*args_, **kwargs_)
        else:
            return DATASTORE_QUOTAType65(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType65', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORE_QUOTAType65')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORE_QUOTAType65')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORE_QUOTAType65', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORE_QUOTAType65'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORE_QUOTAType65', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType66.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORE_QUOTAType65


class DATASTOREType66(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IMAGES=None, IMAGES_USED=None, SIZE=None, SIZE_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.IMAGES = IMAGES
        self.IMAGES_USED = IMAGES_USED
        self.SIZE = SIZE
        self.SIZE_USED = SIZE_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType66)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType66.subclass:
            return DATASTOREType66.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType66(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IMAGES(self): return self.IMAGES
    def set_IMAGES(self, IMAGES): self.IMAGES = IMAGES
    def get_IMAGES_USED(self): return self.IMAGES_USED
    def set_IMAGES_USED(self, IMAGES_USED): self.IMAGES_USED = IMAGES_USED
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_SIZE_USED(self): return self.SIZE_USED
    def set_SIZE_USED(self, SIZE_USED): self.SIZE_USED = SIZE_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.IMAGES is not None or
            self.IMAGES_USED is not None or
            self.SIZE is not None or
            self.SIZE_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType66', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType66')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType66')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType66', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType66'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType66', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.IMAGES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES>%s</IMAGES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES), input_name='IMAGES')), eol_))
        if self.IMAGES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IMAGES_USED>%s</IMAGES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IMAGES_USED), input_name='IMAGES_USED')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE), input_name='SIZE')), eol_))
        if self.SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE_USED>%s</SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SIZE_USED), input_name='SIZE_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'IMAGES':
            IMAGES_ = child_.text
            IMAGES_ = self.gds_validate_string(IMAGES_, node, 'IMAGES')
            self.IMAGES = IMAGES_
        elif nodeName_ == 'IMAGES_USED':
            IMAGES_USED_ = child_.text
            IMAGES_USED_ = self.gds_validate_string(IMAGES_USED_, node, 'IMAGES_USED')
            self.IMAGES_USED = IMAGES_USED_
        elif nodeName_ == 'SIZE':
            SIZE_ = child_.text
            SIZE_ = self.gds_validate_string(SIZE_, node, 'SIZE')
            self.SIZE = SIZE_
        elif nodeName_ == 'SIZE_USED':
            SIZE_USED_ = child_.text
            SIZE_USED_ = self.gds_validate_string(SIZE_USED_, node, 'SIZE_USED')
            self.SIZE_USED = SIZE_USED_
# end class DATASTOREType66


class NETWORK_QUOTAType67(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NETWORK=None):
        self.original_tagname_ = None
        if NETWORK is None:
            self.NETWORK = []
        else:
            self.NETWORK = NETWORK
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORK_QUOTAType67)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORK_QUOTAType67.subclass:
            return NETWORK_QUOTAType67.subclass(*args_, **kwargs_)
        else:
            return NETWORK_QUOTAType67(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NETWORK(self): return self.NETWORK
    def set_NETWORK(self, NETWORK): self.NETWORK = NETWORK
    def add_NETWORK(self, value): self.NETWORK.append(value)
    def insert_NETWORK_at(self, index, value): self.NETWORK.insert(index, value)
    def replace_NETWORK_at(self, index, value): self.NETWORK[index] = value
    def hasContent_(self):
        if (
            self.NETWORK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType67', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORK_QUOTAType67')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORK_QUOTAType67')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORK_QUOTAType67', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORK_QUOTAType67'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORK_QUOTAType67', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NETWORK_ in self.NETWORK:
            NETWORK_.export(outfile, level, namespace_, name_='NETWORK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NETWORK':
            obj_ = NETWORKType68.factory()
            obj_.build(child_)
            self.NETWORK.append(obj_)
            obj_.original_tagname_ = 'NETWORK'
# end class NETWORK_QUOTAType67


class NETWORKType68(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LEASES=None, LEASES_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.LEASES = LEASES
        self.LEASES_USED = LEASES_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NETWORKType68)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NETWORKType68.subclass:
            return NETWORKType68.subclass(*args_, **kwargs_)
        else:
            return NETWORKType68(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def get_LEASES_USED(self): return self.LEASES_USED
    def set_LEASES_USED(self, LEASES_USED): self.LEASES_USED = LEASES_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.LEASES is not None or
            self.LEASES_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NETWORKType68', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NETWORKType68')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NETWORKType68')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NETWORKType68', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NETWORKType68'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NETWORKType68', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES>%s</LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES), input_name='LEASES')), eol_))
        if self.LEASES_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LEASES_USED>%s</LEASES_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LEASES_USED), input_name='LEASES_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LEASES':
            LEASES_ = child_.text
            LEASES_ = self.gds_validate_string(LEASES_, node, 'LEASES')
            self.LEASES = LEASES_
        elif nodeName_ == 'LEASES_USED':
            LEASES_USED_ = child_.text
            LEASES_USED_ = self.gds_validate_string(LEASES_USED_, node, 'LEASES_USED')
            self.LEASES_USED = LEASES_USED_
# end class NETWORKType68


class VM_QUOTAType69(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VM=None):
        self.original_tagname_ = None
        self.VM = VM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM_QUOTAType69)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM_QUOTAType69.subclass:
            return VM_QUOTAType69.subclass(*args_, **kwargs_)
        else:
            return VM_QUOTAType69(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def hasContent_(self):
        if (
            self.VM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VM_QUOTAType69', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VM_QUOTAType69')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VM_QUOTAType69')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VM_QUOTAType69', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VM_QUOTAType69'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VM_QUOTAType69', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VM is not None:
            self.VM.export(outfile, level, namespace_, name_='VM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VM':
            obj_ = VMType70.factory()
            obj_.build(child_)
            self.VM = obj_
            obj_.original_tagname_ = 'VM'
# end class VM_QUOTAType69


class VMType70(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPU=None, CPU_USED=None, MEMORY=None, MEMORY_USED=None, SYSTEM_DISK_SIZE=None, SYSTEM_DISK_SIZE_USED=None, VMS=None, VMS_USED=None):
        self.original_tagname_ = None
        self.CPU = CPU
        self.CPU_USED = CPU_USED
        self.MEMORY = MEMORY
        self.MEMORY_USED = MEMORY_USED
        self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
        self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
        self.VMS = VMS
        self.VMS_USED = VMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMType70)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMType70.subclass:
            return VMType70.subclass(*args_, **kwargs_)
        else:
            return VMType70(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPU(self): return self.CPU
    def set_CPU(self, CPU): self.CPU = CPU
    def get_CPU_USED(self): return self.CPU_USED
    def set_CPU_USED(self, CPU_USED): self.CPU_USED = CPU_USED
    def get_MEMORY(self): return self.MEMORY
    def set_MEMORY(self, MEMORY): self.MEMORY = MEMORY
    def get_MEMORY_USED(self): return self.MEMORY_USED
    def set_MEMORY_USED(self, MEMORY_USED): self.MEMORY_USED = MEMORY_USED
    def get_SYSTEM_DISK_SIZE(self): return self.SYSTEM_DISK_SIZE
    def set_SYSTEM_DISK_SIZE(self, SYSTEM_DISK_SIZE): self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE
    def get_SYSTEM_DISK_SIZE_USED(self): return self.SYSTEM_DISK_SIZE_USED
    def set_SYSTEM_DISK_SIZE_USED(self, SYSTEM_DISK_SIZE_USED): self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED
    def get_VMS(self): return self.VMS
    def set_VMS(self, VMS): self.VMS = VMS
    def get_VMS_USED(self): return self.VMS_USED
    def set_VMS_USED(self, VMS_USED): self.VMS_USED = VMS_USED
    def hasContent_(self):
        if (
            self.CPU is not None or
            self.CPU_USED is not None or
            self.MEMORY is not None or
            self.MEMORY_USED is not None or
            self.SYSTEM_DISK_SIZE is not None or
            self.SYSTEM_DISK_SIZE_USED is not None or
            self.VMS is not None or
            self.VMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMType70', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMType70')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMType70')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMType70', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMType70'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMType70', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU>%s</CPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU), input_name='CPU')), eol_))
        if self.CPU_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPU_USED>%s</CPU_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPU_USED), input_name='CPU_USED')), eol_))
        if self.MEMORY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY>%s</MEMORY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY), input_name='MEMORY')), eol_))
        if self.MEMORY_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MEMORY_USED>%s</MEMORY_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MEMORY_USED), input_name='MEMORY_USED')), eol_))
        if self.SYSTEM_DISK_SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE>%s</SYSTEM_DISK_SIZE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE), input_name='SYSTEM_DISK_SIZE')), eol_))
        if self.SYSTEM_DISK_SIZE_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SYSTEM_DISK_SIZE_USED>%s</SYSTEM_DISK_SIZE_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SYSTEM_DISK_SIZE_USED), input_name='SYSTEM_DISK_SIZE_USED')), eol_))
        if self.VMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS>%s</VMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS), input_name='VMS')), eol_))
        if self.VMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VMS_USED>%s</VMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VMS_USED), input_name='VMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPU':
            CPU_ = child_.text
            CPU_ = self.gds_validate_string(CPU_, node, 'CPU')
            self.CPU = CPU_
        elif nodeName_ == 'CPU_USED':
            CPU_USED_ = child_.text
            CPU_USED_ = self.gds_validate_string(CPU_USED_, node, 'CPU_USED')
            self.CPU_USED = CPU_USED_
        elif nodeName_ == 'MEMORY':
            MEMORY_ = child_.text
            MEMORY_ = self.gds_validate_string(MEMORY_, node, 'MEMORY')
            self.MEMORY = MEMORY_
        elif nodeName_ == 'MEMORY_USED':
            MEMORY_USED_ = child_.text
            MEMORY_USED_ = self.gds_validate_string(MEMORY_USED_, node, 'MEMORY_USED')
            self.MEMORY_USED = MEMORY_USED_
        elif nodeName_ == 'SYSTEM_DISK_SIZE':
            SYSTEM_DISK_SIZE_ = child_.text
            SYSTEM_DISK_SIZE_ = self.gds_validate_string(SYSTEM_DISK_SIZE_, node, 'SYSTEM_DISK_SIZE')
            self.SYSTEM_DISK_SIZE = SYSTEM_DISK_SIZE_
        elif nodeName_ == 'SYSTEM_DISK_SIZE_USED':
            SYSTEM_DISK_SIZE_USED_ = child_.text
            SYSTEM_DISK_SIZE_USED_ = self.gds_validate_string(SYSTEM_DISK_SIZE_USED_, node, 'SYSTEM_DISK_SIZE_USED')
            self.SYSTEM_DISK_SIZE_USED = SYSTEM_DISK_SIZE_USED_
        elif nodeName_ == 'VMS':
            VMS_ = child_.text
            VMS_ = self.gds_validate_string(VMS_, node, 'VMS')
            self.VMS = VMS_
        elif nodeName_ == 'VMS_USED':
            VMS_USED_ = child_.text
            VMS_USED_ = self.gds_validate_string(VMS_USED_, node, 'VMS_USED')
            self.VMS_USED = VMS_USED_
# end class VMType70


class IMAGE_QUOTAType71(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None):
        self.original_tagname_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_QUOTAType71)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_QUOTAType71.subclass:
            return IMAGE_QUOTAType71.subclass(*args_, **kwargs_)
        else:
            return IMAGE_QUOTAType71(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IMAGE(self): return self.IMAGE
    def set_IMAGE(self, IMAGE): self.IMAGE = IMAGE
    def add_IMAGE(self, value): self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value): self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value): self.IMAGE[index] = value
    def hasContent_(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType71', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_QUOTAType71')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGE_QUOTAType71')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGE_QUOTAType71', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGE_QUOTAType71'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGE_QUOTAType71', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            IMAGE_.export(outfile, level, namespace_, name_='IMAGE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IMAGE':
            obj_ = IMAGEType72.factory()
            obj_.build(child_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class IMAGE_QUOTAType71


class IMAGEType72(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, RVMS=None, RVMS_USED=None):
        self.original_tagname_ = None
        self.ID = ID
        self.RVMS = RVMS
        self.RVMS_USED = RVMS_USED
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGEType72)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGEType72.subclass:
            return IMAGEType72.subclass(*args_, **kwargs_)
        else:
            return IMAGEType72(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_RVMS(self): return self.RVMS
    def set_RVMS(self, RVMS): self.RVMS = RVMS
    def get_RVMS_USED(self): return self.RVMS_USED
    def set_RVMS_USED(self, RVMS_USED): self.RVMS_USED = RVMS_USED
    def hasContent_(self):
        if (
            self.ID is not None or
            self.RVMS is not None or
            self.RVMS_USED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IMAGEType72', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGEType72')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMAGEType72')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IMAGEType72', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IMAGEType72'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IMAGEType72', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), eol_))
        if self.RVMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS>%s</RVMS>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS), input_name='RVMS')), eol_))
        if self.RVMS_USED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RVMS_USED>%s</RVMS_USED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RVMS_USED), input_name='RVMS_USED')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'RVMS':
            RVMS_ = child_.text
            RVMS_ = self.gds_validate_string(RVMS_, node, 'RVMS')
            self.RVMS = RVMS_
        elif nodeName_ == 'RVMS_USED':
            RVMS_USED_ = child_.text
            RVMS_USED_ = self.gds_validate_string(RVMS_USED_, node, 'RVMS_USED')
            self.RVMS_USED = RVMS_USED_
# end class IMAGEType72


class GROUPSType73(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROUPSType73)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROUPSType73.subclass:
            return GROUPSType73.subclass(*args_, **kwargs_)
        else:
            return GROUPSType73(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GROUPSType73', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROUPSType73')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GROUPSType73')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GROUPSType73', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GROUPSType73'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GROUPSType73', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class GROUPSType73


class CLUSTERSType74(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CLUSTER=None):
        self.original_tagname_ = None
        if CLUSTER is None:
            self.CLUSTER = []
        else:
            self.CLUSTER = CLUSTER
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERSType74)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERSType74.subclass:
            return CLUSTERSType74.subclass(*args_, **kwargs_)
        else:
            return CLUSTERSType74(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CLUSTER(self): return self.CLUSTER
    def set_CLUSTER(self, CLUSTER): self.CLUSTER = CLUSTER
    def add_CLUSTER(self, value): self.CLUSTER.append(value)
    def insert_CLUSTER_at(self, index, value): self.CLUSTER.insert(index, value)
    def replace_CLUSTER_at(self, index, value): self.CLUSTER[index] = value
    def hasContent_(self):
        if (
            self.CLUSTER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CLUSTERSType74', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERSType74')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLUSTERSType74')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CLUSTERSType74', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLUSTERSType74'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLUSTERSType74', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CLUSTER_ in self.CLUSTER:
            CLUSTER_.export(outfile, level, namespace_, name_='CLUSTER', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CLUSTER':
            obj_ = CLUSTERType.factory()
            obj_.build(child_)
            self.CLUSTER.append(obj_)
            obj_.original_tagname_ = 'CLUSTER'
# end class CLUSTERSType74


class CLUSTERType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZONE_ID=None, CLUSTER_ID=None):
        self.original_tagname_ = None
        self.ZONE_ID = ZONE_ID
        self.CLUSTER_ID = CLUSTER_ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERType.subclass:
            return CLUSTERType.subclass(*args_, **kwargs_)
        else:
            return CLUSTERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZONE_ID(self): return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID): self.ZONE_ID = ZONE_ID
    def get_CLUSTER_ID(self): return self.CLUSTER_ID
    def set_CLUSTER_ID(self, CLUSTER_ID): self.CLUSTER_ID = CLUSTER_ID
    def hasContent_(self):
        if (
            self.ZONE_ID is not None or
            self.CLUSTER_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CLUSTERType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLUSTERType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CLUSTERType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLUSTERType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLUSTERType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZONE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ZONE_ID>%s</ZONE_ID>%s' % (self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), eol_))
        if self.CLUSTER_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CLUSTER_ID>%s</CLUSTER_ID>%s' % (self.gds_format_integer(self.CLUSTER_ID, input_name='CLUSTER_ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZONE_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
        elif nodeName_ == 'CLUSTER_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CLUSTER_ID')
            self.CLUSTER_ID = ival_
# end class CLUSTERType


class HOSTSType75(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HOST=None):
        self.original_tagname_ = None
        if HOST is None:
            self.HOST = []
        else:
            self.HOST = HOST
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOSTSType75)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOSTSType75.subclass:
            return HOSTSType75.subclass(*args_, **kwargs_)
        else:
            return HOSTSType75(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HOST(self): return self.HOST
    def set_HOST(self, HOST): self.HOST = HOST
    def add_HOST(self, value): self.HOST.append(value)
    def insert_HOST_at(self, index, value): self.HOST.insert(index, value)
    def replace_HOST_at(self, index, value): self.HOST[index] = value
    def hasContent_(self):
        if (
            self.HOST
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HOSTSType75', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOSTSType75')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HOSTSType75')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HOSTSType75', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HOSTSType75'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HOSTSType75', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HOST_ in self.HOST:
            HOST_.export(outfile, level, namespace_, name_='HOST', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HOST':
            obj_ = HOSTType.factory()
            obj_.build(child_)
            self.HOST.append(obj_)
            obj_.original_tagname_ = 'HOST'
# end class HOSTSType75


class HOSTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZONE_ID=None, HOST_ID=None):
        self.original_tagname_ = None
        self.ZONE_ID = ZONE_ID
        self.HOST_ID = HOST_ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOSTType.subclass:
            return HOSTType.subclass(*args_, **kwargs_)
        else:
            return HOSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZONE_ID(self): return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID): self.ZONE_ID = ZONE_ID
    def get_HOST_ID(self): return self.HOST_ID
    def set_HOST_ID(self, HOST_ID): self.HOST_ID = HOST_ID
    def hasContent_(self):
        if (
            self.ZONE_ID is not None or
            self.HOST_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HOSTType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HOSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HOSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HOSTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HOSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZONE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ZONE_ID>%s</ZONE_ID>%s' % (self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), eol_))
        if self.HOST_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<HOST_ID>%s</HOST_ID>%s' % (self.gds_format_integer(self.HOST_ID, input_name='HOST_ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZONE_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
        elif nodeName_ == 'HOST_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'HOST_ID')
            self.HOST_ID = ival_
# end class HOSTType


class DATASTORESType76(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATASTORE=None):
        self.original_tagname_ = None
        if DATASTORE is None:
            self.DATASTORE = []
        else:
            self.DATASTORE = DATASTORE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTORESType76)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTORESType76.subclass:
            return DATASTORESType76.subclass(*args_, **kwargs_)
        else:
            return DATASTORESType76(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATASTORE(self): return self.DATASTORE
    def set_DATASTORE(self, DATASTORE): self.DATASTORE = DATASTORE
    def add_DATASTORE(self, value): self.DATASTORE.append(value)
    def insert_DATASTORE_at(self, index, value): self.DATASTORE.insert(index, value)
    def replace_DATASTORE_at(self, index, value): self.DATASTORE[index] = value
    def hasContent_(self):
        if (
            self.DATASTORE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTORESType76', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTORESType76')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTORESType76')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTORESType76', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTORESType76'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTORESType76', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASTORE_ in self.DATASTORE:
            DATASTORE_.export(outfile, level, namespace_, name_='DATASTORE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATASTORE':
            obj_ = DATASTOREType77.factory()
            obj_.build(child_)
            self.DATASTORE.append(obj_)
            obj_.original_tagname_ = 'DATASTORE'
# end class DATASTORESType76


class DATASTOREType77(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZONE_ID=None, DATASTORE_ID=None):
        self.original_tagname_ = None
        self.ZONE_ID = ZONE_ID
        self.DATASTORE_ID = DATASTORE_ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASTOREType77)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASTOREType77.subclass:
            return DATASTOREType77.subclass(*args_, **kwargs_)
        else:
            return DATASTOREType77(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZONE_ID(self): return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID): self.ZONE_ID = ZONE_ID
    def get_DATASTORE_ID(self): return self.DATASTORE_ID
    def set_DATASTORE_ID(self, DATASTORE_ID): self.DATASTORE_ID = DATASTORE_ID
    def hasContent_(self):
        if (
            self.ZONE_ID is not None or
            self.DATASTORE_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATASTOREType77', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASTOREType77')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATASTOREType77')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATASTOREType77', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATASTOREType77'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DATASTOREType77', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZONE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ZONE_ID>%s</ZONE_ID>%s' % (self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), eol_))
        if self.DATASTORE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATASTORE_ID>%s</DATASTORE_ID>%s' % (self.gds_format_integer(self.DATASTORE_ID, input_name='DATASTORE_ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZONE_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
        elif nodeName_ == 'DATASTORE_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DATASTORE_ID')
            self.DATASTORE_ID = ival_
# end class DATASTOREType77


class VNETSType78(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VNET=None):
        self.original_tagname_ = None
        if VNET is None:
            self.VNET = []
        else:
            self.VNET = VNET
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNETSType78)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNETSType78.subclass:
            return VNETSType78.subclass(*args_, **kwargs_)
        else:
            return VNETSType78(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VNET(self): return self.VNET
    def set_VNET(self, VNET): self.VNET = VNET
    def add_VNET(self, value): self.VNET.append(value)
    def insert_VNET_at(self, index, value): self.VNET.insert(index, value)
    def replace_VNET_at(self, index, value): self.VNET[index] = value
    def hasContent_(self):
        if (
            self.VNET
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VNETSType78', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNETSType78')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VNETSType78')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VNETSType78', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VNETSType78'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VNETSType78', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VNET_ in self.VNET:
            VNET_.export(outfile, level, namespace_, name_='VNET', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VNET':
            obj_ = VNETType.factory()
            obj_.build(child_)
            self.VNET.append(obj_)
            obj_.original_tagname_ = 'VNET'
# end class VNETSType78


class VNETType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZONE_ID=None, VNET_ID=None):
        self.original_tagname_ = None
        self.ZONE_ID = ZONE_ID
        self.VNET_ID = VNET_ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNETType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNETType.subclass:
            return VNETType.subclass(*args_, **kwargs_)
        else:
            return VNETType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZONE_ID(self): return self.ZONE_ID
    def set_ZONE_ID(self, ZONE_ID): self.ZONE_ID = ZONE_ID
    def get_VNET_ID(self): return self.VNET_ID
    def set_VNET_ID(self, VNET_ID): self.VNET_ID = VNET_ID
    def hasContent_(self):
        if (
            self.ZONE_ID is not None or
            self.VNET_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VNETType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNETType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VNETType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VNETType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VNETType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VNETType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZONE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ZONE_ID>%s</ZONE_ID>%s' % (self.gds_format_integer(self.ZONE_ID, input_name='ZONE_ID'), eol_))
        if self.VNET_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VNET_ID>%s</VNET_ID>%s' % (self.gds_format_integer(self.VNET_ID, input_name='VNET_ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZONE_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZONE_ID')
            self.ZONE_ID = ival_
        elif nodeName_ == 'VNET_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VNET_ID')
            self.VNET_ID = ival_
# end class VNETType


class PERMISSIONSType79(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType79)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType79.subclass:
            return PERMISSIONSType79.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType79(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType79', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType79')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType79')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType79', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType79'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType79', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType79


class HISTORY_RECORDSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HISTORY=None):
        self.original_tagname_ = None
        if HISTORY is None:
            self.HISTORY = []
        else:
            self.HISTORY = HISTORY
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORY_RECORDSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORY_RECORDSType.subclass:
            return HISTORY_RECORDSType.subclass(*args_, **kwargs_)
        else:
            return HISTORY_RECORDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HISTORY(self): return self.HISTORY
    def set_HISTORY(self, HISTORY): self.HISTORY = HISTORY
    def add_HISTORY(self, value): self.HISTORY.append(value)
    def insert_HISTORY_at(self, index, value): self.HISTORY.insert(index, value)
    def replace_HISTORY_at(self, index, value): self.HISTORY[index] = value
    def hasContent_(self):
        if (
            self.HISTORY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HISTORY_RECORDSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORY_RECORDSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HISTORY_RECORDSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HISTORY_RECORDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HISTORY_RECORDSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HISTORY_RECORDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HISTORY_ in self.HISTORY:
            HISTORY_.export(outfile, level, namespace_, name_='HISTORY', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HISTORY':
            obj_ = HISTORYType.factory()
            obj_.build(child_)
            self.HISTORY.append(obj_)
            obj_.original_tagname_ = 'HISTORY'
# end class HISTORY_RECORDSType


class HISTORYType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OID=None, SEQ=None, HOSTNAME=None, HID=None, CID=None, STIME=None, ETIME=None, VM_MAD=None, TM_MAD=None, DS_ID=None, PSTIME=None, PETIME=None, RSTIME=None, RETIME=None, ESTIME=None, EETIME=None, ACTION=None, UID=None, GID=None, REQUEST_ID=None):
        self.original_tagname_ = None
        self.OID = OID
        self.SEQ = SEQ
        self.HOSTNAME = HOSTNAME
        self.HID = HID
        self.CID = CID
        self.STIME = STIME
        self.ETIME = ETIME
        self.VM_MAD = VM_MAD
        self.TM_MAD = TM_MAD
        self.DS_ID = DS_ID
        self.PSTIME = PSTIME
        self.PETIME = PETIME
        self.RSTIME = RSTIME
        self.RETIME = RETIME
        self.ESTIME = ESTIME
        self.EETIME = EETIME
        self.ACTION = ACTION
        self.UID = UID
        self.GID = GID
        self.REQUEST_ID = REQUEST_ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HISTORYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HISTORYType.subclass:
            return HISTORYType.subclass(*args_, **kwargs_)
        else:
            return HISTORYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OID(self): return self.OID
    def set_OID(self, OID): self.OID = OID
    def get_SEQ(self): return self.SEQ
    def set_SEQ(self, SEQ): self.SEQ = SEQ
    def get_HOSTNAME(self): return self.HOSTNAME
    def set_HOSTNAME(self, HOSTNAME): self.HOSTNAME = HOSTNAME
    def get_HID(self): return self.HID
    def set_HID(self, HID): self.HID = HID
    def get_CID(self): return self.CID
    def set_CID(self, CID): self.CID = CID
    def get_STIME(self): return self.STIME
    def set_STIME(self, STIME): self.STIME = STIME
    def get_ETIME(self): return self.ETIME
    def set_ETIME(self, ETIME): self.ETIME = ETIME
    def get_VM_MAD(self): return self.VM_MAD
    def set_VM_MAD(self, VM_MAD): self.VM_MAD = VM_MAD
    def get_TM_MAD(self): return self.TM_MAD
    def set_TM_MAD(self, TM_MAD): self.TM_MAD = TM_MAD
    def get_DS_ID(self): return self.DS_ID
    def set_DS_ID(self, DS_ID): self.DS_ID = DS_ID
    def get_PSTIME(self): return self.PSTIME
    def set_PSTIME(self, PSTIME): self.PSTIME = PSTIME
    def get_PETIME(self): return self.PETIME
    def set_PETIME(self, PETIME): self.PETIME = PETIME
    def get_RSTIME(self): return self.RSTIME
    def set_RSTIME(self, RSTIME): self.RSTIME = RSTIME
    def get_RETIME(self): return self.RETIME
    def set_RETIME(self, RETIME): self.RETIME = RETIME
    def get_ESTIME(self): return self.ESTIME
    def set_ESTIME(self, ESTIME): self.ESTIME = ESTIME
    def get_EETIME(self): return self.EETIME
    def set_EETIME(self, EETIME): self.EETIME = EETIME
    def get_ACTION(self): return self.ACTION
    def set_ACTION(self, ACTION): self.ACTION = ACTION
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_REQUEST_ID(self): return self.REQUEST_ID
    def set_REQUEST_ID(self, REQUEST_ID): self.REQUEST_ID = REQUEST_ID
    def hasContent_(self):
        if (
            self.OID is not None or
            self.SEQ is not None or
            self.HOSTNAME is not None or
            self.HID is not None or
            self.CID is not None or
            self.STIME is not None or
            self.ETIME is not None or
            self.VM_MAD is not None or
            self.TM_MAD is not None or
            self.DS_ID is not None or
            self.PSTIME is not None or
            self.PETIME is not None or
            self.RSTIME is not None or
            self.RETIME is not None or
            self.ESTIME is not None or
            self.EETIME is not None or
            self.ACTION is not None or
            self.UID is not None or
            self.GID is not None or
            self.REQUEST_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HISTORYType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HISTORYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HISTORYType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HISTORYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HISTORYType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HISTORYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OID>%s</OID>%s' % (self.gds_format_integer(self.OID, input_name='OID'), eol_))
        if self.SEQ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SEQ>%s</SEQ>%s' % (self.gds_format_integer(self.SEQ, input_name='SEQ'), eol_))
        if self.HOSTNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<HOSTNAME>%s</HOSTNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HOSTNAME), input_name='HOSTNAME')), eol_))
        if self.HID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<HID>%s</HID>%s' % (self.gds_format_integer(self.HID, input_name='HID'), eol_))
        if self.CID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CID>%s</CID>%s' % (self.gds_format_integer(self.CID, input_name='CID'), eol_))
        if self.STIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STIME>%s</STIME>%s' % (self.gds_format_integer(self.STIME, input_name='STIME'), eol_))
        if self.ETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ETIME>%s</ETIME>%s' % (self.gds_format_integer(self.ETIME, input_name='ETIME'), eol_))
        if self.VM_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VM_MAD>%s</VM_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VM_MAD), input_name='VM_MAD')), eol_))
        if self.TM_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TM_MAD>%s</TM_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TM_MAD), input_name='TM_MAD')), eol_))
        if self.DS_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DS_ID>%s</DS_ID>%s' % (self.gds_format_integer(self.DS_ID, input_name='DS_ID'), eol_))
        if self.PSTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PSTIME>%s</PSTIME>%s' % (self.gds_format_integer(self.PSTIME, input_name='PSTIME'), eol_))
        if self.PETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PETIME>%s</PETIME>%s' % (self.gds_format_integer(self.PETIME, input_name='PETIME'), eol_))
        if self.RSTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RSTIME>%s</RSTIME>%s' % (self.gds_format_integer(self.RSTIME, input_name='RSTIME'), eol_))
        if self.RETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RETIME>%s</RETIME>%s' % (self.gds_format_integer(self.RETIME, input_name='RETIME'), eol_))
        if self.ESTIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ESTIME>%s</ESTIME>%s' % (self.gds_format_integer(self.ESTIME, input_name='ESTIME'), eol_))
        if self.EETIME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EETIME>%s</EETIME>%s' % (self.gds_format_integer(self.EETIME, input_name='EETIME'), eol_))
        if self.ACTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ACTION>%s</ACTION>%s' % (self.gds_format_integer(self.ACTION, input_name='ACTION'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.REQUEST_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<REQUEST_ID>%s</REQUEST_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.REQUEST_ID), input_name='REQUEST_ID')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OID')
            self.OID = ival_
        elif nodeName_ == 'SEQ':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SEQ')
            self.SEQ = ival_
        elif nodeName_ == 'HOSTNAME':
            HOSTNAME_ = child_.text
            HOSTNAME_ = self.gds_validate_string(HOSTNAME_, node, 'HOSTNAME')
            self.HOSTNAME = HOSTNAME_
        elif nodeName_ == 'HID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'HID')
            self.HID = ival_
        elif nodeName_ == 'CID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CID')
            self.CID = ival_
        elif nodeName_ == 'STIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'STIME')
            self.STIME = ival_
        elif nodeName_ == 'ETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ETIME')
            self.ETIME = ival_
        elif nodeName_ == 'VM_MAD':
            VM_MAD_ = child_.text
            VM_MAD_ = self.gds_validate_string(VM_MAD_, node, 'VM_MAD')
            self.VM_MAD = VM_MAD_
        elif nodeName_ == 'TM_MAD':
            TM_MAD_ = child_.text
            TM_MAD_ = self.gds_validate_string(TM_MAD_, node, 'TM_MAD')
            self.TM_MAD = TM_MAD_
        elif nodeName_ == 'DS_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DS_ID')
            self.DS_ID = ival_
        elif nodeName_ == 'PSTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PSTIME')
            self.PSTIME = ival_
        elif nodeName_ == 'PETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PETIME')
            self.PETIME = ival_
        elif nodeName_ == 'RSTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RSTIME')
            self.RSTIME = ival_
        elif nodeName_ == 'RETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RETIME')
            self.RETIME = ival_
        elif nodeName_ == 'ESTIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ESTIME')
            self.ESTIME = ival_
        elif nodeName_ == 'EETIME':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'EETIME')
            self.EETIME = ival_
        elif nodeName_ == 'ACTION':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ACTION')
            self.ACTION = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'REQUEST_ID':
            REQUEST_ID_ = child_.text
            REQUEST_ID_ = self.gds_validate_string(REQUEST_ID_, node, 'REQUEST_ID')
            self.REQUEST_ID = REQUEST_ID_
# end class HISTORYType


class SNAPSHOTSType80(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DISK_ID=None, SNAPSHOT=None):
        self.original_tagname_ = None
        self.DISK_ID = DISK_ID
        if SNAPSHOT is None:
            self.SNAPSHOT = []
        else:
            self.SNAPSHOT = SNAPSHOT
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTSType80)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTSType80.subclass:
            return SNAPSHOTSType80.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTSType80(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DISK_ID(self): return self.DISK_ID
    def set_DISK_ID(self, DISK_ID): self.DISK_ID = DISK_ID
    def get_SNAPSHOT(self): return self.SNAPSHOT
    def set_SNAPSHOT(self, SNAPSHOT): self.SNAPSHOT = SNAPSHOT
    def add_SNAPSHOT(self, value): self.SNAPSHOT.append(value)
    def insert_SNAPSHOT_at(self, index, value): self.SNAPSHOT.insert(index, value)
    def replace_SNAPSHOT_at(self, index, value): self.SNAPSHOT[index] = value
    def hasContent_(self):
        if (
            self.DISK_ID is not None or
            self.SNAPSHOT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SNAPSHOTSType80', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTSType80')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SNAPSHOTSType80')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SNAPSHOTSType80', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SNAPSHOTSType80'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SNAPSHOTSType80', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DISK_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DISK_ID>%s</DISK_ID>%s' % (self.gds_format_integer(self.DISK_ID, input_name='DISK_ID'), eol_))
        for SNAPSHOT_ in self.SNAPSHOT:
            SNAPSHOT_.export(outfile, level, namespace_, name_='SNAPSHOT', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DISK_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DISK_ID')
            self.DISK_ID = ival_
        elif nodeName_ == 'SNAPSHOT':
            obj_ = SNAPSHOTType81.factory()
            obj_.build(child_)
            self.SNAPSHOT.append(obj_)
            obj_.original_tagname_ = 'SNAPSHOT'
# end class SNAPSHOTSType80


class SNAPSHOTType81(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ACTIVE=None, CHILDREN=None, DATE=None, ID=None, NAME=None, PARENT=None, SIZE=None):
        self.original_tagname_ = None
        self.ACTIVE = ACTIVE
        self.CHILDREN = CHILDREN
        self.DATE = DATE
        self.ID = ID
        self.NAME = NAME
        self.PARENT = PARENT
        self.SIZE = SIZE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SNAPSHOTType81)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SNAPSHOTType81.subclass:
            return SNAPSHOTType81.subclass(*args_, **kwargs_)
        else:
            return SNAPSHOTType81(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ACTIVE(self): return self.ACTIVE
    def set_ACTIVE(self, ACTIVE): self.ACTIVE = ACTIVE
    def get_CHILDREN(self): return self.CHILDREN
    def set_CHILDREN(self, CHILDREN): self.CHILDREN = CHILDREN
    def get_DATE(self): return self.DATE
    def set_DATE(self, DATE): self.DATE = DATE
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PARENT(self): return self.PARENT
    def set_PARENT(self, PARENT): self.PARENT = PARENT
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def hasContent_(self):
        if (
            self.ACTIVE is not None or
            self.CHILDREN is not None or
            self.DATE is not None or
            self.ID is not None or
            self.NAME is not None or
            self.PARENT is not None or
            self.SIZE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SNAPSHOTType81', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SNAPSHOTType81')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SNAPSHOTType81')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SNAPSHOTType81', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SNAPSHOTType81'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SNAPSHOTType81', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ACTIVE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ACTIVE>%s</ACTIVE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ACTIVE), input_name='ACTIVE')), eol_))
        if self.CHILDREN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CHILDREN>%s</CHILDREN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CHILDREN), input_name='CHILDREN')), eol_))
        if self.DATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATE>%s</DATE>%s' % (self.gds_format_integer(self.DATE, input_name='DATE'), eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PARENT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PARENT>%s</PARENT>%s' % (self.gds_format_integer(self.PARENT, input_name='PARENT'), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_format_integer(self.SIZE, input_name='SIZE'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ACTIVE':
            ACTIVE_ = child_.text
            ACTIVE_ = self.gds_validate_string(ACTIVE_, node, 'ACTIVE')
            self.ACTIVE = ACTIVE_
        elif nodeName_ == 'CHILDREN':
            CHILDREN_ = child_.text
            CHILDREN_ = self.gds_validate_string(CHILDREN_, node, 'CHILDREN')
            self.CHILDREN = CHILDREN_
        elif nodeName_ == 'DATE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DATE')
            self.DATE = ival_
        elif nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PARENT':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PARENT')
            self.PARENT = ival_
        elif nodeName_ == 'SIZE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
# end class SNAPSHOTType81


class PERMISSIONSType82(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType82)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType82.subclass:
            return PERMISSIONSType82.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType82(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType82', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType82')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType82')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType82', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType82'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType82', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType82


class VNETType83(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, UID=None, GID=None, UNAME=None, GNAME=None, NAME=None, PERMISSIONS=None, CLUSTERS=None, BRIDGE=None, PARENT_NETWORK_ID=None, VN_MAD=None, PHYDEV=None, VLAN_ID=None, VLAN_ID_AUTOMATIC=None, USED_LEASES=None, VROUTERS=None, TEMPLATE=None, AR_POOL=None):
        self.original_tagname_ = None
        self.ID = ID
        self.UID = UID
        self.GID = GID
        self.UNAME = UNAME
        self.GNAME = GNAME
        self.NAME = NAME
        self.PERMISSIONS = PERMISSIONS
        self.CLUSTERS = CLUSTERS
        self.BRIDGE = BRIDGE
        self.PARENT_NETWORK_ID = PARENT_NETWORK_ID
        self.VN_MAD = VN_MAD
        self.PHYDEV = PHYDEV
        self.VLAN_ID = VLAN_ID
        self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC
        self.USED_LEASES = USED_LEASES
        self.VROUTERS = VROUTERS
        self.TEMPLATE = TEMPLATE
        self.AR_POOL = AR_POOL
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VNETType83)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VNETType83.subclass:
            return VNETType83.subclass(*args_, **kwargs_)
        else:
            return VNETType83(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_UID(self): return self.UID
    def set_UID(self, UID): self.UID = UID
    def get_GID(self): return self.GID
    def set_GID(self, GID): self.GID = GID
    def get_UNAME(self): return self.UNAME
    def set_UNAME(self, UNAME): self.UNAME = UNAME
    def get_GNAME(self): return self.GNAME
    def set_GNAME(self, GNAME): self.GNAME = GNAME
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_PERMISSIONS(self): return self.PERMISSIONS
    def set_PERMISSIONS(self, PERMISSIONS): self.PERMISSIONS = PERMISSIONS
    def get_CLUSTERS(self): return self.CLUSTERS
    def set_CLUSTERS(self, CLUSTERS): self.CLUSTERS = CLUSTERS
    def get_BRIDGE(self): return self.BRIDGE
    def set_BRIDGE(self, BRIDGE): self.BRIDGE = BRIDGE
    def get_PARENT_NETWORK_ID(self): return self.PARENT_NETWORK_ID
    def set_PARENT_NETWORK_ID(self, PARENT_NETWORK_ID): self.PARENT_NETWORK_ID = PARENT_NETWORK_ID
    def get_VN_MAD(self): return self.VN_MAD
    def set_VN_MAD(self, VN_MAD): self.VN_MAD = VN_MAD
    def get_PHYDEV(self): return self.PHYDEV
    def set_PHYDEV(self, PHYDEV): self.PHYDEV = PHYDEV
    def get_VLAN_ID(self): return self.VLAN_ID
    def set_VLAN_ID(self, VLAN_ID): self.VLAN_ID = VLAN_ID
    def get_VLAN_ID_AUTOMATIC(self): return self.VLAN_ID_AUTOMATIC
    def set_VLAN_ID_AUTOMATIC(self, VLAN_ID_AUTOMATIC): self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC
    def get_USED_LEASES(self): return self.USED_LEASES
    def set_USED_LEASES(self, USED_LEASES): self.USED_LEASES = USED_LEASES
    def get_VROUTERS(self): return self.VROUTERS
    def set_VROUTERS(self, VROUTERS): self.VROUTERS = VROUTERS
    def get_TEMPLATE(self): return self.TEMPLATE
    def set_TEMPLATE(self, TEMPLATE): self.TEMPLATE = TEMPLATE
    def get_AR_POOL(self): return self.AR_POOL
    def set_AR_POOL(self, AR_POOL): self.AR_POOL = AR_POOL
    def hasContent_(self):
        if (
            self.ID is not None or
            self.UID is not None or
            self.GID is not None or
            self.UNAME is not None or
            self.GNAME is not None or
            self.NAME is not None or
            self.PERMISSIONS is not None or
            self.CLUSTERS is not None or
            self.BRIDGE is not None or
            self.PARENT_NETWORK_ID is not None or
            self.VN_MAD is not None or
            self.PHYDEV is not None or
            self.VLAN_ID is not None or
            self.VLAN_ID_AUTOMATIC is not None or
            self.USED_LEASES is not None or
            self.VROUTERS is not None or
            self.TEMPLATE is not None or
            self.AR_POOL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VNETType83', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VNETType83')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VNETType83')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VNETType83', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VNETType83'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VNETType83', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(self.ID, input_name='ID'), eol_))
        if self.UID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UID>%s</UID>%s' % (self.gds_format_integer(self.UID, input_name='UID'), eol_))
        if self.GID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GID>%s</GID>%s' % (self.gds_format_integer(self.GID, input_name='GID'), eol_))
        if self.UNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UNAME>%s</UNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UNAME), input_name='UNAME')), eol_))
        if self.GNAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GNAME>%s</GNAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GNAME), input_name='GNAME')), eol_))
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME>%s</NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), eol_))
        if self.PERMISSIONS is not None:
            self.PERMISSIONS.export(outfile, level, namespace_, name_='PERMISSIONS', pretty_print=pretty_print)
        if self.CLUSTERS is not None:
            self.CLUSTERS.export(outfile, level, namespace_, name_='CLUSTERS', pretty_print=pretty_print)
        if self.BRIDGE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BRIDGE>%s</BRIDGE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BRIDGE), input_name='BRIDGE')), eol_))
        if self.PARENT_NETWORK_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PARENT_NETWORK_ID>%s</PARENT_NETWORK_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_NETWORK_ID), input_name='PARENT_NETWORK_ID')), eol_))
        if self.VN_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VN_MAD>%s</VN_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), eol_))
        if self.PHYDEV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PHYDEV>%s</PHYDEV>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PHYDEV), input_name='PHYDEV')), eol_))
        if self.VLAN_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VLAN_ID>%s</VLAN_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VLAN_ID), input_name='VLAN_ID')), eol_))
        if self.VLAN_ID_AUTOMATIC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VLAN_ID_AUTOMATIC>%s</VLAN_ID_AUTOMATIC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VLAN_ID_AUTOMATIC), input_name='VLAN_ID_AUTOMATIC')), eol_))
        if self.USED_LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_LEASES>%s</USED_LEASES>%s' % (self.gds_format_integer(self.USED_LEASES, input_name='USED_LEASES'), eol_))
        if self.VROUTERS is not None:
            self.VROUTERS.export(outfile, level, namespace_, name_='VROUTERS', pretty_print=pretty_print)
        if self.TEMPLATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TEMPLATE>%s</TEMPLATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TEMPLATE), input_name='TEMPLATE')), eol_))
        if self.AR_POOL is not None:
            self.AR_POOL.export(outfile, level, namespace_, name_='AR_POOL', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'UID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UID')
            self.UID = ival_
        elif nodeName_ == 'GID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GID')
            self.GID = ival_
        elif nodeName_ == 'UNAME':
            UNAME_ = child_.text
            UNAME_ = self.gds_validate_string(UNAME_, node, 'UNAME')
            self.UNAME = UNAME_
        elif nodeName_ == 'GNAME':
            GNAME_ = child_.text
            GNAME_ = self.gds_validate_string(GNAME_, node, 'GNAME')
            self.GNAME = GNAME_
        elif nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PERMISSIONS':
            obj_ = PERMISSIONSType84.factory()
            obj_.build(child_)
            self.PERMISSIONS = obj_
            obj_.original_tagname_ = 'PERMISSIONS'
        elif nodeName_ == 'CLUSTERS':
            obj_ = CLUSTERSType85.factory()
            obj_.build(child_)
            self.CLUSTERS = obj_
            obj_.original_tagname_ = 'CLUSTERS'
        elif nodeName_ == 'BRIDGE':
            BRIDGE_ = child_.text
            BRIDGE_ = self.gds_validate_string(BRIDGE_, node, 'BRIDGE')
            self.BRIDGE = BRIDGE_
        elif nodeName_ == 'PARENT_NETWORK_ID':
            PARENT_NETWORK_ID_ = child_.text
            PARENT_NETWORK_ID_ = self.gds_validate_string(PARENT_NETWORK_ID_, node, 'PARENT_NETWORK_ID')
            self.PARENT_NETWORK_ID = PARENT_NETWORK_ID_
        elif nodeName_ == 'VN_MAD':
            VN_MAD_ = child_.text
            VN_MAD_ = self.gds_validate_string(VN_MAD_, node, 'VN_MAD')
            self.VN_MAD = VN_MAD_
        elif nodeName_ == 'PHYDEV':
            PHYDEV_ = child_.text
            PHYDEV_ = self.gds_validate_string(PHYDEV_, node, 'PHYDEV')
            self.PHYDEV = PHYDEV_
        elif nodeName_ == 'VLAN_ID':
            VLAN_ID_ = child_.text
            VLAN_ID_ = self.gds_validate_string(VLAN_ID_, node, 'VLAN_ID')
            self.VLAN_ID = VLAN_ID_
        elif nodeName_ == 'VLAN_ID_AUTOMATIC':
            VLAN_ID_AUTOMATIC_ = child_.text
            VLAN_ID_AUTOMATIC_ = self.gds_validate_string(VLAN_ID_AUTOMATIC_, node, 'VLAN_ID_AUTOMATIC')
            self.VLAN_ID_AUTOMATIC = VLAN_ID_AUTOMATIC_
        elif nodeName_ == 'USED_LEASES':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'USED_LEASES')
            self.USED_LEASES = ival_
        elif nodeName_ == 'VROUTERS':
            obj_ = VROUTERSType.factory()
            obj_.build(child_)
            self.VROUTERS = obj_
            obj_.original_tagname_ = 'VROUTERS'
        elif nodeName_ == 'TEMPLATE':
            TEMPLATE_ = child_.text
            TEMPLATE_ = self.gds_validate_string(TEMPLATE_, node, 'TEMPLATE')
            self.TEMPLATE = TEMPLATE_
        elif nodeName_ == 'AR_POOL':
            obj_ = AR_POOLType.factory()
            obj_.build(child_)
            self.AR_POOL = obj_
            obj_.original_tagname_ = 'AR_POOL'
# end class VNETType83


class PERMISSIONSType84(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType84)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType84.subclass:
            return PERMISSIONSType84.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType84(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType84', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType84')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType84')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType84', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType84'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType84', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType84


class CLUSTERSType85(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERSType85)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERSType85.subclass:
            return CLUSTERSType85.subclass(*args_, **kwargs_)
        else:
            return CLUSTERSType85(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CLUSTERSType85', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERSType85')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLUSTERSType85')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CLUSTERSType85', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLUSTERSType85'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLUSTERSType85', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class CLUSTERSType85


class VROUTERSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VROUTERSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VROUTERSType.subclass:
            return VROUTERSType.subclass(*args_, **kwargs_)
        else:
            return VROUTERSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VROUTERSType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VROUTERSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VROUTERSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VROUTERSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VROUTERSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VROUTERSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class VROUTERSType


class AR_POOLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AR=None):
        self.original_tagname_ = None
        if AR is None:
            self.AR = []
        else:
            self.AR = AR
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AR_POOLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AR_POOLType.subclass:
            return AR_POOLType.subclass(*args_, **kwargs_)
        else:
            return AR_POOLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AR(self): return self.AR
    def set_AR(self, AR): self.AR = AR
    def add_AR(self, value): self.AR.append(value)
    def insert_AR_at(self, index, value): self.AR.insert(index, value)
    def replace_AR_at(self, index, value): self.AR[index] = value
    def hasContent_(self):
        if (
            self.AR
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AR_POOLType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AR_POOLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AR_POOLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AR_POOLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AR_POOLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AR_POOLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AR_ in self.AR:
            AR_.export(outfile, level, namespace_, name_='AR', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AR':
            obj_ = ARType.factory()
            obj_.build(child_)
            self.AR.append(obj_)
            obj_.original_tagname_ = 'AR'
# end class AR_POOLType


class ARType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ALLOCATED=None, AR_ID=None, GLOBAL_PREFIX=None, IP=None, MAC=None, PARENT_NETWORK_AR_ID=None, SIZE=None, TYPE=None, ULA_PREFIX=None, VN_MAD=None):
        self.original_tagname_ = None
        self.ALLOCATED = ALLOCATED
        self.AR_ID = AR_ID
        self.GLOBAL_PREFIX = GLOBAL_PREFIX
        self.IP = IP
        self.MAC = MAC
        self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID
        self.SIZE = SIZE
        self.TYPE = TYPE
        self.ULA_PREFIX = ULA_PREFIX
        self.VN_MAD = VN_MAD
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ARType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ARType.subclass:
            return ARType.subclass(*args_, **kwargs_)
        else:
            return ARType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ALLOCATED(self): return self.ALLOCATED
    def set_ALLOCATED(self, ALLOCATED): self.ALLOCATED = ALLOCATED
    def get_AR_ID(self): return self.AR_ID
    def set_AR_ID(self, AR_ID): self.AR_ID = AR_ID
    def get_GLOBAL_PREFIX(self): return self.GLOBAL_PREFIX
    def set_GLOBAL_PREFIX(self, GLOBAL_PREFIX): self.GLOBAL_PREFIX = GLOBAL_PREFIX
    def get_IP(self): return self.IP
    def set_IP(self, IP): self.IP = IP
    def get_MAC(self): return self.MAC
    def set_MAC(self, MAC): self.MAC = MAC
    def get_PARENT_NETWORK_AR_ID(self): return self.PARENT_NETWORK_AR_ID
    def set_PARENT_NETWORK_AR_ID(self, PARENT_NETWORK_AR_ID): self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ULA_PREFIX(self): return self.ULA_PREFIX
    def set_ULA_PREFIX(self, ULA_PREFIX): self.ULA_PREFIX = ULA_PREFIX
    def get_VN_MAD(self): return self.VN_MAD
    def set_VN_MAD(self, VN_MAD): self.VN_MAD = VN_MAD
    def hasContent_(self):
        if (
            self.ALLOCATED is not None or
            self.AR_ID is not None or
            self.GLOBAL_PREFIX is not None or
            self.IP is not None or
            self.MAC is not None or
            self.PARENT_NETWORK_AR_ID is not None or
            self.SIZE is not None or
            self.TYPE is not None or
            self.ULA_PREFIX is not None or
            self.VN_MAD is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ARType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ARType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ARType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ARType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ARType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ARType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ALLOCATED is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ALLOCATED>%s</ALLOCATED>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ALLOCATED), input_name='ALLOCATED')), eol_))
        if self.AR_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AR_ID>%s</AR_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AR_ID), input_name='AR_ID')), eol_))
        if self.GLOBAL_PREFIX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GLOBAL_PREFIX>%s</GLOBAL_PREFIX>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GLOBAL_PREFIX), input_name='GLOBAL_PREFIX')), eol_))
        if self.IP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP>%s</IP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP), input_name='IP')), eol_))
        if self.MAC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MAC>%s</MAC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MAC), input_name='MAC')), eol_))
        if self.PARENT_NETWORK_AR_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PARENT_NETWORK_AR_ID>%s</PARENT_NETWORK_AR_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_NETWORK_AR_ID), input_name='PARENT_NETWORK_AR_ID')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_format_integer(self.SIZE, input_name='SIZE'), eol_))
        if self.TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TYPE>%s</TYPE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), eol_))
        if self.ULA_PREFIX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ULA_PREFIX>%s</ULA_PREFIX>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ULA_PREFIX), input_name='ULA_PREFIX')), eol_))
        if self.VN_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VN_MAD>%s</VN_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ALLOCATED':
            ALLOCATED_ = child_.text
            ALLOCATED_ = self.gds_validate_string(ALLOCATED_, node, 'ALLOCATED')
            self.ALLOCATED = ALLOCATED_
        elif nodeName_ == 'AR_ID':
            AR_ID_ = child_.text
            AR_ID_ = self.gds_validate_string(AR_ID_, node, 'AR_ID')
            self.AR_ID = AR_ID_
        elif nodeName_ == 'GLOBAL_PREFIX':
            GLOBAL_PREFIX_ = child_.text
            GLOBAL_PREFIX_ = self.gds_validate_string(GLOBAL_PREFIX_, node, 'GLOBAL_PREFIX')
            self.GLOBAL_PREFIX = GLOBAL_PREFIX_
        elif nodeName_ == 'IP':
            IP_ = child_.text
            IP_ = self.gds_validate_string(IP_, node, 'IP')
            self.IP = IP_
        elif nodeName_ == 'MAC':
            MAC_ = child_.text
            MAC_ = self.gds_validate_string(MAC_, node, 'MAC')
            self.MAC = MAC_
        elif nodeName_ == 'PARENT_NETWORK_AR_ID':
            PARENT_NETWORK_AR_ID_ = child_.text
            PARENT_NETWORK_AR_ID_ = self.gds_validate_string(PARENT_NETWORK_AR_ID_, node, 'PARENT_NETWORK_AR_ID')
            self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID_
        elif nodeName_ == 'SIZE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
        elif nodeName_ == 'ULA_PREFIX':
            ULA_PREFIX_ = child_.text
            ULA_PREFIX_ = self.gds_validate_string(ULA_PREFIX_, node, 'ULA_PREFIX')
            self.ULA_PREFIX = ULA_PREFIX_
        elif nodeName_ == 'VN_MAD':
            VN_MAD_ = child_.text
            VN_MAD_ = self.gds_validate_string(VN_MAD_, node, 'VN_MAD')
            self.VN_MAD = VN_MAD_
# end class ARType


class PERMISSIONSType86(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType86)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType86.subclass:
            return PERMISSIONSType86.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType86(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType86', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType86')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType86')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType86', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType86'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType86', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType86


class CLUSTERSType87(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CLUSTERSType87)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CLUSTERSType87.subclass:
            return CLUSTERSType87.subclass(*args_, **kwargs_)
        else:
            return CLUSTERSType87(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CLUSTERSType87', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CLUSTERSType87')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CLUSTERSType87')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CLUSTERSType87', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CLUSTERSType87'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CLUSTERSType87', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class CLUSTERSType87


class VROUTERSType88(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VROUTERSType88)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VROUTERSType88.subclass:
            return VROUTERSType88.subclass(*args_, **kwargs_)
        else:
            return VROUTERSType88(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VROUTERSType88', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VROUTERSType88')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VROUTERSType88')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VROUTERSType88', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VROUTERSType88'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VROUTERSType88', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class VROUTERSType88


class AR_POOLType89(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AR=None):
        self.original_tagname_ = None
        if AR is None:
            self.AR = []
        else:
            self.AR = AR
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AR_POOLType89)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AR_POOLType89.subclass:
            return AR_POOLType89.subclass(*args_, **kwargs_)
        else:
            return AR_POOLType89(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AR(self): return self.AR
    def set_AR(self, AR): self.AR = AR
    def add_AR(self, value): self.AR.append(value)
    def insert_AR_at(self, index, value): self.AR.insert(index, value)
    def replace_AR_at(self, index, value): self.AR[index] = value
    def hasContent_(self):
        if (
            self.AR
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AR_POOLType89', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AR_POOLType89')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AR_POOLType89')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AR_POOLType89', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AR_POOLType89'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AR_POOLType89', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AR_ in self.AR:
            AR_.export(outfile, level, namespace_, name_='AR', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AR':
            obj_ = ARType90.factory()
            obj_.build(child_)
            self.AR.append(obj_)
            obj_.original_tagname_ = 'AR'
# end class AR_POOLType89


class ARType90(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AR_ID=None, GLOBAL_PREFIX=None, IP=None, MAC=None, PARENT_NETWORK_AR_ID=None, SIZE=None, TYPE=None, ULA_PREFIX=None, VN_MAD=None, MAC_END=None, IP_END=None, IP6_ULA=None, IP6_ULA_END=None, IP6_GLOBAL=None, IP6_GLOBAL_END=None, IP6=None, IP6_END=None, USED_LEASES=None, LEASES=None):
        self.original_tagname_ = None
        self.AR_ID = AR_ID
        self.GLOBAL_PREFIX = GLOBAL_PREFIX
        self.IP = IP
        self.MAC = MAC
        self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID
        self.SIZE = SIZE
        self.TYPE = TYPE
        self.ULA_PREFIX = ULA_PREFIX
        self.VN_MAD = VN_MAD
        self.MAC_END = MAC_END
        self.IP_END = IP_END
        self.IP6_ULA = IP6_ULA
        self.IP6_ULA_END = IP6_ULA_END
        self.IP6_GLOBAL = IP6_GLOBAL
        self.IP6_GLOBAL_END = IP6_GLOBAL_END
        self.IP6 = IP6
        self.IP6_END = IP6_END
        self.USED_LEASES = USED_LEASES
        self.LEASES = LEASES
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ARType90)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ARType90.subclass:
            return ARType90.subclass(*args_, **kwargs_)
        else:
            return ARType90(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AR_ID(self): return self.AR_ID
    def set_AR_ID(self, AR_ID): self.AR_ID = AR_ID
    def get_GLOBAL_PREFIX(self): return self.GLOBAL_PREFIX
    def set_GLOBAL_PREFIX(self, GLOBAL_PREFIX): self.GLOBAL_PREFIX = GLOBAL_PREFIX
    def get_IP(self): return self.IP
    def set_IP(self, IP): self.IP = IP
    def get_MAC(self): return self.MAC
    def set_MAC(self, MAC): self.MAC = MAC
    def get_PARENT_NETWORK_AR_ID(self): return self.PARENT_NETWORK_AR_ID
    def set_PARENT_NETWORK_AR_ID(self, PARENT_NETWORK_AR_ID): self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def get_ULA_PREFIX(self): return self.ULA_PREFIX
    def set_ULA_PREFIX(self, ULA_PREFIX): self.ULA_PREFIX = ULA_PREFIX
    def get_VN_MAD(self): return self.VN_MAD
    def set_VN_MAD(self, VN_MAD): self.VN_MAD = VN_MAD
    def get_MAC_END(self): return self.MAC_END
    def set_MAC_END(self, MAC_END): self.MAC_END = MAC_END
    def get_IP_END(self): return self.IP_END
    def set_IP_END(self, IP_END): self.IP_END = IP_END
    def get_IP6_ULA(self): return self.IP6_ULA
    def set_IP6_ULA(self, IP6_ULA): self.IP6_ULA = IP6_ULA
    def get_IP6_ULA_END(self): return self.IP6_ULA_END
    def set_IP6_ULA_END(self, IP6_ULA_END): self.IP6_ULA_END = IP6_ULA_END
    def get_IP6_GLOBAL(self): return self.IP6_GLOBAL
    def set_IP6_GLOBAL(self, IP6_GLOBAL): self.IP6_GLOBAL = IP6_GLOBAL
    def get_IP6_GLOBAL_END(self): return self.IP6_GLOBAL_END
    def set_IP6_GLOBAL_END(self, IP6_GLOBAL_END): self.IP6_GLOBAL_END = IP6_GLOBAL_END
    def get_IP6(self): return self.IP6
    def set_IP6(self, IP6): self.IP6 = IP6
    def get_IP6_END(self): return self.IP6_END
    def set_IP6_END(self, IP6_END): self.IP6_END = IP6_END
    def get_USED_LEASES(self): return self.USED_LEASES
    def set_USED_LEASES(self, USED_LEASES): self.USED_LEASES = USED_LEASES
    def get_LEASES(self): return self.LEASES
    def set_LEASES(self, LEASES): self.LEASES = LEASES
    def hasContent_(self):
        if (
            self.AR_ID is not None or
            self.GLOBAL_PREFIX is not None or
            self.IP is not None or
            self.MAC is not None or
            self.PARENT_NETWORK_AR_ID is not None or
            self.SIZE is not None or
            self.TYPE is not None or
            self.ULA_PREFIX is not None or
            self.VN_MAD is not None or
            self.MAC_END is not None or
            self.IP_END is not None or
            self.IP6_ULA is not None or
            self.IP6_ULA_END is not None or
            self.IP6_GLOBAL is not None or
            self.IP6_GLOBAL_END is not None or
            self.IP6 is not None or
            self.IP6_END is not None or
            self.USED_LEASES is not None or
            self.LEASES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ARType90', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ARType90')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ARType90')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ARType90', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ARType90'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ARType90', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AR_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AR_ID>%s</AR_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AR_ID), input_name='AR_ID')), eol_))
        if self.GLOBAL_PREFIX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GLOBAL_PREFIX>%s</GLOBAL_PREFIX>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GLOBAL_PREFIX), input_name='GLOBAL_PREFIX')), eol_))
        if self.IP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP>%s</IP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP), input_name='IP')), eol_))
        if self.MAC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MAC>%s</MAC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MAC), input_name='MAC')), eol_))
        if self.PARENT_NETWORK_AR_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PARENT_NETWORK_AR_ID>%s</PARENT_NETWORK_AR_ID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PARENT_NETWORK_AR_ID), input_name='PARENT_NETWORK_AR_ID')), eol_))
        if self.SIZE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SIZE>%s</SIZE>%s' % (self.gds_format_integer(self.SIZE, input_name='SIZE'), eol_))
        if self.TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TYPE>%s</TYPE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), eol_))
        if self.ULA_PREFIX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ULA_PREFIX>%s</ULA_PREFIX>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ULA_PREFIX), input_name='ULA_PREFIX')), eol_))
        if self.VN_MAD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VN_MAD>%s</VN_MAD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VN_MAD), input_name='VN_MAD')), eol_))
        if self.MAC_END is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MAC_END>%s</MAC_END>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MAC_END), input_name='MAC_END')), eol_))
        if self.IP_END is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP_END>%s</IP_END>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP_END), input_name='IP_END')), eol_))
        if self.IP6_ULA is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6_ULA>%s</IP6_ULA>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6_ULA), input_name='IP6_ULA')), eol_))
        if self.IP6_ULA_END is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6_ULA_END>%s</IP6_ULA_END>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6_ULA_END), input_name='IP6_ULA_END')), eol_))
        if self.IP6_GLOBAL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6_GLOBAL>%s</IP6_GLOBAL>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6_GLOBAL), input_name='IP6_GLOBAL')), eol_))
        if self.IP6_GLOBAL_END is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6_GLOBAL_END>%s</IP6_GLOBAL_END>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6_GLOBAL_END), input_name='IP6_GLOBAL_END')), eol_))
        if self.IP6 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6>%s</IP6>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6), input_name='IP6')), eol_))
        if self.IP6_END is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6_END>%s</IP6_END>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6_END), input_name='IP6_END')), eol_))
        if self.USED_LEASES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USED_LEASES>%s</USED_LEASES>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USED_LEASES), input_name='USED_LEASES')), eol_))
        if self.LEASES is not None:
            self.LEASES.export(outfile, level, namespace_, name_='LEASES', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AR_ID':
            AR_ID_ = child_.text
            AR_ID_ = self.gds_validate_string(AR_ID_, node, 'AR_ID')
            self.AR_ID = AR_ID_
        elif nodeName_ == 'GLOBAL_PREFIX':
            GLOBAL_PREFIX_ = child_.text
            GLOBAL_PREFIX_ = self.gds_validate_string(GLOBAL_PREFIX_, node, 'GLOBAL_PREFIX')
            self.GLOBAL_PREFIX = GLOBAL_PREFIX_
        elif nodeName_ == 'IP':
            IP_ = child_.text
            IP_ = self.gds_validate_string(IP_, node, 'IP')
            self.IP = IP_
        elif nodeName_ == 'MAC':
            MAC_ = child_.text
            MAC_ = self.gds_validate_string(MAC_, node, 'MAC')
            self.MAC = MAC_
        elif nodeName_ == 'PARENT_NETWORK_AR_ID':
            PARENT_NETWORK_AR_ID_ = child_.text
            PARENT_NETWORK_AR_ID_ = self.gds_validate_string(PARENT_NETWORK_AR_ID_, node, 'PARENT_NETWORK_AR_ID')
            self.PARENT_NETWORK_AR_ID = PARENT_NETWORK_AR_ID_
        elif nodeName_ == 'SIZE':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SIZE')
            self.SIZE = ival_
        elif nodeName_ == 'TYPE':
            TYPE_ = child_.text
            TYPE_ = self.gds_validate_string(TYPE_, node, 'TYPE')
            self.TYPE = TYPE_
        elif nodeName_ == 'ULA_PREFIX':
            ULA_PREFIX_ = child_.text
            ULA_PREFIX_ = self.gds_validate_string(ULA_PREFIX_, node, 'ULA_PREFIX')
            self.ULA_PREFIX = ULA_PREFIX_
        elif nodeName_ == 'VN_MAD':
            VN_MAD_ = child_.text
            VN_MAD_ = self.gds_validate_string(VN_MAD_, node, 'VN_MAD')
            self.VN_MAD = VN_MAD_
        elif nodeName_ == 'MAC_END':
            MAC_END_ = child_.text
            MAC_END_ = self.gds_validate_string(MAC_END_, node, 'MAC_END')
            self.MAC_END = MAC_END_
        elif nodeName_ == 'IP_END':
            IP_END_ = child_.text
            IP_END_ = self.gds_validate_string(IP_END_, node, 'IP_END')
            self.IP_END = IP_END_
        elif nodeName_ == 'IP6_ULA':
            IP6_ULA_ = child_.text
            IP6_ULA_ = self.gds_validate_string(IP6_ULA_, node, 'IP6_ULA')
            self.IP6_ULA = IP6_ULA_
        elif nodeName_ == 'IP6_ULA_END':
            IP6_ULA_END_ = child_.text
            IP6_ULA_END_ = self.gds_validate_string(IP6_ULA_END_, node, 'IP6_ULA_END')
            self.IP6_ULA_END = IP6_ULA_END_
        elif nodeName_ == 'IP6_GLOBAL':
            IP6_GLOBAL_ = child_.text
            IP6_GLOBAL_ = self.gds_validate_string(IP6_GLOBAL_, node, 'IP6_GLOBAL')
            self.IP6_GLOBAL = IP6_GLOBAL_
        elif nodeName_ == 'IP6_GLOBAL_END':
            IP6_GLOBAL_END_ = child_.text
            IP6_GLOBAL_END_ = self.gds_validate_string(IP6_GLOBAL_END_, node, 'IP6_GLOBAL_END')
            self.IP6_GLOBAL_END = IP6_GLOBAL_END_
        elif nodeName_ == 'IP6':
            IP6_ = child_.text
            IP6_ = self.gds_validate_string(IP6_, node, 'IP6')
            self.IP6 = IP6_
        elif nodeName_ == 'IP6_END':
            IP6_END_ = child_.text
            IP6_END_ = self.gds_validate_string(IP6_END_, node, 'IP6_END')
            self.IP6_END = IP6_END_
        elif nodeName_ == 'USED_LEASES':
            USED_LEASES_ = child_.text
            USED_LEASES_ = self.gds_validate_string(USED_LEASES_, node, 'USED_LEASES')
            self.USED_LEASES = USED_LEASES_
        elif nodeName_ == 'LEASES':
            obj_ = LEASESType.factory()
            obj_.build(child_)
            self.LEASES = obj_
            obj_.original_tagname_ = 'LEASES'
# end class ARType90


class LEASESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LEASE=None):
        self.original_tagname_ = None
        if LEASE is None:
            self.LEASE = []
        else:
            self.LEASE = LEASE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEASESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEASESType.subclass:
            return LEASESType.subclass(*args_, **kwargs_)
        else:
            return LEASESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LEASE(self): return self.LEASE
    def set_LEASE(self, LEASE): self.LEASE = LEASE
    def add_LEASE(self, value): self.LEASE.append(value)
    def insert_LEASE_at(self, index, value): self.LEASE.insert(index, value)
    def replace_LEASE_at(self, index, value): self.LEASE[index] = value
    def hasContent_(self):
        if (
            self.LEASE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LEASESType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LEASESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LEASESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LEASESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LEASESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LEASESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LEASE_ in self.LEASE:
            LEASE_.export(outfile, level, namespace_, name_='LEASE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LEASE':
            obj_ = LEASEType.factory()
            obj_.build(child_)
            self.LEASE.append(obj_)
            obj_.original_tagname_ = 'LEASE'
# end class LEASESType


class LEASEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IP=None, IP6=None, IP6_GLOBAL=None, IP6_LINK=None, IP6_ULA=None, MAC=None, VM=None, VNET=None, VROUTER=None):
        self.original_tagname_ = None
        self.IP = IP
        self.IP6 = IP6
        self.IP6_GLOBAL = IP6_GLOBAL
        self.IP6_LINK = IP6_LINK
        self.IP6_ULA = IP6_ULA
        self.MAC = MAC
        self.VM = VM
        self.VNET = VNET
        self.VROUTER = VROUTER
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LEASEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LEASEType.subclass:
            return LEASEType.subclass(*args_, **kwargs_)
        else:
            return LEASEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IP(self): return self.IP
    def set_IP(self, IP): self.IP = IP
    def get_IP6(self): return self.IP6
    def set_IP6(self, IP6): self.IP6 = IP6
    def get_IP6_GLOBAL(self): return self.IP6_GLOBAL
    def set_IP6_GLOBAL(self, IP6_GLOBAL): self.IP6_GLOBAL = IP6_GLOBAL
    def get_IP6_LINK(self): return self.IP6_LINK
    def set_IP6_LINK(self, IP6_LINK): self.IP6_LINK = IP6_LINK
    def get_IP6_ULA(self): return self.IP6_ULA
    def set_IP6_ULA(self, IP6_ULA): self.IP6_ULA = IP6_ULA
    def get_MAC(self): return self.MAC
    def set_MAC(self, MAC): self.MAC = MAC
    def get_VM(self): return self.VM
    def set_VM(self, VM): self.VM = VM
    def get_VNET(self): return self.VNET
    def set_VNET(self, VNET): self.VNET = VNET
    def get_VROUTER(self): return self.VROUTER
    def set_VROUTER(self, VROUTER): self.VROUTER = VROUTER
    def hasContent_(self):
        if (
            self.IP is not None or
            self.IP6 is not None or
            self.IP6_GLOBAL is not None or
            self.IP6_LINK is not None or
            self.IP6_ULA is not None or
            self.MAC is not None or
            self.VM is not None or
            self.VNET is not None or
            self.VROUTER is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LEASEType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LEASEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LEASEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LEASEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LEASEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LEASEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP>%s</IP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP), input_name='IP')), eol_))
        if self.IP6 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6>%s</IP6>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6), input_name='IP6')), eol_))
        if self.IP6_GLOBAL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6_GLOBAL>%s</IP6_GLOBAL>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6_GLOBAL), input_name='IP6_GLOBAL')), eol_))
        if self.IP6_LINK is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6_LINK>%s</IP6_LINK>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6_LINK), input_name='IP6_LINK')), eol_))
        if self.IP6_ULA is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IP6_ULA>%s</IP6_ULA>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IP6_ULA), input_name='IP6_ULA')), eol_))
        if self.MAC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MAC>%s</MAC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MAC), input_name='MAC')), eol_))
        if self.VM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VM>%s</VM>%s' % (self.gds_format_integer(self.VM, input_name='VM'), eol_))
        if self.VNET is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VNET>%s</VNET>%s' % (self.gds_format_integer(self.VNET, input_name='VNET'), eol_))
        if self.VROUTER is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VROUTER>%s</VROUTER>%s' % (self.gds_format_integer(self.VROUTER, input_name='VROUTER'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IP':
            IP_ = child_.text
            IP_ = self.gds_validate_string(IP_, node, 'IP')
            self.IP = IP_
        elif nodeName_ == 'IP6':
            IP6_ = child_.text
            IP6_ = self.gds_validate_string(IP6_, node, 'IP6')
            self.IP6 = IP6_
        elif nodeName_ == 'IP6_GLOBAL':
            IP6_GLOBAL_ = child_.text
            IP6_GLOBAL_ = self.gds_validate_string(IP6_GLOBAL_, node, 'IP6_GLOBAL')
            self.IP6_GLOBAL = IP6_GLOBAL_
        elif nodeName_ == 'IP6_LINK':
            IP6_LINK_ = child_.text
            IP6_LINK_ = self.gds_validate_string(IP6_LINK_, node, 'IP6_LINK')
            self.IP6_LINK = IP6_LINK_
        elif nodeName_ == 'IP6_ULA':
            IP6_ULA_ = child_.text
            IP6_ULA_ = self.gds_validate_string(IP6_ULA_, node, 'IP6_ULA')
            self.IP6_ULA = IP6_ULA_
        elif nodeName_ == 'MAC':
            MAC_ = child_.text
            MAC_ = self.gds_validate_string(MAC_, node, 'MAC')
            self.MAC = MAC_
        elif nodeName_ == 'VM':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VM')
            self.VM = ival_
        elif nodeName_ == 'VNET':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VNET')
            self.VNET = ival_
        elif nodeName_ == 'VROUTER':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VROUTER')
            self.VROUTER = ival_
# end class LEASEType


class PERMISSIONSType91(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OWNER_U=None, OWNER_M=None, OWNER_A=None, GROUP_U=None, GROUP_M=None, GROUP_A=None, OTHER_U=None, OTHER_M=None, OTHER_A=None):
        self.original_tagname_ = None
        self.OWNER_U = OWNER_U
        self.OWNER_M = OWNER_M
        self.OWNER_A = OWNER_A
        self.GROUP_U = GROUP_U
        self.GROUP_M = GROUP_M
        self.GROUP_A = GROUP_A
        self.OTHER_U = OTHER_U
        self.OTHER_M = OTHER_M
        self.OTHER_A = OTHER_A
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PERMISSIONSType91)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PERMISSIONSType91.subclass:
            return PERMISSIONSType91.subclass(*args_, **kwargs_)
        else:
            return PERMISSIONSType91(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OWNER_U(self): return self.OWNER_U
    def set_OWNER_U(self, OWNER_U): self.OWNER_U = OWNER_U
    def get_OWNER_M(self): return self.OWNER_M
    def set_OWNER_M(self, OWNER_M): self.OWNER_M = OWNER_M
    def get_OWNER_A(self): return self.OWNER_A
    def set_OWNER_A(self, OWNER_A): self.OWNER_A = OWNER_A
    def get_GROUP_U(self): return self.GROUP_U
    def set_GROUP_U(self, GROUP_U): self.GROUP_U = GROUP_U
    def get_GROUP_M(self): return self.GROUP_M
    def set_GROUP_M(self, GROUP_M): self.GROUP_M = GROUP_M
    def get_GROUP_A(self): return self.GROUP_A
    def set_GROUP_A(self, GROUP_A): self.GROUP_A = GROUP_A
    def get_OTHER_U(self): return self.OTHER_U
    def set_OTHER_U(self, OTHER_U): self.OTHER_U = OTHER_U
    def get_OTHER_M(self): return self.OTHER_M
    def set_OTHER_M(self, OTHER_M): self.OTHER_M = OTHER_M
    def get_OTHER_A(self): return self.OTHER_A
    def set_OTHER_A(self, OTHER_A): self.OTHER_A = OTHER_A
    def hasContent_(self):
        if (
            self.OWNER_U is not None or
            self.OWNER_M is not None or
            self.OWNER_A is not None or
            self.GROUP_U is not None or
            self.GROUP_M is not None or
            self.GROUP_A is not None or
            self.OTHER_U is not None or
            self.OTHER_M is not None or
            self.OTHER_A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PERMISSIONSType91', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PERMISSIONSType91')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PERMISSIONSType91')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PERMISSIONSType91', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PERMISSIONSType91'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PERMISSIONSType91', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OWNER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_U>%s</OWNER_U>%s' % (self.gds_format_integer(self.OWNER_U, input_name='OWNER_U'), eol_))
        if self.OWNER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_M>%s</OWNER_M>%s' % (self.gds_format_integer(self.OWNER_M, input_name='OWNER_M'), eol_))
        if self.OWNER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OWNER_A>%s</OWNER_A>%s' % (self.gds_format_integer(self.OWNER_A, input_name='OWNER_A'), eol_))
        if self.GROUP_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_U>%s</GROUP_U>%s' % (self.gds_format_integer(self.GROUP_U, input_name='GROUP_U'), eol_))
        if self.GROUP_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_M>%s</GROUP_M>%s' % (self.gds_format_integer(self.GROUP_M, input_name='GROUP_M'), eol_))
        if self.GROUP_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GROUP_A>%s</GROUP_A>%s' % (self.gds_format_integer(self.GROUP_A, input_name='GROUP_A'), eol_))
        if self.OTHER_U is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_U>%s</OTHER_U>%s' % (self.gds_format_integer(self.OTHER_U, input_name='OTHER_U'), eol_))
        if self.OTHER_M is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_M>%s</OTHER_M>%s' % (self.gds_format_integer(self.OTHER_M, input_name='OTHER_M'), eol_))
        if self.OTHER_A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OTHER_A>%s</OTHER_A>%s' % (self.gds_format_integer(self.OTHER_A, input_name='OTHER_A'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OWNER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_U')
            self.OWNER_U = ival_
        elif nodeName_ == 'OWNER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_M')
            self.OWNER_M = ival_
        elif nodeName_ == 'OWNER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OWNER_A')
            self.OWNER_A = ival_
        elif nodeName_ == 'GROUP_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_U')
            self.GROUP_U = ival_
        elif nodeName_ == 'GROUP_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_M')
            self.GROUP_M = ival_
        elif nodeName_ == 'GROUP_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GROUP_A')
            self.GROUP_A = ival_
        elif nodeName_ == 'OTHER_U':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_U')
            self.OTHER_U = ival_
        elif nodeName_ == 'OTHER_M':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_M')
            self.OTHER_M = ival_
        elif nodeName_ == 'OTHER_A':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OTHER_A')
            self.OTHER_A = ival_
# end class PERMISSIONSType91


class VMSType92(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None):
        self.original_tagname_ = None
        if ID is None:
            self.ID = []
        else:
            self.ID = ID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMSType92)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMSType92.subclass:
            return VMSType92.subclass(*args_, **kwargs_)
        else:
            return VMSType92(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def add_ID(self, value): self.ID.append(value)
    def insert_ID_at(self, index, value): self.ID.insert(index, value)
    def replace_ID_at(self, index, value): self.ID[index] = value
    def hasContent_(self):
        if (
            self.ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMSType92', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VMSType92')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMSType92')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMSType92', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMSType92'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VMSType92', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ID_ in self.ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ID>%s</ID>%s' % (self.gds_format_integer(ID_, input_name='ID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID.append(ival_)
# end class VMSType92


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'HISTORY_RECORDS'
        rootClass = HISTORY_RECORDS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='',
##             pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'HISTORY_RECORDS'
        rootClass = HISTORY_RECORDS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
##     if not silence:
##         content = etree_.tostring(
##             rootElement, pretty_print=True,
##             xml_declaration=True, encoding="utf-8")
##         sys.stdout.write(content)
##         sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'HISTORY_RECORDS'
        rootClass = HISTORY_RECORDS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'HISTORY_RECORDS'
        rootClass = HISTORY_RECORDS
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     if not silence:
##         sys.stdout.write('#from supbind import *\n\n')
##         sys.stdout.write('import supbind as model_\n\n')
##         sys.stdout.write('rootObj = model_.rootClass(\n')
##         rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##         sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ADMINSType",
    "ADMINSType12",
    "APP_CLONESType",
    "ARType",
    "ARType90",
    "AR_POOLType",
    "AR_POOLType89",
    "CLONESType",
    "CLUSTER",
    "CLUSTERSType",
    "CLUSTERSType74",
    "CLUSTERSType85",
    "CLUSTERSType87",
    "CLUSTERType",
    "CLUSTER_POOL",
    "DATASTORE",
    "DATASTORESType",
    "DATASTORESType30",
    "DATASTORESType76",
    "DATASTOREType",
    "DATASTOREType14",
    "DATASTOREType23",
    "DATASTOREType39",
    "DATASTOREType4",
    "DATASTOREType47",
    "DATASTOREType57",
    "DATASTOREType66",
    "DATASTOREType77",
    "DATASTORE_POOL",
    "DATASTORE_QUOTAType",
    "DATASTORE_QUOTAType13",
    "DATASTORE_QUOTAType22",
    "DATASTORE_QUOTAType3",
    "DATASTORE_QUOTAType38",
    "DATASTORE_QUOTAType46",
    "DATASTORE_QUOTAType56",
    "DATASTORE_QUOTAType65",
    "DEFAULT_GROUP_QUOTASType",
    "DEFAULT_GROUP_QUOTASType21",
    "DEFAULT_USER_QUOTASType",
    "DEFAULT_USER_QUOTASType64",
    "DSType",
    "GROUP",
    "GROUPSType",
    "GROUPSType54",
    "GROUPSType73",
    "GROUPType",
    "GROUP_POOL",
    "HISTORY",
    "HISTORYType",
    "HISTORY_RECORDS",
    "HISTORY_RECORDSType",
    "HOST",
    "HOSTSType",
    "HOSTSType75",
    "HOSTType",
    "HOST_POOL",
    "HOST_SHAREType",
    "IMAGE",
    "IMAGESType",
    "IMAGEType",
    "IMAGEType10",
    "IMAGEType20",
    "IMAGEType29",
    "IMAGEType45",
    "IMAGEType53",
    "IMAGEType63",
    "IMAGEType72",
    "IMAGE_POOL",
    "IMAGE_QUOTAType",
    "IMAGE_QUOTAType19",
    "IMAGE_QUOTAType28",
    "IMAGE_QUOTAType44",
    "IMAGE_QUOTAType52",
    "IMAGE_QUOTAType62",
    "IMAGE_QUOTAType71",
    "IMAGE_QUOTAType9",
    "LEASESType",
    "LEASEType",
    "LOGIN_TOKENType",
    "LOGIN_TOKENType55",
    "MARKETPLACE",
    "MARKETPLACEAPP",
    "MARKETPLACEAPPSType",
    "MARKETPLACEAPP_POOL",
    "MARKETPLACE_POOL",
    "NETWORKType",
    "NETWORKType16",
    "NETWORKType25",
    "NETWORKType41",
    "NETWORKType49",
    "NETWORKType59",
    "NETWORKType6",
    "NETWORKType68",
    "NETWORK_QUOTAType",
    "NETWORK_QUOTAType15",
    "NETWORK_QUOTAType24",
    "NETWORK_QUOTAType40",
    "NETWORK_QUOTAType48",
    "NETWORK_QUOTAType5",
    "NETWORK_QUOTAType58",
    "NETWORK_QUOTAType67",
    "PCI_DEVICESType",
    "PERMISSIONSType",
    "PERMISSIONSType1",
    "PERMISSIONSType31",
    "PERMISSIONSType35",
    "PERMISSIONSType36",
    "PERMISSIONSType79",
    "PERMISSIONSType82",
    "PERMISSIONSType84",
    "PERMISSIONSType86",
    "PERMISSIONSType91",
    "QUOTASType",
    "QUOTASType37",
    "SNAPSHOTSType",
    "SNAPSHOTSType33",
    "SNAPSHOTSType80",
    "SNAPSHOTType",
    "SNAPSHOTType34",
    "SNAPSHOTType81",
    "USER",
    "USERSType",
    "USERSType11",
    "USERType",
    "USER_POOL",
    "VDC",
    "VDC_POOL",
    "VM",
    "VMSType",
    "VMSType32",
    "VMSType92",
    "VMTEMPLATE",
    "VMTEMPLATE_POOL",
    "VMType",
    "VMType18",
    "VMType2",
    "VMType27",
    "VMType43",
    "VMType51",
    "VMType61",
    "VMType70",
    "VMType8",
    "VM_POOL",
    "VM_QUOTAType",
    "VM_QUOTAType17",
    "VM_QUOTAType26",
    "VM_QUOTAType42",
    "VM_QUOTAType50",
    "VM_QUOTAType60",
    "VM_QUOTAType69",
    "VM_QUOTAType7",
    "VNET",
    "VNETSType",
    "VNETSType78",
    "VNETType",
    "VNETType83",
    "VNET_POOL",
    "VROUTER",
    "VROUTERSType",
    "VROUTERSType88",
    "VROUTER_POOL"
]
