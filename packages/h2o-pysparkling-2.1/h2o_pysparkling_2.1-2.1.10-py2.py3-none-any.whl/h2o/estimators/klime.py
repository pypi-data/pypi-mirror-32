#!/usr/bin/env python
# -*- encoding: utf-8 -*-
#
# This file is auto-generated by h2o-3/h2o-bindings/bin/gen_python.py
# Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)
#
from __future__ import absolute_import, division, print_function, unicode_literals

from h2o.estimators.estimator_base import H2OEstimator
from h2o.exceptions import H2OValueError
from h2o.frame import H2OFrame
from h2o.utils.typechecks import assert_is_type, Enum, numeric


class H2OKLimeEstimator(H2OEstimator):
    """
    k-LIME

    """

    algo = "klime"

    def __init__(self, **kwargs):
        super(H2OKLimeEstimator, self).__init__()
        self._parms = {}
        names_list = {"model_id", "training_frame", "response_column", "ignored_columns", "max_k", "estimate_k",
                      "alpha", "min_cluster_size", "seed"}
        if "Lambda" in kwargs: kwargs["lambda_"] = kwargs.pop("Lambda")
        for pname, pvalue in kwargs.items():
            if pname == 'model_id':
                self._id = pvalue
                self._parms["model_id"] = pvalue
            elif pname in names_list:
                # Using setattr(...) will invoke type-checking of the arguments
                setattr(self, pname, pvalue)
            else:
                raise H2OValueError("Unknown parameter %s = %r" % (pname, pvalue))

    @property
    def training_frame(self):
        """
        Id of the training data frame (Not required, to allow initial validation of model parameters).

        Type: ``H2OFrame``.
        """
        return self._parms.get("training_frame")

    @training_frame.setter
    def training_frame(self, training_frame):
        assert_is_type(training_frame, None, H2OFrame)
        self._parms["training_frame"] = training_frame


    @property
    def response_column(self):
        """
        Response variable column.

        Type: ``str``.
        """
        return self._parms.get("response_column")

    @response_column.setter
    def response_column(self, response_column):
        assert_is_type(response_column, None, str)
        self._parms["response_column"] = response_column


    @property
    def ignored_columns(self):
        """
        Names of columns to ignore for training.

        Type: ``List[str]``.
        """
        return self._parms.get("ignored_columns")

    @ignored_columns.setter
    def ignored_columns(self, ignored_columns):
        assert_is_type(ignored_columns, None, [str])
        self._parms["ignored_columns"] = ignored_columns


    @property
    def max_k(self):
        """
        Maximum number of clusters to be considered.

        Type: ``int``  (default: ``20``).
        """
        return self._parms.get("max_k")

    @max_k.setter
    def max_k(self, max_k):
        assert_is_type(max_k, None, int)
        self._parms["max_k"] = max_k


    @property
    def estimate_k(self):
        """
        Automatically determine the number of clusters in an unsupervised manner.

        Type: ``bool``  (default: ``True``).
        """
        return self._parms.get("estimate_k")

    @estimate_k.setter
    def estimate_k(self, estimate_k):
        assert_is_type(estimate_k, None, bool)
        self._parms["estimate_k"] = estimate_k


    @property
    def alpha(self):
        """
        Balance between L1 and L2 regularization. Use alpha=0 to switch off L1 variable selection.

        Type: ``float``  (default: ``0.5``).
        """
        return self._parms.get("alpha")

    @alpha.setter
    def alpha(self, alpha):
        assert_is_type(alpha, None, numeric)
        self._parms["alpha"] = alpha


    @property
    def min_cluster_size(self):
        """
        Required minimum cluster size to build a local regression model, smaller clusters will use a global model.

        Type: ``int``  (default: ``20``).
        """
        return self._parms.get("min_cluster_size")

    @min_cluster_size.setter
    def min_cluster_size(self, min_cluster_size):
        assert_is_type(min_cluster_size, None, int)
        self._parms["min_cluster_size"] = min_cluster_size


    @property
    def seed(self):
        """
        Seed for pseudo random number generator (if applicable).

        Type: ``int``  (default: ``-1``).
        """
        return self._parms.get("seed")

    @seed.setter
    def seed(self, seed):
        assert_is_type(seed, None, int)
        self._parms["seed"] = seed


