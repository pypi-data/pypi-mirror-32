# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_connect')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_connect')
    _connect = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_connect', [dirname(__file__)])
        except ImportError:
            import _connect
            return _connect
        if fp is not None:
            try:
                _mod = imp.load_module('_connect', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _connect = swig_import_helper()
    del swig_import_helper
else:
    import _connect
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _connect.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _connect.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _connect.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _connect.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _connect.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _connect.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _connect.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _connect.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _connect.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _connect.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _connect.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _connect.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _connect.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _connect.SHARED_PTR_DISOWN
class ucharArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ucharArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ucharArray, name)
    __repr__ = _swig_repr

    def __init__(self, nelements: 'size_t'):
        this = _connect.new_ucharArray(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_ucharArray
    __del__ = lambda self: None

    def __getitem__(self, index: 'size_t') -> "unsigned char":
        return _connect.ucharArray___getitem__(self, index)

    def __setitem__(self, index: 'size_t', value: 'unsigned char') -> "void":
        return _connect.ucharArray___setitem__(self, index, value)

    def cast(self) -> "unsigned char *":
        return _connect.ucharArray_cast(self)
    if _newclass:
        frompointer = staticmethod(_connect.ucharArray_frompointer)
    else:
        frompointer = _connect.ucharArray_frompointer
ucharArray_swigregister = _connect.ucharArray_swigregister
ucharArray_swigregister(ucharArray)

def ucharArray_frompointer(t: 'unsigned char *') -> "ucharArray *":
    return _connect.ucharArray_frompointer(t)
ucharArray_frompointer = _connect.ucharArray_frompointer

WINVER = _connect.WINVER
class CConnectionConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CConnectionConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CConnectionConfig, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CConnectionConfig()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def workspace(self, workspace: 'std::string const &') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_workspace(self, workspace)

    def udpDiscoveryPort(self, udpDiscoveryPort: 'int') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_udpDiscoveryPort(self, udpDiscoveryPort)

    def instanceId(self, instanceId: 'std::string const &') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_instanceId(self, instanceId)

    def cmdLineParams(self, cmdLineParams: 'std::string const &') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_cmdLineParams(self, cmdLineParams)

    def waitTime(self, waitTime: 'IConnect::ELaunchFlags') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_waitTime(self, waitTime)

    def useIPCDiscovery(self, isUseIPCDiscovery: 'bool') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_useIPCDiscovery(self, isUseIPCDiscovery)

    def visibility(self, visibility: 'IConnect::ELaunchFlags') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_visibility(self, visibility)

    def processId(self, pid: 'DWORD') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_processId(self, pid)

    def processTCPPort(self, wTCPPort: 'WORD') -> "isys::CConnectionConfig &":
        return _connect.CConnectionConfig_processTCPPort(self, wTCPPort)

    def getWorkspace(self) -> "std::string const &":
        return _connect.CConnectionConfig_getWorkspace(self)

    def getUdpDiscoveryPort(self) -> "int":
        return _connect.CConnectionConfig_getUdpDiscoveryPort(self)

    def getInstanceId(self) -> "std::string const &":
        return _connect.CConnectionConfig_getInstanceId(self)

    def getCmdLineParams(self) -> "std::string const &":
        return _connect.CConnectionConfig_getCmdLineParams(self)

    def getWaitTime(self) -> "IConnect::ELaunchFlags":
        return _connect.CConnectionConfig_getWaitTime(self)

    def isUseIPCDiscovery(self) -> "bool":
        return _connect.CConnectionConfig_isUseIPCDiscovery(self)

    def getVisibility(self) -> "IConnect::ELaunchFlags":
        return _connect.CConnectionConfig_getVisibility(self)

    def getProcessId(self) -> "DWORD":
        return _connect.CConnectionConfig_getProcessId(self)

    def getTCPPort(self) -> "WORD":
        return _connect.CConnectionConfig_getTCPPort(self)

    def toString(self) -> "std::string":
        return _connect.CConnectionConfig_toString(self)
    __swig_destroy__ = _connect.delete_CConnectionConfig
    __del__ = lambda self: None
CConnectionConfig_swigregister = _connect.CConnectionConfig_swigregister
CConnectionConfig_swigregister(CConnectionConfig)

class WinIDEAInstanceInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WinIDEAInstanceInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WinIDEAInstanceInfo, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_WinIDEAInstanceInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getWorkspace(self) -> "std::string":
        return _connect.WinIDEAInstanceInfo_getWorkspace(self)

    def getInstanceId(self) -> "std::string":
        return _connect.WinIDEAInstanceInfo_getInstanceId(self)

    def getTcpPort(self) -> "int":
        return _connect.WinIDEAInstanceInfo_getTcpPort(self)
    __swig_destroy__ = _connect.delete_WinIDEAInstanceInfo
    __del__ = lambda self: None
WinIDEAInstanceInfo_swigregister = _connect.WinIDEAInstanceInfo_swigregister
WinIDEAInstanceInfo_swigregister(WinIDEAInstanceInfo)

class ConnectionMgr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionMgr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionMgr, name)
    __repr__ = _swig_repr
    EVersionIgnore = _connect.ConnectionMgr_EVersionIgnore
    EVersionWarning = _connect.ConnectionMgr_EVersionWarning
    EVersionError = _connect.ConnectionMgr_EVersionError

    def __init__(self, *args):
        this = _connect.new_ConnectionMgr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_ConnectionMgr
    __del__ = lambda self: None

    def initLogger(self, id: 'std::string const &', fileName: 'std::string const &', language: 'isys::CLogger::LogFileLanguage') -> "void":
        return _connect.ConnectionMgr_initLogger(self, id, fileName, language)

    def getId(self) -> "std::string const &":
        return _connect.ConnectionMgr_getId(self)

    def getLogger(self) -> "isys::CLogger *":
        return _connect.ConnectionMgr_getLogger(self)

    def connectMRU(self, *args) -> "void":
        return _connect.ConnectionMgr_connectMRU(self, *args)

    def connectMRUEx(self, workspacePath: 'std::string const &', isAnyWinIDEAId: 'bool', winIDEAId: 'std::string const &', hostIpAddress: 'std::string const &', isUseServerEnvVars: 'bool') -> "void":
        return _connect.ConnectionMgr_connectMRUEx(self, workspacePath, isAnyWinIDEAId, winIDEAId, hostIpAddress, isUseServerEnvVars)

    def findExistingInstance(self, address: 'std::string const &', connectionConfig: 'CConnectionConfig') -> "int":
        return _connect.ConnectionMgr_findExistingInstance(self, address, connectionConfig)

    def startNewInstance(self, connectionConfig: 'CConnectionConfig') -> "int":
        return _connect.ConnectionMgr_startNewInstance(self, connectionConfig)

    def findOrStartInstance(self, connectionConfig: 'CConnectionConfig') -> "int":
        return _connect.ConnectionMgr_findOrStartInstance(self, connectionConfig)

    def connect(self, *args) -> "void":
        return _connect.ConnectionMgr_connect(self, *args)

    def isConnected(self) -> "bool":
        return _connect.ConnectionMgr_isConnected(self)

    def enumerateWinIDEAInstances(self, address: 'std::string const &', connectionConfig: 'CConnectionConfig', instances: 'VectorWinIDEAInstanceInfo') -> "void":
        return _connect.ConnectionMgr_enumerateWinIDEAInstances(self, address, connectionConfig, instances)

    def disconnect(self, *args) -> "void":
        return _connect.ConnectionMgr_disconnect(self, *args)

    def inProcessDisconnect(self) -> "void":
        return _connect.ConnectionMgr_inProcessDisconnect(self)

    def isCoreLaunched(self, coreIndex: 'int') -> "bool":
        return _connect.ConnectionMgr_isCoreLaunched(self, coreIndex)

    def launchCore(self, coreIndex: 'int', isPrimaryCoreIndexed: 'bool'=False) -> "std::string":
        return _connect.ConnectionMgr_launchCore(self, coreIndex, isPrimaryCoreIndexed)

    def getIConnectDllVersion(self) -> "isys::CWinIDEAVersion":
        return _connect.ConnectionMgr_getIConnectDllVersion(self)

    def isWarning(self) -> "bool":
        return _connect.ConnectionMgr_isWarning(self)

    def getLastErrorMsg(self) -> "std::string":
        return _connect.ConnectionMgr_getLastErrorMsg(self)

    def isAttached(self) -> "bool":
        return _connect.ConnectionMgr_isAttached(self)
    if _newclass:
        isStartedFromWinIDEA = staticmethod(_connect.ConnectionMgr_isStartedFromWinIDEA)
    else:
        isStartedFromWinIDEA = _connect.ConnectionMgr_isStartedFromWinIDEA
ConnectionMgr_swigregister = _connect.ConnectionMgr_swigregister
ConnectionMgr_swigregister(ConnectionMgr)

def ConnectionMgr_isStartedFromWinIDEA() -> "bool":
    return _connect.ConnectionMgr_isStartedFromWinIDEA()
ConnectionMgr_isStartedFromWinIDEA = _connect.ConnectionMgr_isStartedFromWinIDEA

class CMulticoreConnectionMgr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMulticoreConnectionMgr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CMulticoreConnectionMgr, name)
    __repr__ = _swig_repr

    def connectPrimaryCore(self, *args) -> "isys::ConnectionMgrSPtr":
        return _connect.CMulticoreConnectionMgr_connectPrimaryCore(self, *args)

    def connectCore(self, coreIndex: 'int', coreId: 'std::string const &') -> "isys::ConnectionMgrSPtr":
        return _connect.CMulticoreConnectionMgr_connectCore(self, coreIndex, coreId)

    def getConnectionMgr(self, coreId: 'std::string const &') -> "isys::ConnectionMgrSPtr":
        return _connect.CMulticoreConnectionMgr_getConnectionMgr(self, coreId)

    def isConnected(self, coreId: 'std::string const &') -> "bool":
        return _connect.CMulticoreConnectionMgr_isConnected(self, coreId)

    def disconnect(self, *args) -> "void":
        return _connect.CMulticoreConnectionMgr_disconnect(self, *args)

    def disconnectAll(self) -> "void":
        return _connect.CMulticoreConnectionMgr_disconnectAll(self)

    def getCDebugFacade(self, coreId: 'std::string const &') -> "isys::CDebugFacadeSPtr":
        return _connect.CMulticoreConnectionMgr_getCDebugFacade(self, coreId)

    def getCIDEController(self, coreId: 'std::string const &') -> "isys::CIDEControllerSPtr":
        return _connect.CMulticoreConnectionMgr_getCIDEController(self, coreId)

    def getCExecutionController(self, coreId: 'std::string const &') -> "isys::CExecutionControllerSPtr":
        return _connect.CMulticoreConnectionMgr_getCExecutionController(self, coreId)

    def getCLoaderController(self, coreId: 'std::string const &') -> "isys::CLoaderControllerSPtr":
        return _connect.CMulticoreConnectionMgr_getCLoaderController(self, coreId)

    def getCDataEController2(self, coreId: 'std::string const &') -> "isys::CDataController2SPtr":
        return _connect.CMulticoreConnectionMgr_getCDataEController2(self, coreId)

    def getCDataController2(self, coreId: 'std::string const &') -> "isys::CDataController2SPtr":
        return _connect.CMulticoreConnectionMgr_getCDataController2(self, coreId)

    def getCHILController(self) -> "isys::CHILControllerSPtr":
        return _connect.CMulticoreConnectionMgr_getCHILController(self)

    def getConnectedCoreIDs(self) -> "isys::StrVector":
        return _connect.CMulticoreConnectionMgr_getConnectedCoreIDs(self)

    def __init__(self):
        this = _connect.new_CMulticoreConnectionMgr()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CMulticoreConnectionMgr
    __del__ = lambda self: None
CMulticoreConnectionMgr_swigregister = _connect.CMulticoreConnectionMgr_swigregister
CMulticoreConnectionMgr_swigregister(CMulticoreConnectionMgr)

class CMemAddress(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMemAddress, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CMemAddress, name)
    __repr__ = _swig_repr

    def __init__(self, memArea: 'BYTE', address: 'ADDRESS_64'):
        this = _connect.new_CMemAddress(memArea, address)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getMemArea(self) -> "BYTE":
        return _connect.CMemAddress_getMemArea(self)

    def getAddress(self) -> "ADDRESS_64":
        return _connect.CMemAddress_getAddress(self)

    def toString(self) -> "std::string":
        return _connect.CMemAddress_toString(self)
    __swig_destroy__ = _connect.delete_CMemAddress
    __del__ = lambda self: None
CMemAddress_swigregister = _connect.CMemAddress_swigregister
CMemAddress_swigregister(CMemAddress)

class CSymbolInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSymbolInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSymbolInfo, name)
    __repr__ = _swig_repr

    def __init__(self, memArea: 'BYTE', address: 'ADDRESS_64', sizeMAUs: 'ADDRESS_64', type: 'SType'):
        this = _connect.new_CSymbolInfo(memArea, address, sizeMAUs, type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getMemArea(self) -> "BYTE":
        return _connect.CSymbolInfo_getMemArea(self)

    def getAddress(self) -> "ADDRESS_64":
        return _connect.CSymbolInfo_getAddress(self)

    def getSizeMAUs(self) -> "ADDRESS_64":
        return _connect.CSymbolInfo_getSizeMAUs(self)

    def getMType(self) -> "SType":
        return _connect.CSymbolInfo_getMType(self)

    def toString(self) -> "std::string":
        return _connect.CSymbolInfo_toString(self)
    __swig_destroy__ = _connect.delete_CSymbolInfo
    __del__ = lambda self: None
CSymbolInfo_swigregister = _connect.CSymbolInfo_swigregister
CSymbolInfo_swigregister(CSymbolInfo)

class CLineLocation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CLineLocation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CLineLocation, name)
    __repr__ = _swig_repr

    def __init__(self, fileName: 'std::string const &', lineNumber: 'DWORD'):
        this = _connect.new_CLineLocation(fileName, lineNumber)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getFileName(self) -> "std::string":
        return _connect.CLineLocation_getFileName(self)

    def getLineNumber(self) -> "DWORD":
        return _connect.CLineLocation_getLineNumber(self)

    def toString(self) -> "std::string":
        return _connect.CLineLocation_toString(self)
    __swig_destroy__ = _connect.delete_CLineLocation
    __del__ = lambda self: None
CLineLocation_swigregister = _connect.CLineLocation_swigregister
CLineLocation_swigregister(CLineLocation)

class CLineDescription(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CLineDescription, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CLineDescription, name)
    __repr__ = _swig_repr
    E_RESOURCE_FUNCTION = _connect.CLineDescription_E_RESOURCE_FUNCTION
    E_RESOURCE_FILE = _connect.CLineDescription_E_RESOURCE_FILE
    E_RESOURCE_ADDRESS = _connect.CLineDescription_E_RESOURCE_ADDRESS
    E_SEARCH_ANY = _connect.CLineDescription_E_SEARCH_ANY
    E_SEARCH_CODE = _connect.CLineDescription_E_SEARCH_CODE
    E_SEARCH_COMMENT = _connect.CLineDescription_E_SEARCH_COMMENT
    E_MATCH_PLAIN = _connect.CLineDescription_E_MATCH_PLAIN
    E_MATCH_REG_EX = _connect.CLineDescription_E_MATCH_REG_EX
    E_MATCH_TEST_POINT_ID = _connect.CLineDescription_E_MATCH_TEST_POINT_ID
    ELocalHost = _connect.CLineDescription_ELocalHost
    EWinIDEAHost = _connect.CLineDescription_EWinIDEAHost

    def __init__(self, *args):
        this = _connect.new_CLineDescription(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getResourceType(self) -> "isys::CLineDescription::EResourceType":
        return _connect.CLineDescription_getResourceType(self)

    def getResourceName(self) -> "std::string":
        return _connect.CLineDescription_getResourceName(self)

    def getLine(self) -> "int":
        return _connect.CLineDescription_getLine(self)

    def isSearch(self) -> "bool":
        return _connect.CLineDescription_isSearch(self)

    def getLinesRange(self) -> "int":
        return _connect.CLineDescription_getLinesRange(self)

    def getSearchContext(self) -> "isys::CLineDescription::ESearchContext":
        return _connect.CLineDescription_getSearchContext(self)

    def getMatchingType(self) -> "isys::CLineDescription::EMatchingType":
        return _connect.CLineDescription_getMatchingType(self)

    def getSearchPattern(self) -> "std::string":
        return _connect.CLineDescription_getSearchPattern(self)

    def getLineOffset(self) -> "int":
        return _connect.CLineDescription_getLineOffset(self)

    def getFileLocation(self) -> "isys::CLineDescription::EFileLocation":
        return _connect.CLineDescription_getFileLocation(self)

    def toString(self) -> "std::string":
        return _connect.CLineDescription_toString(self)
    __swig_destroy__ = _connect.delete_CLineDescription
    __del__ = lambda self: None
CLineDescription_swigregister = _connect.CLineDescription_swigregister
CLineDescription_swigregister(CLineDescription)

class CAddressController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CAddressController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CAddressController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CAddressController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CAddressController
    __del__ = lambda self: None

    def getCodeArea(self, bPhysical: 'bool') -> "int":
        return _connect.CAddressController_getCodeArea(self, bPhysical)

    def getFunctionAddress(self, functionName: 'std::string const &') -> "isys::CMemAddress":
        return _connect.CAddressController_getFunctionAddress(self, functionName)

    def getVariableAddress(self, variableName: 'std::string const &') -> "isys::CMemAddress":
        return _connect.CAddressController_getVariableAddress(self, variableName)

    def getExpressionAddress(self, expression: 'std::string const &') -> "isys::CMemAddress":
        return _connect.CAddressController_getExpressionAddress(self, expression)

    def getLabelAddress(self, labelName: 'std::string const &') -> "isys::CMemAddress":
        return _connect.CAddressController_getLabelAddress(self, labelName)

    def getSymbolInfo(self, flags: 'DWORD', expression: 'std::string const &') -> "isys::CSymbolInfo":
        return _connect.CAddressController_getSymbolInfo(self, flags, expression)

    def getSymbolAtAddress(self, *args) -> "std::string":
        return _connect.CAddressController_getSymbolAtAddress(self, *args)

    def getAnySymbolAtAddress(self, symbolTypes: 'DWORD', memArea: 'BYTE', address: 'ADDRESS_64', scope: 'IConnectDebug::ESymbolFlags') -> "std::string":
        return _connect.CAddressController_getAnySymbolAtAddress(self, symbolTypes, memArea, address, scope)

    def getAddressOfSourceLine(self, fileName: 'std::string const &', line: 'int', isReportSize: 'bool'=False) -> "isys::AddressVector":
        return _connect.CAddressController_getAddressOfSourceLine(self, fileName, line, isReportSize)

    def getSourceLineAtAddress(self, *args) -> "isys::CLineLocation":
        return _connect.CAddressController_getSourceLineAtAddress(self, *args)

    def getFunctionNames(self, addresses: 'AddressVector', names: 'StrVector', types: 'IntVector') -> "void":
        return _connect.CAddressController_getFunctionNames(self, addresses, names, types)

    def getSourceLocation(self, *args) -> "isys::CLineLocation":
        return _connect.CAddressController_getSourceLocation(self, *args)
    if _newclass:
        getTestPointIdPrefix = staticmethod(_connect.CAddressController_getTestPointIdPrefix)
    else:
        getTestPointIdPrefix = _connect.CAddressController_getTestPointIdPrefix
CAddressController_swigregister = _connect.CAddressController_swigregister
CAddressController_swigregister(CAddressController)

def CAddressController_getTestPointIdPrefix() -> "std::string":
    return _connect.CAddressController_getTestPointIdPrefix()
CAddressController_getTestPointIdPrefix = _connect.CAddressController_getTestPointIdPrefix

class CBreakpointController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CBreakpointController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CBreakpointController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CBreakpointController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CBreakpointController
    __del__ = lambda self: None

    def setBP(self, *args) -> "int":
        return _connect.CBreakpointController_setBP(self, *args)

    def setHWBP(self, *args) -> "int":
        return _connect.CBreakpointController_setHWBP(self, *args)

    def deleteBP(self, *args) -> "int":
        return _connect.CBreakpointController_deleteBP(self, *args)

    def deleteHWBP(self, *args) -> "int":
        return _connect.CBreakpointController_deleteHWBP(self, *args)

    def deleteAll(self) -> "int":
        return _connect.CBreakpointController_deleteAll(self)

    def deleteAllHWBP(self) -> "int":
        return _connect.CBreakpointController_deleteAllHWBP(self)

    def setEnabled(self, *args) -> "int":
        return _connect.CBreakpointController_setEnabled(self, *args)

    def setHWEnabled(self, *args) -> "int":
        return _connect.CBreakpointController_setHWEnabled(self, *args)

    def setHWEnabledAll(self, isEnabled: 'bool') -> "int":
        return _connect.CBreakpointController_setHWEnabledAll(self, isEnabled)

    def setEnabledAll(self, isEnabled: 'bool') -> "int":
        return _connect.CBreakpointController_setEnabledAll(self, isEnabled)

    def reapplyAll(self) -> "int":
        return _connect.CBreakpointController_reapplyAll(self)
CBreakpointController_swigregister = _connect.CBreakpointController_swigregister
CBreakpointController_swigregister(CBreakpointController)

class CDAQSample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDAQSample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDAQSample, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CDAQSample()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getIndex(self) -> "WORD":
        return _connect.CDAQSample_getIndex(self)

    def getCoreID(self) -> "WORD":
        return _connect.CDAQSample_getCoreID(self)

    def getTime(self) -> "QWORD":
        return _connect.CDAQSample_getTime(self)

    def getData(self) -> "std::vector< BYTE,std::allocator< BYTE > > const &":
        return _connect.CDAQSample_getData(self)
    __swig_destroy__ = _connect.delete_CDAQSample
    __del__ = lambda self: None
CDAQSample_swigregister = _connect.CDAQSample_swigregister
CDAQSample_swigregister(CDAQSample)

class CDAQInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDAQInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDAQInfo, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CDAQInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getMaxItems(self) -> "WORD":
        return _connect.CDAQInfo_getMaxItems(self)

    def getNumItems(self) -> "WORD":
        return _connect.CDAQInfo_getNumItems(self)

    def getBufSize(self) -> "DWORD":
        return _connect.CDAQInfo_getBufSize(self)

    def getTick_ns(self) -> "DWORD":
        return _connect.CDAQInfo_getTick_ns(self)

    def getCoreID(self) -> "BYTE":
        return _connect.CDAQInfo_getCoreID(self)

    def getMaxItemSize(self) -> "BYTE":
        return _connect.CDAQInfo_getMaxItemSize(self)
    __swig_destroy__ = _connect.delete_CDAQInfo
    __del__ = lambda self: None
CDAQInfo_swigregister = _connect.CDAQInfo_swigregister
CDAQInfo_swigregister(CDAQInfo)

class CDAQStatus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDAQStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDAQStatus, name)
    __repr__ = _swig_repr

    def __init__(self, qwTime: 'QWORD', dwLastLoopTime: 'DWORD', dwNumSamplesAvailable: 'DWORD', dwNumLoops: 'DWORD', bOverflow: 'bool', bGlobalEnable: 'bool', bCoreEnable: 'bool'):
        this = _connect.new_CDAQStatus(qwTime, dwLastLoopTime, dwNumSamplesAvailable, dwNumLoops, bOverflow, bGlobalEnable, bCoreEnable)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getTime(self) -> "QWORD":
        return _connect.CDAQStatus_getTime(self)

    def getLastLoopTime(self) -> "DWORD":
        return _connect.CDAQStatus_getLastLoopTime(self)

    def getNumSamplesAvailable(self) -> "DWORD":
        return _connect.CDAQStatus_getNumSamplesAvailable(self)

    def getNumLoops(self) -> "DWORD":
        return _connect.CDAQStatus_getNumLoops(self)

    def getOverflow(self) -> "bool":
        return _connect.CDAQStatus_getOverflow(self)

    def getGlobalEnable(self) -> "bool":
        return _connect.CDAQStatus_getGlobalEnable(self)

    def getCoreEnable(self) -> "bool":
        return _connect.CDAQStatus_getCoreEnable(self)
    __swig_destroy__ = _connect.delete_CDAQStatus
    __del__ = lambda self: None
CDAQStatus_swigregister = _connect.CDAQStatus_swigregister
CDAQStatus_swigregister(CDAQStatus)

class CDAQController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDAQController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDAQController, name)
    __repr__ = _swig_repr
    daqSampleMax = _connect.CDAQController_daqSampleMax
    daqSample1ms = _connect.CDAQController_daqSample1ms
    daqSample10ms = _connect.CDAQController_daqSample10ms
    daqSample100ms = _connect.CDAQController_daqSample100ms
    daqSample1s = _connect.CDAQController_daqSample1s

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CDAQController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CDAQController
    __del__ = lambda self: None

    def attachHW(self) -> "void":
        return _connect.CDAQController_attachHW(self)

    def detachHW(self) -> "void":
        return _connect.CDAQController_detachHW(self)

    def configReset(self) -> "void":
        return _connect.CDAQController_configReset(self)

    def configAdd(self, *args) -> "DWORD":
        return _connect.CDAQController_configAdd(self, *args)

    def configAddDINMask(self, *args) -> "DWORD":
        return _connect.CDAQController_configAddDINMask(self, *args)

    def configAddDIN(self, *args) -> "DWORD":
        return _connect.CDAQController_configAddDIN(self, *args)

    def configAddAIN(self, *args) -> "DWORD":
        return _connect.CDAQController_configAddAIN(self, *args)

    def enableGlobal(self, bEnable: 'bool') -> "void":
        return _connect.CDAQController_enableGlobal(self, bEnable)

    def enableCore(self, bEnable: 'bool') -> "void":
        return _connect.CDAQController_enableCore(self, bEnable)

    def info(self) -> "isys::CDAQInfo":
        return _connect.CDAQController_info(self)

    def status(self) -> "isys::CDAQStatus":
        return _connect.CDAQController_status(self)

    def read(self, rvSamples: 'DAQSampleVector', dwMaxSamples: 'DWORD'=0) -> "void":
        return _connect.CDAQController_read(self, rvSamples, dwMaxSamples)

    def getDataValue(self, rSample: 'CDAQSample') -> "isys::CValueType":
        return _connect.CDAQController_getDataValue(self, rSample)
CDAQController_swigregister = _connect.CDAQController_swigregister
CDAQController_swigregister(CDAQController)

class CValueType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CValueType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CValueType, name)
    __repr__ = _swig_repr
    EDecimal = _connect.CValueType_EDecimal
    EHex = _connect.CValueType_EHex
    EChar = _connect.CValueType_EChar

    def __init__(self, *args):
        this = _connect.new_CValueType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isError(self) -> "bool":
        return _connect.CValueType_isError(self)

    def getType(self) -> "SType const &":
        return _connect.CValueType_getType(self)

    def getValue(self) -> "SValue const &":
        return _connect.CValueType_getValue(self)

    def getResult(self, *args) -> "std::string const":
        return _connect.CValueType_getResult(self, *args)

    def isTypeUnsigned(self) -> "bool":
        return _connect.CValueType_isTypeUnsigned(self)

    def isTypeSigned(self) -> "bool":
        return _connect.CValueType_isTypeSigned(self)

    def isTypeFloat(self) -> "bool":
        return _connect.CValueType_isTypeFloat(self)

    def isTypeAddress(self) -> "bool":
        return _connect.CValueType_isTypeAddress(self)

    def isTypeCompound(self) -> "bool":
        return _connect.CValueType_isTypeCompound(self)

    def getBitSize(self) -> "int":
        return _connect.CValueType_getBitSize(self)

    def getInt(self) -> "int":
        return _connect.CValueType_getInt(self)

    def getLong(self) -> "long long":
        return _connect.CValueType_getLong(self)

    def getFloat(self) -> "float":
        return _connect.CValueType_getFloat(self)

    def getDouble(self) -> "double":
        return _connect.CValueType_getDouble(self)

    def getAddress(self) -> "CAddress":
        return _connect.CValueType_getAddress(self)
    __swig_destroy__ = _connect.delete_CValueType
    __del__ = lambda self: None
CValueType_swigregister = _connect.CValueType_swigregister
CValueType_swigregister(CValueType)

class CVariable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CVariable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CVariable, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CVariable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getName(self) -> "std::string":
        return _connect.CVariable_getName(self)

    def getQualifiedName(self) -> "std::string":
        return _connect.CVariable_getQualifiedName(self)

    def getType(self) -> "std::string":
        return _connect.CVariable_getType(self)

    def getArrayDimension(self) -> "int64_t":
        return _connect.CVariable_getArrayDimension(self)

    def getNumBytes(self) -> "int64_t":
        return _connect.CVariable_getNumBytes(self)

    def getSize(self) -> "int64_t":
        return _connect.CVariable_getSize(self)

    def getTypeAsEnum(self) -> "iEclipse::IVariable::EType":
        return _connect.CVariable_getTypeAsEnum(self)

    def getScope(self) -> "std::string":
        return _connect.CVariable_getScope(self)
    __swig_destroy__ = _connect.delete_CVariable
    __del__ = lambda self: None
CVariable_swigregister = _connect.CVariable_swigregister
CVariable_swigregister(CVariable)

class CFunction(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CFunction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getName(self) -> "std::string":
        return _connect.CFunction_getName(self)

    def getQualifiedName(self) -> "std::string":
        return _connect.CFunction_getQualifiedName(self)

    def getScope(self) -> "std::string":
        return _connect.CFunction_getScope(self)

    def getReturnType(self) -> "std::string":
        return _connect.CFunction_getReturnType(self)

    def getModuleIndex(self) -> "int":
        return _connect.CFunction_getModuleIndex(self)

    def getParameters(self) -> "isys::VariableVector":
        return _connect.CFunction_getParameters(self)

    def getLocalVars(self) -> "isys::VariableVector":
        return _connect.CFunction_getLocalVars(self)

    def getCallsToFunction(self, functionAddresses: 'AddressVector') -> "void":
        return _connect.CFunction_getCallsToFunction(self, functionAddresses)

    def getCallsFromFunction(self, functionAddresses: 'AddressVector') -> "void":
        return _connect.CFunction_getCallsFromFunction(self, functionAddresses)
    __swig_destroy__ = _connect.delete_CFunction
    __del__ = lambda self: None
CFunction_swigregister = _connect.CFunction_swigregister
CFunction_swigregister(CFunction)

class CStackFrame(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CStackFrame, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CStackFrame, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CStackFrame(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getAddress(self) -> "int64_t":
        return _connect.CStackFrame_getAddress(self)

    def getMemArea(self) -> "unsigned char":
        return _connect.CStackFrame_getMemArea(self)

    def getFileName(self) -> "std::string":
        return _connect.CStackFrame_getFileName(self)

    def getLineNumber(self) -> "int":
        return _connect.CStackFrame_getLineNumber(self)

    def getFunction(self) -> "isys::CFunction":
        return _connect.CStackFrame_getFunction(self)

    def getPartition(self) -> "int":
        return _connect.CStackFrame_getPartition(self)
    __swig_destroy__ = _connect.delete_CStackFrame
    __del__ = lambda self: None
CStackFrame_swigregister = _connect.CStackFrame_swigregister
CStackFrame_swigregister(CStackFrame)

class CModule(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CModule, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CModule, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getPath(self) -> "std::string":
        return _connect.CModule_getPath(self)

    def getName(self) -> "std::string":
        return _connect.CModule_getName(self)
    __swig_destroy__ = _connect.delete_CModule
    __del__ = lambda self: None
CModule_swigregister = _connect.CModule_swigregister
CModule_swigregister(CModule)

class CType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getName(self) -> "std::string":
        return _connect.CType_getName(self)

    def getType(self) -> "SType2":
        return _connect.CType_getType(self)
    __swig_destroy__ = _connect.delete_CType
    __del__ = lambda self: None
CType_swigregister = _connect.CType_swigregister
CType_swigregister(CType)

class CTypedef(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTypedef, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTypedef, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CTypedef(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getTypedefName(self) -> "std::string":
        return _connect.CTypedef_getTypedefName(self)

    def getTypeName(self) -> "std::string":
        return _connect.CTypedef_getTypeName(self)
    __swig_destroy__ = _connect.delete_CTypedef
    __del__ = lambda self: None
CTypedef_swigregister = _connect.CTypedef_swigregister
CTypedef_swigregister(CTypedef)

class CMemoryAccess(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMemoryAccess, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CMemoryAccess, name)
    __repr__ = _swig_repr

    def __init__(self, accessInfo: 'BYTE'):
        this = _connect.new_CMemoryAccess(accessInfo)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def canRead(self) -> "bool":
        return _connect.CMemoryAccess_canRead(self)

    def canWrite(self) -> "bool":
        return _connect.CMemoryAccess_canWrite(self)

    def canReadInRealtime(self) -> "bool":
        return _connect.CMemoryAccess_canReadInRealtime(self)

    def canWriteInRealtime(self) -> "bool":
        return _connect.CMemoryAccess_canWriteInRealtime(self)
    __swig_destroy__ = _connect.delete_CMemoryAccess
    __del__ = lambda self: None
CMemoryAccess_swigregister = _connect.CMemoryAccess_swigregister
CMemoryAccess_swigregister(CMemoryAccess)

class CSystemMemoryAreas(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSystemMemoryAreas, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSystemMemoryAreas, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getMemAreaCodeVirtual(self) -> "int":
        return _connect.CSystemMemoryAreas_getMemAreaCodeVirtual(self)

    def getMemAreaCodePhysical(self) -> "int":
        return _connect.CSystemMemoryAreas_getMemAreaCodePhysical(self)

    def getMemAreaDataVirtual(self) -> "int":
        return _connect.CSystemMemoryAreas_getMemAreaDataVirtual(self)

    def getMemAreaDataPhysical(self) -> "int":
        return _connect.CSystemMemoryAreas_getMemAreaDataPhysical(self)

    def getMemAreaSFR(self) -> "int":
        return _connect.CSystemMemoryAreas_getMemAreaSFR(self)
    __swig_destroy__ = _connect.delete_CSystemMemoryAreas
    __del__ = lambda self: None
CSystemMemoryAreas_swigregister = _connect.CSystemMemoryAreas_swigregister
CSystemMemoryAreas_swigregister(CSystemMemoryAreas)

class CStackUsage(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CStackUsage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CStackUsage, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CStackUsage()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getBase(self) -> "ADDRESS_64":
        return _connect.CStackUsage_getBase(self)

    def getSize(self) -> "ADDRESS_64":
        return _connect.CStackUsage_getSize(self)

    def getUsed(self) -> "ADDRESS_64":
        return _connect.CStackUsage_getUsed(self)
    __swig_destroy__ = _connect.delete_CStackUsage
    __del__ = lambda self: None
CStackUsage_swigregister = _connect.CStackUsage_swigregister
CStackUsage_swigregister(CStackUsage)

class CDataController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDataController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDataController, name)
    __repr__ = _swig_repr
    estFunctions = _connect.CDataController_estFunctions
    estGlobalVariables = _connect.CDataController_estGlobalVariables
    estModules = _connect.CDataController_estModules
    PARTITION_DEFAULT = _connect.CDataController_PARTITION_DEFAULT
    PARTITION_CURRENT = _connect.CDataController_PARTITION_CURRENT

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CDataController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CDataController
    __del__ = lambda self: None

    def getCPUInfo(self) -> "CCPUInfo":
        return _connect.CDataController_getCPUInfo(self)

    def getMemoryAreaBytesPerMAU(self, memArea: 'int') -> "int":
        return _connect.CDataController_getMemoryAreaBytesPerMAU(self, memArea)

    def readMemory(self, accessFlags: 'IConnectDebug::EAccessFlags', memArea: 'BYTE', aAddress: 'ADDRESS_64', aNumMAUs: 'ADDRESS_64', bytesPerMAU: 'BYTE') -> "std::vector< BYTE,std::allocator< BYTE > >":
        return _connect.CDataController_readMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU)

    def writeMemory(self, accessFlags: 'IConnectDebug::EAccessFlags', memArea: 'BYTE', aAddress: 'ADDRESS_64', aNumMAUs: 'ADDRESS_64', bytesPerMAU: 'BYTE', buff: 'VectorBYTE') -> "std::vector< BYTE,std::allocator< BYTE > >":
        return _connect.CDataController_writeMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def writeMemoryNAI(self, accessFlags: 'IConnectDebug::EAccessFlags', memArea: 'BYTE', aAddress: 'ADDRESS_64', aNumMAUs: 'ADDRESS_64', bytesPerMAU: 'BYTE', buff: 'VectorBYTE') -> "void":
        return _connect.CDataController_writeMemoryNAI(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def readRegister(self, accessFlags: 'IConnectDebug::EAccessFlags', registerName: 'std::string const &') -> "isys::CValueType":
        return _connect.CDataController_readRegister(self, accessFlags, registerName)

    def writeRegister(self, accessFlags: 'IConnectDebug::EAccessFlags', registerName: 'std::string const &', registerInfo: 'CValueType') -> "void":
        return _connect.CDataController_writeRegister(self, accessFlags, registerName, registerInfo)

    def readValue(self, accessFlags: 'IConnectDebug::EAccessFlags', memArea: 'BYTE', aAddress: 'ADDRESS_64', type: 'SType') -> "isys::CValueType":
        return _connect.CDataController_readValue(self, accessFlags, memArea, aAddress, type)

    def writeValue(self, *args) -> "void":
        return _connect.CDataController_writeValue(self, *args)

    def evaluate(self, *args) -> "isys::CValueType":
        return _connect.CDataController_evaluate(self, *args)

    def modify(self, *args) -> "std::string":
        return _connect.CDataController_modify(self, *args)

    def batchAccess(self, dwBatchAccessFlags: 'DWORD', pBatchAccessHeader: 'SBatchAccessHeader', batchAccessItems: 'VectorBatchAccessItem', batchAccessItemResults: 'VectorBatchAccessResult') -> "bool":
        return _connect.CDataController_batchAccess(self, dwBatchAccessFlags, pBatchAccessHeader, batchAccessItems, batchAccessItemResults)

    def jtagScan(self, dwScanFlags: 'DWORD', dwNumBits: 'DWORD', tdi: 'VectorBYTE', isOutputRequested: 'bool', tdo: 'VectorBYTE') -> "void":
        return _connect.CDataController_jtagScan(self, dwScanFlags, dwNumBits, tdi, isOutputRequested, tdo)

    def setJtagLine(self, line: 'DWORD', level: 'BYTE') -> "void":
        return _connect.CDataController_setJtagLine(self, line, level)

    def writeOCDRegister(self, dwRegAddress: 'DWORD', dwNumBits: 'DWORD', data: 'VectorBYTE') -> "void":
        return _connect.CDataController_writeOCDRegister(self, dwRegAddress, dwNumBits, data)

    def readOCDRegister(self, dwRegAddress: 'DWORD', dwNumBits: 'DWORD', data: 'VectorBYTE') -> "void":
        return _connect.CDataController_readOCDRegister(self, dwRegAddress, dwNumBits, data)

    def setOcdPortTristate(self, isTristate: 'bool') -> "void":
        return _connect.CDataController_setOcdPortTristate(self, isTristate)

    def eraseFlash(self, nDevice: 'int'=-1) -> "void":
        return _connect.CDataController_eraseFlash(self, nDevice)

    def secureFlash(self, nDevice: 'int'=-1) -> "void":
        return _connect.CDataController_secureFlash(self, nDevice)

    def unsecureFlash(self, nDevice: 'int'=-1) -> "void":
        return _connect.CDataController_unsecureFlash(self, nDevice)
    if _newclass:
        setByte = staticmethod(_connect.CDataController_setByte)
    else:
        setByte = _connect.CDataController_setByte
    if _newclass:
        getByte = staticmethod(_connect.CDataController_getByte)
    else:
        getByte = _connect.CDataController_getByte
    if _newclass:
        byteArrayToVector = staticmethod(_connect.CDataController_byteArrayToVector)
    else:
        byteArrayToVector = _connect.CDataController_byteArrayToVector
    if _newclass:
        vectorToByteArray = staticmethod(_connect.CDataController_vectorToByteArray)
    else:
        vectorToByteArray = _connect.CDataController_vectorToByteArray

    def getSymbols(self, *args) -> "void":
        return _connect.CDataController_getSymbols(self, *args)

    def getStackFrames(self, isActiveFrameOnly: 'bool', isAbsPaths: 'bool', stackFrames: 'StackFrameVector') -> "void":
        return _connect.CDataController_getStackFrames(self, isActiveFrameOnly, isAbsPaths, stackFrames)

    def getVariables(self, partition: 'int', variables: 'VariableVector') -> "void":
        return _connect.CDataController_getVariables(self, partition, variables)

    def getLabels(self, partition: 'int', labels: 'VariableVector') -> "void":
        return _connect.CDataController_getLabels(self, partition, labels)

    def getModules(self, partition: 'int', modules: 'ModuleVector') -> "void":
        return _connect.CDataController_getModules(self, partition, modules)

    def getFunctions(self, partition: 'int', functions: 'FunctionVector') -> "void":
        return _connect.CDataController_getFunctions(self, partition, functions)

    def getTypes(self, partition: 'int', types: 'TypeVector') -> "void":
        return _connect.CDataController_getTypes(self, partition, types)

    def getTypedefs(self, partition: 'int', typedefs: 'TypedefVector') -> "void":
        return _connect.CDataController_getTypedefs(self, partition, typedefs)

    def getPartitions(self, paths: 'StrVector', fileNames: 'StrVector') -> "void":
        return _connect.CDataController_getPartitions(self, paths, fileNames)

    def getMacros(self, partition: 'int', names: 'StrVector', values: 'StrVector') -> "void":
        return _connect.CDataController_getMacros(self, partition, names, values)

    def canAccessMemory(self) -> "isys::CMemoryAccess":
        return _connect.CDataController_canAccessMemory(self)

    def getSystemMemoryAreas(self) -> "isys::CSystemMemoryAreas":
        return _connect.CDataController_getSystemMemoryAreas(self)

    def getDefaultEndian(self) -> "EEndian":
        return _connect.CDataController_getDefaultEndian(self)

    def getStackUsage(self) -> "isys::CStackUsage":
        return _connect.CDataController_getStackUsage(self)

    def seedStack(self) -> "void":
        return _connect.CDataController_seedStack(self)

    def configureStackUsage(self, *args) -> "void":
        return _connect.CDataController_configureStackUsage(self, *args)

    def csCreate(self) -> "isys::CCodeStoreSPtr":
        return _connect.CDataController_csCreate(self)

    def csGetDownloaded(self, memArea: 'BYTE', fileDownload: 'std::string const &', data: 'bool') -> "isys::CCodeStoreSPtr":
        return _connect.CDataController_csGetDownloaded(self, memArea, fileDownload, data)

    def csReadMemory(self, memArea: 'BYTE', rspSource: 'isys::CCodeStoreSPtr const &') -> "isys::CCodeStoreSPtr":
        return _connect.CDataController_csReadMemory(self, memArea, rspSource)

    def csVerifyDownloaded(self, memArea: 'BYTE', fileDownload: 'std::string const &', fileReport: 'std::string const &') -> "isys::CCodeStoreSPtr":
        return _connect.CDataController_csVerifyDownloaded(self, memArea, fileDownload, fileReport)

    def csDif(self, rsp1: 'isys::CCodeStoreSPtr const &', rsp2: 'isys::CCodeStoreSPtr const &', flDifferent: 'bool'=True, flNotIn1: 'bool'=True, flNotIn2: 'bool'=True, flEqual: 'bool'=False) -> "isys::CCodeStoreSPtr":
        return _connect.CDataController_csDif(self, rsp1, rsp2, flDifferent, flNotIn1, flNotIn2, flEqual)
CDataController_swigregister = _connect.CDataController_swigregister
CDataController_swigregister(CDataController)

def CDataController_setByte(array: 'BYTE *', idx: 'int', value: 'BYTE') -> "void":
    return _connect.CDataController_setByte(array, idx, value)
CDataController_setByte = _connect.CDataController_setByte

def CDataController_getByte(array: 'BYTE *', idx: 'int') -> "BYTE":
    return _connect.CDataController_getByte(array, idx)
CDataController_getByte = _connect.CDataController_getByte

def CDataController_byteArrayToVector(array: 'BYTE *', len: 'size_t') -> "std::vector< BYTE,std::allocator< BYTE > >":
    return _connect.CDataController_byteArrayToVector(array, len)
CDataController_byteArrayToVector = _connect.CDataController_byteArrayToVector

def CDataController_vectorToByteArray(buff: 'VectorBYTE', array: 'BYTE *', size: 'size_t') -> "void":
    return _connect.CDataController_vectorToByteArray(buff, array, size)
CDataController_vectorToByteArray = _connect.CDataController_vectorToByteArray

class CRegisterInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CRegisterInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CRegisterInfo, name)
    __repr__ = _swig_repr

    def __init__(self, regName: 'TCHAR *', type: 'SType'):
        this = _connect.new_CRegisterInfo(regName, type)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getRegisterName(self) -> "std::string":
        return _connect.CRegisterInfo_getRegisterName(self)

    def getType(self) -> "SType":
        return _connect.CRegisterInfo_getType(self)
    __swig_destroy__ = _connect.delete_CRegisterInfo
    __del__ = lambda self: None
CRegisterInfo_swigregister = _connect.CRegisterInfo_swigregister
CRegisterInfo_swigregister(CRegisterInfo)

class SDisassemblyLine(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SDisassemblyLine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SDisassemblyLine, name)
    __repr__ = _swig_repr
    __swig_setmethods__["address"] = _connect.SDisassemblyLine_address_set
    __swig_getmethods__["address"] = _connect.SDisassemblyLine_address_get
    if _newclass:
        address = _swig_property(_connect.SDisassemblyLine_address_get, _connect.SDisassemblyLine_address_set)
    __swig_setmethods__["opCode"] = _connect.SDisassemblyLine_opCode_set
    __swig_getmethods__["opCode"] = _connect.SDisassemblyLine_opCode_get
    if _newclass:
        opCode = _swig_property(_connect.SDisassemblyLine_opCode_get, _connect.SDisassemblyLine_opCode_set)
    __swig_setmethods__["opCodeArgs"] = _connect.SDisassemblyLine_opCodeArgs_set
    __swig_getmethods__["opCodeArgs"] = _connect.SDisassemblyLine_opCodeArgs_get
    if _newclass:
        opCodeArgs = _swig_property(_connect.SDisassemblyLine_opCodeArgs_get, _connect.SDisassemblyLine_opCodeArgs_set)
    __swig_setmethods__["fileName"] = _connect.SDisassemblyLine_fileName_set
    __swig_getmethods__["fileName"] = _connect.SDisassemblyLine_fileName_get
    if _newclass:
        fileName = _swig_property(_connect.SDisassemblyLine_fileName_get, _connect.SDisassemblyLine_fileName_set)
    __swig_setmethods__["lineNumber"] = _connect.SDisassemblyLine_lineNumber_set
    __swig_getmethods__["lineNumber"] = _connect.SDisassemblyLine_lineNumber_get
    if _newclass:
        lineNumber = _swig_property(_connect.SDisassemblyLine_lineNumber_get, _connect.SDisassemblyLine_lineNumber_set)
    __swig_setmethods__["functionName"] = _connect.SDisassemblyLine_functionName_set
    __swig_getmethods__["functionName"] = _connect.SDisassemblyLine_functionName_get
    if _newclass:
        functionName = _swig_property(_connect.SDisassemblyLine_functionName_get, _connect.SDisassemblyLine_functionName_set)
    __swig_setmethods__["functionOffset"] = _connect.SDisassemblyLine_functionOffset_set
    __swig_getmethods__["functionOffset"] = _connect.SDisassemblyLine_functionOffset_get
    if _newclass:
        functionOffset = _swig_property(_connect.SDisassemblyLine_functionOffset_get, _connect.SDisassemblyLine_functionOffset_set)
    __swig_setmethods__["branchTarget"] = _connect.SDisassemblyLine_branchTarget_set
    __swig_getmethods__["branchTarget"] = _connect.SDisassemblyLine_branchTarget_get
    if _newclass:
        branchTarget = _swig_property(_connect.SDisassemblyLine_branchTarget_get, _connect.SDisassemblyLine_branchTarget_set)
    __swig_setmethods__["length"] = _connect.SDisassemblyLine_length_set
    __swig_getmethods__["length"] = _connect.SDisassemblyLine_length_get
    if _newclass:
        length = _swig_property(_connect.SDisassemblyLine_length_get, _connect.SDisassemblyLine_length_set)
    __swig_setmethods__["isBranch"] = _connect.SDisassemblyLine_isBranch_set
    __swig_getmethods__["isBranch"] = _connect.SDisassemblyLine_isBranch_get
    if _newclass:
        isBranch = _swig_property(_connect.SDisassemblyLine_isBranch_get, _connect.SDisassemblyLine_isBranch_set)
    __swig_setmethods__["isCall"] = _connect.SDisassemblyLine_isCall_set
    __swig_getmethods__["isCall"] = _connect.SDisassemblyLine_isCall_get
    if _newclass:
        isCall = _swig_property(_connect.SDisassemblyLine_isCall_get, _connect.SDisassemblyLine_isCall_set)
    __swig_setmethods__["isConditional"] = _connect.SDisassemblyLine_isConditional_set
    __swig_getmethods__["isConditional"] = _connect.SDisassemblyLine_isConditional_get
    if _newclass:
        isConditional = _swig_property(_connect.SDisassemblyLine_isConditional_get, _connect.SDisassemblyLine_isConditional_set)
    __swig_setmethods__["isIndirect"] = _connect.SDisassemblyLine_isIndirect_set
    __swig_getmethods__["isIndirect"] = _connect.SDisassemblyLine_isIndirect_get
    if _newclass:
        isIndirect = _swig_property(_connect.SDisassemblyLine_isIndirect_get, _connect.SDisassemblyLine_isIndirect_set)

    def __init__(self, *args):
        this = _connect.new_SDisassemblyLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SDisassemblyLine
    __del__ = lambda self: None
SDisassemblyLine_swigregister = _connect.SDisassemblyLine_swigregister
SDisassemblyLine_swigregister(SDisassemblyLine)

class CDataComposite(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDataComposite, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDataComposite, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CDataComposite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getVariable(self) -> "isys::CVariable":
        return _connect.CDataComposite_getVariable(self)

    def isValueSet(self) -> "bool":
        return _connect.CDataComposite_isValueSet(self)

    def getValue(self) -> "isys::CValueType":
        return _connect.CDataComposite_getValue(self)

    def getChildren(self, children: 'VectorDataComposite') -> "void":
        return _connect.CDataComposite_getChildren(self, children)
    __swig_destroy__ = _connect.delete_CDataComposite
    __del__ = lambda self: None
CDataComposite_swigregister = _connect.CDataComposite_swigregister
CDataComposite_swigregister(CDataComposite)

class CDataController2(CDataController):
    __swig_setmethods__ = {}
    for _s in [CDataController]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDataController2, name, value)
    __swig_getmethods__ = {}
    for _s in [CDataController]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CDataController2, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CDataController2(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CDataController2
    __del__ = lambda self: None

    def getTargetInfo(self) -> "iEclipse::SInfo":
        return _connect.CDataController2_getTargetInfo(self)

    def getRegisterInfo(self, registerIdx: 'int') -> "isys::CRegisterInfo":
        return _connect.CDataController2_getRegisterInfo(self, registerIdx)

    def getDisassembly(self, *args) -> "iEclipse::IDisassemblyBlock *":
        return _connect.CDataController2_getDisassembly(self, *args)

    def getStackFrameInfo(self, isActiveFrameOnly: 'bool', isAbsolutePath: 'bool') -> "iEclipse::IStackFrameInfo *":
        return _connect.CDataController2_getStackFrameInfo(self, isActiveFrameOnly, isAbsolutePath)

    def release(self, *args) -> "void":
        return _connect.CDataController2_release(self, *args)

    def setStackFrameContext(self, flags: 'DWORD', context: 'DWORD') -> "void":
        return _connect.CDataController2_setStackFrameContext(self, flags, context)

    def getExpressionType(self, flags: 'DWORD', expression: 'std::string const &') -> "iEclipse::IExpressionType *":
        return _connect.CDataController2_getExpressionType(self, flags, expression)

    def getGlobals(self, flags: 'DWORD', partition: 'DWORD') -> "iEclipse::IGlobals *":
        return _connect.CDataController2_getGlobals(self, flags, partition)

    def getConfiguration(self, flags: 'DWORD') -> "iEclipse::IConfiguration *":
        return _connect.CDataController2_getConfiguration(self, flags)

    def getCPUSFRs(self, flags: 'DWORD') -> "iEclipse::ICPUSFR *":
        return _connect.CDataController2_getCPUSFRs(self, flags)

    def readSFR(self, dwHandle: 'DWORD', type: 'SType') -> "isys::CValueType":
        return _connect.CDataController2_readSFR(self, dwHandle, type)

    def writeSFR(self, flags: 'DWORD', dwHandle: 'DWORD', value: 'CValueType') -> "isys::CValueType":
        return _connect.CDataController2_writeSFR(self, flags, dwHandle, value)

    def evaluateComposite(self, accessFlags: 'IConnectDebug::EAccessFlags', expression: 'std::string const &', isGetValue: 'bool', maxArrayElements: 'int') -> "isys::CDataCompositeSPtr":
        return _connect.CDataController2_evaluateComposite(self, accessFlags, expression, isGetValue, maxArrayElements)
CDataController2_swigregister = _connect.CDataController2_swigregister
CDataController2_swigregister(CDataController2)

class CPUStatus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPUStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CPUStatus, name)
    __repr__ = _swig_repr

    def __init__(self, isStopReasonAvailable: 'bool'):
        this = _connect.new_CPUStatus(isStopReasonAvailable)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isMustInit(self) -> "bool":
        return _connect.CPUStatus_isMustInit(self)

    def isStopped(self) -> "bool":
        return _connect.CPUStatus_isStopped(self)

    def isRunning(self) -> "bool":
        return _connect.CPUStatus_isRunning(self)

    def isReset(self) -> "bool":
        return _connect.CPUStatus_isReset(self)

    def isHalted(self) -> "bool":
        return _connect.CPUStatus_isHalted(self)

    def isWaiting(self) -> "bool":
        return _connect.CPUStatus_isWaiting(self)

    def isAttach(self) -> "bool":
        return _connect.CPUStatus_isAttach(self)

    def isIdle(self) -> "bool":
        return _connect.CPUStatus_isIdle(self)

    def isStopReasonExplicit(self) -> "bool":
        return _connect.CPUStatus_isStopReasonExplicit(self)

    def isStopReasonBP(self) -> "bool":
        return _connect.CPUStatus_isStopReasonBP(self)

    def isStopReasonStep(self) -> "bool":
        return _connect.CPUStatus_isStopReasonStep(self)

    def isStopReasonHW(self) -> "bool":
        return _connect.CPUStatus_isStopReasonHW(self)

    def getExecutionPoint(self) -> "ADDRESS_64":
        return _connect.CPUStatus_getExecutionPoint(self)

    def getExecutionArea(self) -> "BYTE":
        return _connect.CPUStatus_getExecutionArea(self)

    def toString(self) -> "std::string":
        return _connect.CPUStatus_toString(self)
    __swig_destroy__ = _connect.delete_CPUStatus
    __del__ = lambda self: None
CPUStatus_swigregister = _connect.CPUStatus_swigregister
CPUStatus_swigregister(CPUStatus)

class CExecutionController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CExecutionController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CExecutionController, name)
    __repr__ = _swig_repr
    TOUT_NONE = _connect.CExecutionController_TOUT_NONE
    TOUT_1s = _connect.CExecutionController_TOUT_1s
    TOUT_10s = _connect.CExecutionController_TOUT_10s
    TOUT_100s = _connect.CExecutionController_TOUT_100s
    TOUT_INF = _connect.CExecutionController_TOUT_INF

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CExecutionController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CExecutionController
    __del__ = lambda self: None

    def getIConnectDebug(self) -> "IConnectDebug *":
        return _connect.CExecutionController_getIConnectDebug(self)

    def hotAttach(self) -> "int":
        return _connect.CExecutionController_hotAttach(self)

    def hotDetach(self) -> "int":
        return _connect.CExecutionController_hotDetach(self)

    def run(self, *args) -> "int":
        return _connect.CExecutionController_run(self, *args)

    def runUntilReturn(self, *args) -> "int":
        return _connect.CExecutionController_runUntilReturn(self, *args)

    def runUntilAddress(self, *args) -> "int":
        return _connect.CExecutionController_runUntilAddress(self, *args)

    def runUntilFunction(self, *args) -> "int":
        return _connect.CExecutionController_runUntilFunction(self, *args)

    def setSlowRun(self, isSlowRun: 'bool') -> "int":
        return _connect.CExecutionController_setSlowRun(self, isSlowRun)

    def gotoAddress(self, memArea: 'BYTE', address: 'ADDRESS_64') -> "void":
        return _connect.CExecutionController_gotoAddress(self, memArea, address)

    def gotoFunction(self, functionName: 'std::string const &') -> "void":
        return _connect.CExecutionController_gotoFunction(self, functionName)

    def reset(self, *args) -> "void":
        return _connect.CExecutionController_reset(self, *args)

    def resetAndRun(self, *args) -> "int":
        return _connect.CExecutionController_resetAndRun(self, *args)

    def stop(self) -> "void":
        return _connect.CExecutionController_stop(self)

    def stepHigh(self, *args) -> "int":
        return _connect.CExecutionController_stepHigh(self, *args)

    def stepOverHigh(self, *args) -> "int":
        return _connect.CExecutionController_stepOverHigh(self, *args)

    def stepInst(self, *args) -> "int":
        return _connect.CExecutionController_stepInst(self, *args)

    def stepOverInst(self, *args) -> "int":
        return _connect.CExecutionController_stepOverInst(self, *args)

    def call(self, *args) -> "std::string":
        return _connect.CExecutionController_call(self, *args)

    def getCPUStatus(self, wantStopReason: 'bool'=True) -> "isys::CPUStatus":
        return _connect.CExecutionController_getCPUStatus(self, wantStopReason)

    def setPollingEnabled(self, isEnabled: 'bool') -> "void":
        return _connect.CExecutionController_setPollingEnabled(self, isEnabled)

    def setBlueBoxTristateStatus(self, isTristate: 'bool') -> "void":
        return _connect.CExecutionController_setBlueBoxTristateStatus(self, isTristate)

    def setBlueBoxTargetConnection(self, isConnected: 'bool') -> "void":
        return _connect.CExecutionController_setBlueBoxTargetConnection(self, isConnected)

    def waitUntilStopped(self, timeout: 'int'=0, pollingInterval: 'DWORD'=100, isThrow: 'bool'=False) -> "bool":
        return _connect.CExecutionController_waitUntilStopped(self, timeout, pollingInterval, isThrow)

    def waitWhileRunning(self, timeout: 'int', pollingInterval: 'DWORD'=100, isThrow: 'bool'=False) -> "bool":
        return _connect.CExecutionController_waitWhileRunning(self, timeout, pollingInterval, isThrow)
CExecutionController_swigregister = _connect.CExecutionController_swigregister
CExecutionController_swigregister(CExecutionController)

class CHILChannel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CHILChannel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CHILChannel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CHILChannel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getName(self) -> "std::string":
        return _connect.CHILChannel_getName(self)

    def getQualifiedName(self) -> "std::string":
        return _connect.CHILChannel_getQualifiedName(self)

    def isAvailable(self) -> "bool":
        return _connect.CHILChannel_isAvailable(self)

    def getType(self) -> "DWORD":
        return _connect.CHILChannel_getType(self)

    def getIndex(self) -> "DWORD":
        return _connect.CHILChannel_getIndex(self)

    def getUnit(self) -> "std::string":
        return _connect.CHILChannel_getUnit(self)

    def getAMin(self) -> "double":
        return _connect.CHILChannel_getAMin(self)

    def getAMax(self) -> "double":
        return _connect.CHILChannel_getAMax(self)
    __swig_destroy__ = _connect.delete_CHILChannel
    __del__ = lambda self: None
CHILChannel_swigregister = _connect.CHILChannel_swigregister
CHILChannel_swigregister(CHILChannel)

class CHILController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CHILController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CHILController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CHILController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CHILController
    __del__ = lambda self: None

    def read(self, paths: 'std::string const &', bufferSize: 'DWORD'=4096, dwFlags: 'DWORD'=0, dwGenParam: 'DWORD'=0) -> "std::string":
        return _connect.CHILController_read(self, paths, bufferSize, dwFlags, dwGenParam)

    def write(self, values: 'std::string const &', dwFlags: 'DWORD'=0, dwGenParam: 'DWORD'=0) -> "void":
        return _connect.CHILController_write(self, values, dwFlags, dwGenParam)

    def getDescriptors(self) -> "DataDescriptor::IItemDescriptors const *":
        return _connect.CHILController_getDescriptors(self)

    def getChannels(self, channels: 'HILChannelVector') -> "void":
        return _connect.CHILController_getChannels(self, channels)
CHILController_swigregister = _connect.CHILController_swigregister
CHILController_swigregister(CHILController)

class CMPC5xxxController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMPC5xxxController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CMPC5xxxController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CMPC5xxxController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CMPC5xxxController
    __del__ = lambda self: None

    def getTLB(self, dwEntry: 'DWORD') -> "DebugService_MPC55xx::STLBEntry":
        return _connect.CMPC5xxxController_getTLB(self, dwEntry)

    def setTLB(self, dwEntry: 'DWORD', rTLBEntry: 'STLBEntry') -> "void":
        return _connect.CMPC5xxxController_setTLB(self, dwEntry, rTLBEntry)
CMPC5xxxController_swigregister = _connect.CMPC5xxxController_swigregister
CMPC5xxxController_swigregister(CMPC5xxxController)

class CIDEData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CIDEData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CIDEData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getLeft(self) -> "LONG":
        return _connect.CIDEData_getLeft(self)

    def getTop(self) -> "LONG":
        return _connect.CIDEData_getTop(self)

    def getRight(self) -> "LONG":
        return _connect.CIDEData_getRight(self)

    def getBottom(self) -> "LONG":
        return _connect.CIDEData_getBottom(self)

    def getPID(self) -> "DWORD":
        return _connect.CIDEData_getPID(self)
    __swig_destroy__ = _connect.delete_CIDEData
    __del__ = lambda self: None
CIDEData_swigregister = _connect.CIDEData_swigregister
CIDEData_swigregister(CIDEData)
cvar = _connect.cvar
POSTFIX_ENABLE_PROFILER = cvar.POSTFIX_ENABLE_PROFILER
POSTFIX_ENABLE_COVERAGE = cvar.POSTFIX_ENABLE_COVERAGE
OPT_VAL_TRUE = cvar.OPT_VAL_TRUE
OPT_VAL_FALSE = cvar.OPT_VAL_FALSE

class CIDECapabilities(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CIDECapabilities, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CIDECapabilities, name)
    __repr__ = _swig_repr

    def __init__(self, capabilities: 'DWORD'):
        this = _connect.new_CIDECapabilities(capabilities)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isDebugAvailable(self) -> "bool":
        return _connect.CIDECapabilities_isDebugAvailable(self)

    def isTraceAvailable(self) -> "bool":
        return _connect.CIDECapabilities_isTraceAvailable(self)

    def isCoverageAvailable(self) -> "bool":
        return _connect.CIDECapabilities_isCoverageAvailable(self)

    def isProfilerAvailable(self) -> "bool":
        return _connect.CIDECapabilities_isProfilerAvailable(self)
    __swig_destroy__ = _connect.delete_CIDECapabilities
    __del__ = lambda self: None
CIDECapabilities_swigregister = _connect.CIDECapabilities_swigregister
CIDECapabilities_swigregister(CIDECapabilities)

class COptionValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, COptionValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, COptionValue, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_COptionValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_COptionValue
    __del__ = lambda self: None

    def initOutBuffer(self) -> "void":
        return _connect.COptionValue_initOutBuffer(self)

    def setSeparators(self, pathSeparator: 'char'=0, valueSeparator: 'char'=0, optionSeparator: 'char'=0) -> "void":
        return _connect.COptionValue_setSeparators(self, pathSeparator, valueSeparator, optionSeparator)

    def allocOutputBuffer(self, bufferSize: 'DWORD') -> "void":
        return _connect.COptionValue_allocOutputBuffer(self, bufferSize)

    def getOutputBuffer(self) -> "char *":
        return _connect.COptionValue_getOutputBuffer(self)

    def getOptionValue(self) -> "SOptionValue *":
        return _connect.COptionValue_getOptionValue(self)
COptionValue_swigregister = _connect.COptionValue_swigregister
COptionValue_swigregister(COptionValue)

class CIDEController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CIDEController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CIDEController, name)
    __repr__ = _swig_repr
    HOOK_NONE = _connect.CIDEController_HOOK_NONE
    HOOK_ICONNECT_CALL = _connect.CIDEController_HOOK_ICONNECT_CALL
    HOOK_ALL = _connect.CIDEController_HOOK_ALL
    WINIDEA_EXE_DIR = _connect.CIDEController_WINIDEA_EXE_DIR
    WORKSPACE_DIR = _connect.CIDEController_WORKSPACE_DIR
    WORKSPACE_FILE_NAME = _connect.CIDEController_WORKSPACE_FILE_NAME
    EDebugAPI = _connect.CIDEController_EDebugAPI
    EAnalyzerAPI = _connect.CIDEController_EAnalyzerAPI
    EiTestAPI = _connect.CIDEController_EiTestAPI

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CIDEController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CIDEController
    __del__ = lambda self: None

    def getWinIDEAVersion(self) -> "isys::CWinIDEAVersion":
        return _connect.CIDEController_getWinIDEAVersion(self)

    def isWinIDEAOpenVersion(self) -> "bool":
        return _connect.CIDEController_isWinIDEAOpenVersion(self)

    def isAPICompatible(self, apiCategory: 'isys::CIDEController::EAPICategory') -> "bool":
        return _connect.CIDEController_isAPICompatible(self, apiCategory)

    def getPath(self, pathType: 'isys::CIDEController::EPathType') -> "std::string":
        return _connect.CIDEController_getPath(self, pathType)

    def closeAllDocuments(self) -> "void":
        return _connect.CIDEController_closeAllDocuments(self)

    def saveAllDocuments(self) -> "void":
        return _connect.CIDEController_saveAllDocuments(self)

    def activate(self) -> "isys::CIDEData":
        return _connect.CIDEController_activate(self)

    def minimize(self) -> "isys::CIDEData":
        return _connect.CIDEController_minimize(self)

    def maximize(self) -> "isys::CIDEData":
        return _connect.CIDEController_maximize(self)

    def restore(self) -> "isys::CIDEData":
        return _connect.CIDEController_restore(self)

    def getPID(self) -> "isys::CIDEData":
        return _connect.CIDEController_getPID(self)

    def move(self, left: 'int', top: 'int', right: 'int', bottom: 'int') -> "isys::CIDEData":
        return _connect.CIDEController_move(self, left, top, right, bottom)

    def refreshUI(self) -> "void":
        return _connect.CIDEController_refreshUI(self)

    def bringWinIDEAToTop(self) -> "void":
        return _connect.CIDEController_bringWinIDEAToTop(self)

    def getNumClients(self) -> "int":
        return _connect.CIDEController_getNumClients(self)

    def getCapabilities(self) -> "isys::CIDECapabilities":
        return _connect.CIDEController_getCapabilities(self)

    def setMsgBoxHook(self, isHookOn: 'bool') -> "void":
        return _connect.CIDEController_setMsgBoxHook(self, isHookOn)

    def setMsgBoxHookMode(self, hookMode: 'isys::CIDEController::EHookMode') -> "void":
        return _connect.CIDEController_setMsgBoxHookMode(self, hookMode)

    def isMsgBoxHookOn(self) -> "bool":
        return _connect.CIDEController_isMsgBoxHookOn(self)

    def getMsgBoxHookMode(self) -> "isys::CIDEController::EHookMode":
        return _connect.CIDEController_getMsgBoxHookMode(self)

    def iOpenDisconnect(self) -> "void":
        return _connect.CIDEController_iOpenDisconnect(self)

    def getDefaultDownloadFile(self) -> "std::string":
        return _connect.CIDEController_getDefaultDownloadFile(self)

    def option(self, *args) -> "bool":
        return _connect.CIDEController_option(self, *args)

    def setOptionsMap(self, moduleTypeId: 'std::string const &', assignmentsMap: 'std::string const &') -> "void":
        return _connect.CIDEController_setOptionsMap(self, moduleTypeId, assignmentsMap)

    def getOptionsMap(self, moduleTypeId: 'std::string const &', options: 'std::string const &', bufferSize: 'int') -> "std::string":
        return _connect.CIDEController_getOptionsMap(self, moduleTypeId, options, bufferSize)

    def setOption_str(self, optionUrl: 'std::string const &', value: 'std::string const &') -> "void":
        return _connect.CIDEController_setOption_str(self, optionUrl, value)

    def setOption_u32(self, optionUrl: 'std::string const &', value: 'DWORD') -> "void":
        return _connect.CIDEController_setOption_u32(self, optionUrl, value)

    def setOption_f64(self, optionUrl: 'std::string const &', value: 'double') -> "void":
        return _connect.CIDEController_setOption_f64(self, optionUrl, value)

    def setOption(self, *args) -> "void":
        return _connect.CIDEController_setOption(self, *args)

    def getOptionStr(self, *args) -> "std::string":
        return _connect.CIDEController_getOptionStr(self, *args)

    def getOptionInt(self, *args) -> "int":
        return _connect.CIDEController_getOptionInt(self, *args)

    def getOptionFloat(self, *args) -> "double":
        return _connect.CIDEController_getOptionFloat(self, *args)

    def getOptionDataDescriptor(self, optionUrl: 'std::string const &') -> "DataDescriptor::IDescriptor *":
        return _connect.CIDEController_getOptionDataDescriptor(self, optionUrl)

    def getMenuStructure(self, optionUrl: 'std::string const &') -> "isys::IMenuStructure *":
        return _connect.CIDEController_getMenuStructure(self, optionUrl)

    def release(self, *args) -> "void":
        return _connect.CIDEController_release(self, *args)

    def getDynamicOptionSize(self, *args) -> "DWORD":
        return _connect.CIDEController_getDynamicOptionSize(self, *args)

    def findDynamicOption(self, urlBase: 'std::string const &', elementName: 'std::string const &', strToFind: 'std::string const &') -> "int":
        return _connect.CIDEController_findDynamicOption(self, urlBase, elementName, strToFind)

    def getDynamicOptions(self, urlBase: 'std::string const &', elementName: 'std::string const &', optionValues: 'StrVector') -> "void":
        return _connect.CIDEController_getDynamicOptions(self, urlBase, elementName, optionValues)

    def addDynamicOption(self, *args) -> "int":
        return _connect.CIDEController_addDynamicOption(self, *args)

    def addDynamicOptionUrl(self, optionUrl: 'std::string const &', index: 'int'=-1) -> "std::string":
        return _connect.CIDEController_addDynamicOptionUrl(self, optionUrl, index)

    def removeDynamicOption(self, *args) -> "void":
        return _connect.CIDEController_removeDynamicOption(self, *args)

    def commitOptions(self, *args) -> "void":
        return _connect.CIDEController_commitOptions(self, *args)

    def serviceCall(self, *args) -> "std::string":
        return _connect.CIDEController_serviceCall(self, *args)
    if _newclass:
        parseServiceCallMap = staticmethod(_connect.CIDEController_parseServiceCallMap)
    else:
        parseServiceCallMap = _connect.CIDEController_parseServiceCallMap

    def setInterruptsDisable(self, interruptFlags: 'int'=0xffff) -> "int":
        return _connect.CIDEController_setInterruptsDisable(self, interruptFlags)

    def cdToWinIDEAWorkspaceDir(self) -> "std::string":
        return _connect.CIDEController_cdToWinIDEAWorkspaceDir(self)

    def getLicenseDescription(self) -> "std::string":
        return _connect.CIDEController_getLicenseDescription(self)

    def getLValue(self, key: 'std::string const &') -> "std::string":
        return _connect.CIDEController_getLValue(self, key)
CIDEController_swigregister = _connect.CIDEController_swigregister
CIDEController_swigregister(CIDEController)
CIDEController.ADVANCED_KEY_0 = _connect.cvar.CIDEController_ADVANCED_KEY_0
CIDEController.ADVANCED_KEY_1 = _connect.cvar.CIDEController_ADVANCED_KEY_1
CIDEController.ADVANCED_KEY_2 = _connect.cvar.CIDEController_ADVANCED_KEY_2
CIDEController.ADVANCED_KEY_3 = _connect.cvar.CIDEController_ADVANCED_KEY_3
CIDEController.ADVANCED_KEY_4 = _connect.cvar.CIDEController_ADVANCED_KEY_4
CIDEController.ADVANCED_KEY_5 = _connect.cvar.CIDEController_ADVANCED_KEY_5
CIDEController.ADVANCED_KEY_6 = _connect.cvar.CIDEController_ADVANCED_KEY_6
CIDEController.EVALUATION_LICENSE_STR = _connect.cvar.CIDEController_EVALUATION_LICENSE_STR
CIDEController.LICENSE_DESCRIPTION = _connect.cvar.CIDEController_LICENSE_DESCRIPTION
CIDEController.OPT_DEST_IDE = _connect.cvar.CIDEController_OPT_DEST_IDE
CIDEController.OPT_DEST_DOCUMENT = _connect.cvar.CIDEController_OPT_DEST_DOCUMENT
CIDEController.OPT_DEST_IOPEN = _connect.cvar.CIDEController_OPT_DEST_IOPEN
CIDEController.OPT_DEST_PLUGIN = _connect.cvar.CIDEController_OPT_DEST_PLUGIN
CIDEController.OPT_DEST_HIL = _connect.cvar.CIDEController_OPT_DEST_HIL

def CIDEController_parseServiceCallMap(str: 'std::string const &', outParams: 'StrStrMap') -> "void":
    return _connect.CIDEController_parseServiceCallMap(str, outParams)
CIDEController_parseServiceCallMap = _connect.CIDEController_parseServiceCallMap

class DownloadListMember(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DownloadListMember, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DownloadListMember, name)
    __repr__ = _swig_repr
    __swig_setmethods__["fileName"] = _connect.DownloadListMember_fileName_set
    __swig_getmethods__["fileName"] = _connect.DownloadListMember_fileName_get
    if _newclass:
        fileName = _swig_property(_connect.DownloadListMember_fileName_get, _connect.DownloadListMember_fileName_set)
    __swig_setmethods__["options"] = _connect.DownloadListMember_options_set
    __swig_getmethods__["options"] = _connect.DownloadListMember_options_get
    if _newclass:
        options = _swig_property(_connect.DownloadListMember_options_get, _connect.DownloadListMember_options_set)

    def __init__(self):
        this = _connect.new_DownloadListMember()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_DownloadListMember
    __del__ = lambda self: None
DownloadListMember_swigregister = _connect.DownloadListMember_swigregister
DownloadListMember_swigregister(DownloadListMember)

class CDownloadConfiguration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDownloadConfiguration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDownloadConfiguration, name)
    __repr__ = _swig_repr
    ftBinary = _connect.CDownloadConfiguration_ftBinary
    ftIntelHex = _connect.CDownloadConfiguration_ftIntelHex
    ftMotorolaS = _connect.CDownloadConfiguration_ftMotorolaS
    ftTektronix = _connect.CDownloadConfiguration_ftTektronix
    ftExtendedTektronix = _connect.CDownloadConfiguration_ftExtendedTektronix
    ftUBROF = _connect.CDownloadConfiguration_ftUBROF
    ftOMF166 = _connect.CDownloadConfiguration_ftOMF166
    ftICFOFF = _connect.CDownloadConfiguration_ftICFOFF
    ftOMF51 = _connect.CDownloadConfiguration_ftOMF51
    ftSLOText = _connect.CDownloadConfiguration_ftSLOText
    ftMicrotek = _connect.CDownloadConfiguration_ftMicrotek
    ftIEEE695 = _connect.CDownloadConfiguration_ftIEEE695
    ftAD2500 = _connect.CDownloadConfiguration_ftAD2500
    ftAXE = _connect.CDownloadConfiguration_ftAXE
    ftByteCraftCOD = _connect.CDownloadConfiguration_ftByteCraftCOD
    ftMotorolaSymbolic = _connect.CDownloadConfiguration_ftMotorolaSymbolic
    ftHiTech = _connect.CDownloadConfiguration_ftHiTech
    ftOMF86 = _connect.CDownloadConfiguration_ftOMF86
    ftOMF96 = _connect.CDownloadConfiguration_ftOMF96
    ftOMF251 = _connect.CDownloadConfiguration_ftOMF251
    ftProspero = _connect.CDownloadConfiguration_ftProspero
    ftLogitechModula2 = _connect.CDownloadConfiguration_ftLogitechModula2
    ftELF = _connect.CDownloadConfiguration_ftELF
    ftMARC4 = _connect.CDownloadConfiguration_ftMARC4
    ftCR16COFF = _connect.CDownloadConfiguration_ftCR16COFF
    ftTMSCOFF = _connect.CDownloadConfiguration_ftTMSCOFF
    ftStabs = _connect.CDownloadConfiguration_ftStabs
    ftZardoz = _connect.CDownloadConfiguration_ftZardoz

    def __init__(self):
        this = _connect.new_CDownloadConfiguration()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setCodeOffset(self, offset: 'ADDRESS') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setCodeOffset(self, offset)

    def setSymbolsOffset(self, offset: 'ADDRESS') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setSymbolsOffset(self, offset)

    def setMemoryArea(self, memoryArea: 'BYTE') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setMemoryArea(self, memoryArea)

    def setUsedInFullDownload(self, isUsedInFullDownload: 'bool') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setUsedInFullDownload(self, isUsedInFullDownload)

    def setIsProjectOutputFile(self, isProjectOutputFile: 'bool') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setIsProjectOutputFile(self, isProjectOutputFile)

    def setInProjectTargetDir(self, isInProjectTargetDir: 'bool') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setInProjectTargetDir(self, isInProjectTargetDir)

    def setTypeEqualByName(self, isTypeEqualByName: 'bool') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setTypeEqualByName(self, isTypeEqualByName)

    def setDownloadFileFormat(self, format: 'isys::CDownloadConfiguration::DownloadFileFormats') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setDownloadFileFormat(self, format)

    def setRealTimeAccess(self, isRealTimeAccess: 'bool') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setRealTimeAccess(self, isRealTimeAccess)

    def setForceConvert(self, isForceConvert: 'bool') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setForceConvert(self, isForceConvert)

    def setUseAbsolutePath(self, isUseAbsolutePath: 'bool') -> "isys::CDownloadConfiguration &":
        return _connect.CDownloadConfiguration_setUseAbsolutePath(self, isUseAbsolutePath)

    def isForceConvert(self) -> "bool":
        return _connect.CDownloadConfiguration_isForceConvert(self)

    def isRealTimeAccess(self) -> "bool":
        return _connect.CDownloadConfiguration_isRealTimeAccess(self)

    def isUseAbsolutePath(self) -> "bool":
        return _connect.CDownloadConfiguration_isUseAbsolutePath(self)
    __swig_destroy__ = _connect.delete_CDownloadConfiguration
    __del__ = lambda self: None
CDownloadConfiguration_swigregister = _connect.CDownloadConfiguration_swigregister
CDownloadConfiguration_swigregister(CDownloadConfiguration)

class CLoaderController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CLoaderController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CLoaderController, name)
    __repr__ = _swig_repr
    DLIST_PRIMARY = _connect.CLoaderController_DLIST_PRIMARY
    DLIST_TARGET = _connect.CLoaderController_DLIST_TARGET

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CLoaderController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CLoaderController
    __del__ = lambda self: None

    def download(self) -> "int":
        return _connect.CLoaderController_download(self)

    def downloadWithoutCode(self) -> "int":
        return _connect.CLoaderController_downloadWithoutCode(self)

    def targetDownload(self, *args) -> "int":
        return _connect.CLoaderController_targetDownload(self, *args)

    def downloadFromList(self, *args) -> "int":
        return _connect.CLoaderController_downloadFromList(self, *args)

    def addToDownloadList(self, *args) -> "void":
        return _connect.CLoaderController_addToDownloadList(self, *args)

    def removeFromDownloadList(self, listType: 'isys::CLoaderController::DownloadListType', fileIndex: 'int') -> "int":
        return _connect.CLoaderController_removeFromDownloadList(self, listType, fileIndex)

    def clearDownloadList(self, listType: 'isys::CLoaderController::DownloadListType') -> "void":
        return _connect.CLoaderController_clearDownloadList(self, listType)

    def verifyDownload(self) -> "void":
        return _connect.CLoaderController_verifyDownload(self)

    def getDownloadList(self, listType: 'isys::CLoaderController::DownloadListType', isAbsolutePath: 'bool') -> "isys::CLoaderController::DownloadListVector const &":
        return _connect.CLoaderController_getDownloadList(self, listType, isAbsolutePath)
CLoaderController_swigregister = _connect.CLoaderController_swigregister
CLoaderController_swigregister(CLoaderController)

class CWorkspaceController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CWorkspaceController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CWorkspaceController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CWorkspaceController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CWorkspaceController
    __del__ = lambda self: None

    def getIConnectIDE(self) -> "IConnectIDE *":
        return _connect.CWorkspaceController_getIConnectIDE(self)

    def newWS(self, workspaceFileName: 'std::string const &') -> "void":
        return _connect.CWorkspaceController_newWS(self, workspaceFileName)

    def open(self, workspaceFileName: 'std::string const &') -> "bool":
        return _connect.CWorkspaceController_open(self, workspaceFileName)

    def save(self) -> "void":
        return _connect.CWorkspaceController_save(self)

    def saveAs(self, workspaceFileName: 'std::string const &') -> "void":
        return _connect.CWorkspaceController_saveAs(self, workspaceFileName)

    def close(self) -> "void":
        return _connect.CWorkspaceController_close(self)

    def closeDiscard(self) -> "void":
        return _connect.CWorkspaceController_closeDiscard(self)
CWorkspaceController_swigregister = _connect.CWorkspaceController_swigregister
CWorkspaceController_swigregister(CWorkspaceController)

class CBuildStatus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CBuildStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CBuildStatus, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIdle(self) -> "bool":
        return _connect.CBuildStatus_isIdle(self)

    def isIdleWError(self) -> "bool":
        return _connect.CBuildStatus_isIdleWError(self)

    def isConfigError(self) -> "bool":
        return _connect.CBuildStatus_isConfigError(self)

    def isActive(self) -> "bool":
        return _connect.CBuildStatus_isActive(self)

    def getNumErrors(self) -> "int":
        return _connect.CBuildStatus_getNumErrors(self)

    def getNumWarnings(self) -> "int":
        return _connect.CBuildStatus_getNumWarnings(self)
    __swig_destroy__ = _connect.delete_CBuildStatus
    __del__ = lambda self: None
CBuildStatus_swigregister = _connect.CBuildStatus_swigregister
CBuildStatus_swigregister(CBuildStatus)

class CBuildOptions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CBuildOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CBuildOptions, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def get(self, *args) -> "std::string":
        return _connect.CBuildOptions_get(self, *args)

    def set(self, scope: 'std::string const &', option: 'std::string const &', value: 'std::string const &') -> "void":
        return _connect.CBuildOptions_set(self, scope, option, value)

    def add(self, scope: 'std::string const &', option: 'std::string const &', value: 'std::string const &') -> "void":
        return _connect.CBuildOptions_add(self, scope, option, value)

    def remove(self, scope: 'std::string const &', option: 'std::string const &') -> "void":
        return _connect.CBuildOptions_remove(self, scope, option)

    def move(self, scope: 'std::string const &', option: 'std::string const &', value: 'std::string const &') -> "void":
        return _connect.CBuildOptions_move(self, scope, option, value)
    __swig_destroy__ = _connect.delete_CBuildOptions
    __del__ = lambda self: None
CBuildOptions_swigregister = _connect.CBuildOptions_swigregister
CBuildOptions_swigregister(CBuildOptions)

class CProjectController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProjectController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProjectController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CProjectController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CProjectController
    __del__ = lambda self: None

    def getIConnectProject(self) -> "IConnectProject *":
        return _connect.CProjectController_getIConnectProject(self)

    def compile(self, fileName: 'std::string const &') -> "void":
        return _connect.CProjectController_compile(self, fileName)

    def link(self, suppressPostLinkActions: 'bool'=False) -> "void":
        return _connect.CProjectController_link(self, suppressPostLinkActions)

    def make(self, suppressPostLinkActions: 'bool'=False) -> "void":
        return _connect.CProjectController_make(self, suppressPostLinkActions)

    def build(self, suppressPostLinkActions: 'bool'=False) -> "void":
        return _connect.CProjectController_build(self, suppressPostLinkActions)

    def isUpToDate(self) -> "bool":
        return _connect.CProjectController_isUpToDate(self)

    def setTarget(self, makeTargetName: 'std::string const &') -> "void":
        return _connect.CProjectController_setTarget(self, makeTargetName)

    def importProject(self, xmlFileName: 'std::string const &') -> "int":
        return _connect.CProjectController_importProject(self, xmlFileName)

    def exportProject(self, xmlFileName: 'std::string const &') -> "int":
        return _connect.CProjectController_exportProject(self, xmlFileName)

    def dependencies(self) -> "void":
        return _connect.CProjectController_dependencies(self)

    def stop(self) -> "void":
        return _connect.CProjectController_stop(self)

    def customOperation(self, operation: 'std::string const &', parameters: 'std::string const &') -> "void":
        return _connect.CProjectController_customOperation(self, operation, parameters)

    def getStatus(self) -> "isys::CBuildStatus":
        return _connect.CProjectController_getStatus(self)

    def options(self) -> "isys::CBuildOptions &":
        return _connect.CProjectController_options(self)

    def enumerateProjectOption(self, scope: 'std::string const &', option: 'std::string const &', index: 'int', isReturnRelativePath: 'bool') -> "std::string":
        return _connect.CProjectController_enumerateProjectOption(self, scope, option, index, isReturnRelativePath)

    def modifyProjectOption(self, cmd: 'IConnectProject::EOptionFlags', cmdFlags: 'DWORD', scope: 'std::string const &', option: 'std::string const &', value: 'std::string const &') -> "std::string":
        return _connect.CProjectController_modifyProjectOption(self, cmd, cmdFlags, scope, option, value)

    def getWarningMessage(self) -> "std::string":
        return _connect.CProjectController_getWarningMessage(self)
CProjectController_swigregister = _connect.CProjectController_swigregister
CProjectController_swigregister(CProjectController)

EXPORT_TrcAsText = _connect.EXPORT_TrcAsText
EXPORT_TrcAsCSV = _connect.EXPORT_TrcAsCSV
EXPORT_TrcAsXML = _connect.EXPORT_TrcAsXML
EXPORT_TrcAsBinary = _connect.EXPORT_TrcAsBinary
EXPORT_ProfilerAsText = _connect.EXPORT_ProfilerAsText
EXPORT_ProfilerAsCSV = _connect.EXPORT_ProfilerAsCSV
EXPORT_ProfilerAsXML = _connect.EXPORT_ProfilerAsXML
EXPORT_ProfilerAsBinary = _connect.EXPORT_ProfilerAsBinary
EXPORT_ProfilerAsText1 = _connect.EXPORT_ProfilerAsText1
EXPORT_ProfilerAsXMLBinaryTimeline = _connect.EXPORT_ProfilerAsXMLBinaryTimeline
EXPORT_ProfilerAsBTF = _connect.EXPORT_ProfilerAsBTF
EXPORT_CCAsHTML = _connect.EXPORT_CCAsHTML
EXPORT_CCAsText = _connect.EXPORT_CCAsText
EXPORT_CCAsCSV = _connect.EXPORT_CCAsCSV
EXPORT_CCAsXML = _connect.EXPORT_CCAsXML
EXPORT_CCAsReviewHTML = _connect.EXPORT_CCAsReviewHTML
EXPORT_CCAsReviewText = _connect.EXPORT_CCAsReviewText
EXPORT_CCAsXML2 = _connect.EXPORT_CCAsXML2
EXPORT_CCAsGCOV = _connect.EXPORT_CCAsGCOV
class CAnalyzerStatus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CAnalyzerStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CAnalyzerStatus, name)
    __repr__ = _swig_repr

    def __init__(self, hResult: 'DWORD'):
        this = _connect.new_CAnalyzerStatus(hResult)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isErrorInBuffer(self) -> "bool":
        return _connect.CAnalyzerStatus_isErrorInBuffer(self)

    def isBufferOverrun(self) -> "bool":
        return _connect.CAnalyzerStatus_isBufferOverrun(self)

    def isRecordingError(self) -> "bool":
        return _connect.CAnalyzerStatus_isRecordingError(self)

    def isError(self) -> "bool":
        return _connect.CAnalyzerStatus_isError(self)

    def isLoading(self) -> "bool":
        return _connect.CAnalyzerStatus_isLoading(self)

    def isWaiting(self) -> "bool":
        return _connect.CAnalyzerStatus_isWaiting(self)

    def isOpening(self) -> "bool":
        return _connect.CAnalyzerStatus_isOpening(self)

    def isDocumentEmpty(self) -> "bool":
        return _connect.CAnalyzerStatus_isDocumentEmpty(self)

    def isActive(self) -> "bool":
        return _connect.CAnalyzerStatus_isActive(self)

    def isBusy(self) -> "bool":
        return _connect.CAnalyzerStatus_isBusy(self)

    def getReturnCode(self) -> "DWORD":
        return _connect.CAnalyzerStatus_getReturnCode(self)

    def toString(self) -> "std::string":
        return _connect.CAnalyzerStatus_toString(self)
    __swig_destroy__ = _connect.delete_CAnalyzerStatus
    __del__ = lambda self: None
CAnalyzerStatus_swigregister = _connect.CAnalyzerStatus_swigregister
CAnalyzerStatus_swigregister(CAnalyzerStatus)

class CAnalyzerSessionStatus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CAnalyzerSessionStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CAnalyzerSessionStatus, name)
    __repr__ = _swig_repr

    def __init__(self, hResult: 'DWORD'):
        this = _connect.new_CAnalyzerSessionStatus(hResult)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isRecorderIdle(self) -> "bool":
        return _connect.CAnalyzerSessionStatus_isRecorderIdle(self)

    def isRecorderWaiting(self) -> "bool":
        return _connect.CAnalyzerSessionStatus_isRecorderWaiting(self)

    def isRecorderSampling(self) -> "bool":
        return _connect.CAnalyzerSessionStatus_isRecorderSampling(self)

    def isUploading(self) -> "bool":
        return _connect.CAnalyzerSessionStatus_isUploading(self)

    def isAnalyzing(self) -> "bool":
        return _connect.CAnalyzerSessionStatus_isAnalyzing(self)

    def isErrorInTraceStream(self) -> "bool":
        return _connect.CAnalyzerSessionStatus_isErrorInTraceStream(self)

    def isBufferOverrun(self) -> "bool":
        return _connect.CAnalyzerSessionStatus_isBufferOverrun(self)

    def isError(self) -> "bool":
        return _connect.CAnalyzerSessionStatus_isError(self)

    def toString(self) -> "std::string":
        return _connect.CAnalyzerSessionStatus_toString(self)
    __swig_destroy__ = _connect.delete_CAnalyzerSessionStatus
    __del__ = lambda self: None
CAnalyzerSessionStatus_swigregister = _connect.CAnalyzerSessionStatus_swigregister
CAnalyzerSessionStatus_swigregister(CAnalyzerSessionStatus)

class CDocumentStatus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDocumentStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDocumentStatus, name)
    __repr__ = _swig_repr

    def __init__(self, hResult: 'DWORD'):
        this = _connect.new_CDocumentStatus(hResult)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isSerializing(self) -> "bool":
        return _connect.CDocumentStatus_isSerializing(self)

    def isEmpty(self) -> "bool":
        return _connect.CDocumentStatus_isEmpty(self)

    def isDirty(self) -> "bool":
        return _connect.CDocumentStatus_isDirty(self)

    def isCanStart(self) -> "bool":
        return _connect.CDocumentStatus_isCanStart(self)

    def toString(self) -> "std::string":
        return _connect.CDocumentStatus_toString(self)
    __swig_destroy__ = _connect.delete_CDocumentStatus
    __del__ = lambda self: None
CDocumentStatus_swigregister = _connect.CDocumentStatus_swigregister
CDocumentStatus_swigregister(CDocumentStatus)

class CDocumentController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDocumentController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDocumentController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >', fileName: 'std::string const &', mode: 'std::string const &'):
        this = _connect.new_CDocumentController(connectionMgr, fileName, mode)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CDocumentController
    __del__ = lambda self: None

    def getIConnectIDE(self) -> "IConnectIDE3 *":
        return _connect.CDocumentController_getIConnectIDE(self)

    def start(self) -> "void":
        return _connect.CDocumentController_start(self)

    def start1(self) -> "void":
        return _connect.CDocumentController_start1(self)

    def stop(self) -> "void":
        return _connect.CDocumentController_stop(self)

    def resume(self) -> "void":
        return _connect.CDocumentController_resume(self)

    def close(self) -> "void":
        return _connect.CDocumentController_close(self)

    def closeDiscard(self) -> "void":
        return _connect.CDocumentController_closeDiscard(self)

    def closeAll(self) -> "void":
        return _connect.CDocumentController_closeAll(self)

    def reset(self, resetScope: 'IConnectIDE::EDocumentResetParameter') -> "void":
        return _connect.CDocumentController_reset(self, resetScope)

    def save(self) -> "void":
        return _connect.CDocumentController_save(self)

    def saveAs(self, fileName: 'std::string const &', isForceOverwrite: 'bool'=False) -> "void":
        return _connect.CDocumentController_saveAs(self, fileName, isForceOverwrite)

    def saveCopy(self, newFileName: 'std::string const &') -> "void":
        return _connect.CDocumentController_saveCopy(self, newFileName)

    def saveAsPrompt(self) -> "void":
        return _connect.CDocumentController_saveAsPrompt(self)

    def setMarker(self, lineNumber: 'int') -> "void":
        return _connect.CDocumentController_setMarker(self, lineNumber)

    def clearMarker(self) -> "void":
        return _connect.CDocumentController_clearMarker(self)

    def setFocus(self, lineNumber: 'int') -> "void":
        return _connect.CDocumentController_setFocus(self, lineNumber)
CDocumentController_swigregister = _connect.CDocumentController_swigregister
CDocumentController_swigregister(CDocumentController)

class CAnalyzerDocController(CDocumentController):
    __swig_setmethods__ = {}
    for _s in [CDocumentController]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CAnalyzerDocController, name, value)
    __swig_getmethods__ = {}
    for _s in [CDocumentController]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CAnalyzerDocController, name)
    __repr__ = _swig_repr
    ANALYZER = _connect.CAnalyzerDocController_ANALYZER
    CODE_COVERAGE = _connect.CAnalyzerDocController_CODE_COVERAGE
    PROFILER = _connect.CAnalyzerDocController_PROFILER
    ETraceOnly = _connect.CAnalyzerDocController_ETraceOnly
    ECoverage = _connect.CAnalyzerDocController_ECoverage
    EProfiler = _connect.CAnalyzerDocController_EProfiler
    EBoth = _connect.CAnalyzerDocController_EBoth

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >', type: 'isys::CAnalyzerDocController::EDocumentType', fileName: 'std::string const &', mode: 'std::string const &', createObjectOnly: 'bool'=False):
        this = _connect.new_CAnalyzerDocController(connectionMgr, type, fileName, mode, createObjectOnly)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CAnalyzerDocController
    __del__ = lambda self: None

    def isActive(self) -> "bool":
        return _connect.CAnalyzerDocController_isActive(self)

    def isBusy(self) -> "bool":
        return _connect.CAnalyzerDocController_isBusy(self)

    def setDirty(self, isDirty: 'bool') -> "void":
        return _connect.CAnalyzerDocController_setDirty(self, isDirty)

    def abort(self) -> "void":
        return _connect.CAnalyzerDocController_abort(self)

    def stopSampling(self) -> "void":
        return _connect.CAnalyzerDocController_stopSampling(self)

    def stopUploading(self) -> "void":
        return _connect.CAnalyzerDocController_stopUploading(self)

    def stopAnalyzing(self) -> "void":
        return _connect.CAnalyzerDocController_stopAnalyzing(self)

    def stopLoadingOrSaving(self) -> "void":
        return _connect.CAnalyzerDocController_stopLoadingOrSaving(self)

    def getStatus(self) -> "isys::CAnalyzerStatus":
        return _connect.CAnalyzerDocController_getStatus(self)

    def getAnalyzerSessionStatus(self) -> "isys::CAnalyzerSessionStatus":
        return _connect.CAnalyzerDocController_getAnalyzerSessionStatus(self)

    def getDocumentStatus(self) -> "isys::CDocumentStatus":
        return _connect.CAnalyzerDocController_getDocumentStatus(self)

    def getActiveTriggerIndex(self) -> "int":
        return _connect.CAnalyzerDocController_getActiveTriggerIndex(self)

    def createTrigger(self, triggerName: 'std::string const &') -> "int":
        return _connect.CAnalyzerDocController_createTrigger(self, triggerName)

    def setAnalysisType(self, triggerIndex: 'int', analysisType: 'isys::CAnalyzerDocController::EAnalysisType') -> "void":
        return _connect.CAnalyzerDocController_setAnalysisType(self, triggerIndex, analysisType)

    def removeTrigger(self, triggerName: 'std::string const &') -> "int":
        return _connect.CAnalyzerDocController_removeTrigger(self, triggerName)

    def getTriggerIndex(self, triggerName: 'std::string const &', isThrowException: 'bool'=True) -> "int":
        return _connect.CAnalyzerDocController_getTriggerIndex(self, triggerName, isThrowException)

    def select(self, *args) -> "void":
        return _connect.CAnalyzerDocController_select(self, *args)

    def waitUntilLoaded(self, timeout: 'int'=0, pollingInterval: 'DWORD'=100, isThrow: 'bool'=False) -> "bool":
        return _connect.CAnalyzerDocController_waitUntilLoaded(self, timeout, pollingInterval, isThrow)

    def getNumberOfTriggers(self) -> "int":
        return _connect.CAnalyzerDocController_getNumberOfTriggers(self)

    def getDocumentOptionURL(self, postfix: 'std::string const &') -> "std::string":
        return _connect.CAnalyzerDocController_getDocumentOptionURL(self, postfix)

    def getTriggerOption(self, index: 'int', triggerOption: 'std::string const &') -> "std::string":
        return _connect.CAnalyzerDocController_getTriggerOption(self, index, triggerOption)

    def setTriggerOption(self, *args) -> "void":
        return _connect.CAnalyzerDocController_setTriggerOption(self, *args)

    def setExportFormat(self, exportFormat: 'std::string const &') -> "void":
        return _connect.CAnalyzerDocController_setExportFormat(self, exportFormat)

    def exportAs(self, *args) -> "void":
        return _connect.CAnalyzerDocController_exportAs(self, *args)

    def exportAsAndLaunchViewer(self, scope: 'IConnectIDE::EDocumentExportParameter', fileName: 'std::string const &', format: 'DWORD') -> "void":
        return _connect.CAnalyzerDocController_exportAsAndLaunchViewer(self, scope, fileName, format)

    def setMarker(self) -> "void":
        return _connect.CAnalyzerDocController_setMarker(self)
CAnalyzerDocController_swigregister = _connect.CAnalyzerDocController_swigregister
CAnalyzerDocController_swigregister(CAnalyzerDocController)
CAnalyzerDocController.exportCCAsHTML = _connect.cvar.CAnalyzerDocController_exportCCAsHTML
CAnalyzerDocController.exportCCAsText = _connect.cvar.CAnalyzerDocController_exportCCAsText
CAnalyzerDocController.exportCCAsCSV = _connect.cvar.CAnalyzerDocController_exportCCAsCSV
CAnalyzerDocController.exportCCAsXML = _connect.cvar.CAnalyzerDocController_exportCCAsXML
CAnalyzerDocController.exportCCAsXML2 = _connect.cvar.CAnalyzerDocController_exportCCAsXML2
CAnalyzerDocController.exportCCAsGCOV = _connect.cvar.CAnalyzerDocController_exportCCAsGCOV
CAnalyzerDocController.exportCCAsReviewHTML = _connect.cvar.CAnalyzerDocController_exportCCAsReviewHTML
CAnalyzerDocController.exportCCAsReviewText = _connect.cvar.CAnalyzerDocController_exportCCAsReviewText
CAnalyzerDocController.exportTrcAsText = _connect.cvar.CAnalyzerDocController_exportTrcAsText
CAnalyzerDocController.exportTrcAsCSV = _connect.cvar.CAnalyzerDocController_exportTrcAsCSV
CAnalyzerDocController.exportTrcAsBinary = _connect.cvar.CAnalyzerDocController_exportTrcAsBinary
CAnalyzerDocController.exportTrcAsXML = _connect.cvar.CAnalyzerDocController_exportTrcAsXML
CAnalyzerDocController.exportProfilerAsText = _connect.cvar.CAnalyzerDocController_exportProfilerAsText
CAnalyzerDocController.exportProfilerAsXML = _connect.cvar.CAnalyzerDocController_exportProfilerAsXML
CAnalyzerDocController.exportProfilerAsCSV = _connect.cvar.CAnalyzerDocController_exportProfilerAsCSV
CAnalyzerDocController.exportProfilerAsText1 = _connect.cvar.CAnalyzerDocController_exportProfilerAsText1
CAnalyzerDocController.exportProfilerAsBinary = _connect.cvar.CAnalyzerDocController_exportProfilerAsBinary
CAnalyzerDocController.exportProfilerAsBTF = _connect.cvar.CAnalyzerDocController_exportProfilerAsBTF

class CTerminalDocController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTerminalDocController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTerminalDocController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CTerminalDocController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTerminalDocController
    __del__ = lambda self: None

    def close(self) -> "void":
        return _connect.CTerminalDocController_close(self)

    def start(self) -> "void":
        return _connect.CTerminalDocController_start(self)

    def stop(self) -> "void":
        return _connect.CTerminalDocController_stop(self)

    def saveAs(self, fileName: 'std::string const &') -> "void":
        return _connect.CTerminalDocController_saveAs(self, fileName)

    def reset(self) -> "void":
        return _connect.CTerminalDocController_reset(self)
CTerminalDocController_swigregister = _connect.CTerminalDocController_swigregister
CTerminalDocController_swigregister(CTerminalDocController)

class CCoverageFormatBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageFormatBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageFormatBase, name)
    __repr__ = _swig_repr
    EFmtHTML = _connect.CCoverageFormatBase_EFmtHTML
    EFmtText = _connect.CCoverageFormatBase_EFmtText
    EFmtXML = _connect.CCoverageFormatBase_EFmtXML
    EFmtCSV = _connect.CCoverageFormatBase_EFmtCSV
    EFmtGCOV = _connect.CCoverageFormatBase_EFmtGCOV

    def __init__(self, exportFormat: 'isys::CCoverageFormatBase::EExportFormat'):
        this = _connect.new_CCoverageFormatBase(exportFormat)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getExportFormat(self) -> "isys::CCoverageFormatBase::EExportFormat":
        return _connect.CCoverageFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self) -> "std::string":
        return _connect.CCoverageFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CCoverageFormatBase_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CCoverageFormatBase
    __del__ = lambda self: None
CCoverageFormatBase_swigregister = _connect.CCoverageFormatBase_swigregister
CCoverageFormatBase_swigregister(CCoverageFormatBase)

class CCoverageHTMLExportFormat(CCoverageFormatBase):
    __swig_setmethods__ = {}
    for _s in [CCoverageFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageHTMLExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CCoverageFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageHTMLExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CCoverageHTMLExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCoverageHTMLExportFormat
    __del__ = lambda self: None
CCoverageHTMLExportFormat_swigregister = _connect.CCoverageHTMLExportFormat_swigregister
CCoverageHTMLExportFormat_swigregister(CCoverageHTMLExportFormat)

class CCoverageTextExportFormat(CCoverageFormatBase):
    __swig_setmethods__ = {}
    for _s in [CCoverageFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageTextExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CCoverageFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageTextExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CCoverageTextExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCoverageTextExportFormat
    __del__ = lambda self: None
CCoverageTextExportFormat_swigregister = _connect.CCoverageTextExportFormat_swigregister
CCoverageTextExportFormat_swigregister(CCoverageTextExportFormat)

class CCoverageCSVExportFormat(CCoverageFormatBase):
    __swig_setmethods__ = {}
    for _s in [CCoverageFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageCSVExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CCoverageFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageCSVExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CCoverageCSVExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCoverageCSVExportFormat
    __del__ = lambda self: None
CCoverageCSVExportFormat_swigregister = _connect.CCoverageCSVExportFormat_swigregister
CCoverageCSVExportFormat_swigregister(CCoverageCSVExportFormat)

class CCoverageXMLExportFormat(CCoverageFormatBase):
    __swig_setmethods__ = {}
    for _s in [CCoverageFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageXMLExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CCoverageFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageXMLExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CCoverageXMLExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCoverageXMLExportFormat
    __del__ = lambda self: None
CCoverageXMLExportFormat_swigregister = _connect.CCoverageXMLExportFormat_swigregister
CCoverageXMLExportFormat_swigregister(CCoverageXMLExportFormat)

class CCoverageExportConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageExportConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageExportConfig, name)
    __repr__ = _swig_repr
    EScopeAll = _connect.CCoverageExportConfig_EScopeAll
    EScopeVisible = _connect.CCoverageExportConfig_EScopeVisible
    EScopeConfigured = _connect.CCoverageExportConfig_EScopeConfigured

    def __init__(self):
        this = _connect.new_CCoverageExportConfig()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setFileName(self, fileName: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setFileName(self, fileName)

    def setFormatter(self, formatter: 'isys::CCoverageFormatBaseSPtr &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setFormatter(self, formatter)

    def setFormatVariant(self, formatVariant: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setFormatVariant(self, formatVariant)

    def setLaunchViewer(self, isLaunchViewer: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setExportModules(self, isExportModules: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setExportModules(self, isExportModules)

    def setExportModuleLines(self, isExportModuleLines: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setExportModuleLines(self, isExportModuleLines)

    def setExportSources(self, isExportSources: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setExportSources(self, isExportSources)

    def setExportFunctions(self, isExportFunctions: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setExportFunctions(self, isExportFunctions)

    def setExportFunctionLines(self, isExportFunctionLines: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setExportFunctionLines(self, isExportFunctionLines)

    def setExportFunctionAsm(self, isExportFunctionAsm: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setExportFunctionAsm(self, isExportFunctionAsm)

    def setExportAsm(self, isExportAsm: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setExportAsm(self, isExportAsm)

    def setExportRanges(self, isExportRanges: 'bool') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setExportRanges(self, isExportRanges)

    def setModulesFilter(self, modulesFilter: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setModulesFilter(self, modulesFilter)

    def setFunctionsFilter(self, functionsFilter: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setFunctionsFilter(self, functionsFilter)

    def setTestId(self, testId: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setTestId(self, testId)

    def setDescription(self, desc: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setDescription(self, desc)

    def setComment(self, comment: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setComment(self, comment)

    def setSoftware(self, sw: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setSoftware(self, sw)

    def setHardware(self, hw: 'std::string const &') -> "isys::CCoverageExportConfig &":
        return _connect.CCoverageExportConfig_setHardware(self, hw)

    def getFileName(self) -> "std::string":
        return _connect.CCoverageExportConfig_getFileName(self)

    def getFormatVariant(self) -> "std::string":
        return _connect.CCoverageExportConfig_getFormatVariant(self)

    def isLaunchViewer(self) -> "bool":
        return _connect.CCoverageExportConfig_isLaunchViewer(self)

    def isExportModules(self) -> "bool":
        return _connect.CCoverageExportConfig_isExportModules(self)

    def isExportModuleLines(self) -> "bool":
        return _connect.CCoverageExportConfig_isExportModuleLines(self)

    def isExportSources(self) -> "bool":
        return _connect.CCoverageExportConfig_isExportSources(self)

    def isExportFunctions(self) -> "bool":
        return _connect.CCoverageExportConfig_isExportFunctions(self)

    def isExportFunctionLines(self) -> "bool":
        return _connect.CCoverageExportConfig_isExportFunctionLines(self)

    def isExportFunctionAsm(self) -> "bool":
        return _connect.CCoverageExportConfig_isExportFunctionAsm(self)

    def isExportAsm(self) -> "bool":
        return _connect.CCoverageExportConfig_isExportAsm(self)

    def isExportRange(self) -> "bool":
        return _connect.CCoverageExportConfig_isExportRange(self)

    def getModulesFilter(self) -> "std::string":
        return _connect.CCoverageExportConfig_getModulesFilter(self)

    def getFunctionsFilter(self) -> "std::string":
        return _connect.CCoverageExportConfig_getFunctionsFilter(self)

    def getTestId(self) -> "std::string":
        return _connect.CCoverageExportConfig_getTestId(self)

    def getDescription(self) -> "std::string":
        return _connect.CCoverageExportConfig_getDescription(self)

    def getComment(self) -> "std::string":
        return _connect.CCoverageExportConfig_getComment(self)

    def getSoftware(self) -> "std::string":
        return _connect.CCoverageExportConfig_getSoftware(self)

    def getHardware(self) -> "std::string":
        return _connect.CCoverageExportConfig_getHardware(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CCoverageExportConfig_setOptions(self, ide, docFileName)

    def toString(self) -> "std::string":
        return _connect.CCoverageExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CCoverageExportConfig
    __del__ = lambda self: None
CCoverageExportConfig_swigregister = _connect.CCoverageExportConfig_swigregister
CCoverageExportConfig_swigregister(CCoverageExportConfig)

class CCoverageController2(CAnalyzerDocController):
    __swig_setmethods__ = {}
    for _s in [CAnalyzerDocController]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageController2, name, value)
    __swig_getmethods__ = {}
    for _s in [CAnalyzerDocController]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageController2, name)
    __repr__ = _swig_repr
    EAreaFolder = _connect.CCoverageController2_EAreaFolder
    EAreaModule = _connect.CCoverageController2_EAreaModule
    EAreaFunction = _connect.CCoverageController2_EAreaFunction
    EAreaRange = _connect.CCoverageController2_EAreaRange
    EAreaImage = _connect.CCoverageController2_EAreaImage
    EScopeAllDownloadedCode = _connect.CCoverageController2_EScopeAllDownloadedCode
    EScopeEntireMemory = _connect.CCoverageController2_EScopeEntireMemory
    EScopeCustom = _connect.CCoverageController2_EScopeCustom

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >', fileName: 'std::string const &', mode: 'std::string const &'):
        this = _connect.new_CCoverageController2(connectionMgr, fileName, mode)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCoverageController2
    __del__ = lambda self: None

    def createTrigger(self, triggerName: 'std::string const &') -> "int":
        return _connect.CCoverageController2_createTrigger(self, triggerName)

    def setScope(self, triggerIndex: 'int', scope: 'isys::CCoverageController2::ECoverageScope') -> "void":
        return _connect.CCoverageController2_setScope(self, triggerIndex, scope)

    def getScope(self, triggerIdx: 'int') -> "isys::CCoverageController2::ECoverageScope":
        return _connect.CCoverageController2_getScope(self, triggerIdx)

    def setProvideAssemblerInfo(self, triggerIdx: 'int', isProvideAssemblerInfo: 'bool') -> "void":
        return _connect.CCoverageController2_setProvideAssemblerInfo(self, triggerIdx, isProvideAssemblerInfo)

    def isProvideAssemblerInfo(self, triggerIdx: 'int') -> "bool":
        return _connect.CCoverageController2_isProvideAssemblerInfo(self, triggerIdx)

    def setIgnoreUnreachableCode(self, isIgnoreUnreachableCode: 'bool') -> "void":
        return _connect.CCoverageController2_setIgnoreUnreachableCode(self, isIgnoreUnreachableCode)

    def isIgnoreUnreachableCode(self) -> "bool":
        return _connect.CCoverageController2_isIgnoreUnreachableCode(self)

    def addArea(self, triggerIndex: 'int', areaType: 'isys::CCoverageController2::ECoverageAreaType', areaName: 'std::string const &') -> "int":
        return _connect.CCoverageController2_addArea(self, triggerIndex, areaType, areaName)

    def removeArea(self, triggerIndex: 'int', areaType: 'isys::CCoverageController2::ECoverageAreaType', areaName: 'std::string const &') -> "int":
        return _connect.CCoverageController2_removeArea(self, triggerIndex, areaType, areaName)

    def removeAllAreas(self, triggerIndex: 'int') -> "void":
        return _connect.CCoverageController2_removeAllAreas(self, triggerIndex)

    def getAreas(self, triggerIndex: 'int', areaType: 'isys::CCoverageController2::ECoverageAreaType', areas: 'StrVector') -> "void":
        return _connect.CCoverageController2_getAreas(self, triggerIndex, areaType, areas)

    def exportData(self, exportConfig: 'CCoverageExportConfig') -> "void":
        return _connect.CCoverageController2_exportData(self, exportConfig)

    def merge(self, files: 'StrVector') -> "void":
        return _connect.CCoverageController2_merge(self, files)

    def areaType2Str(self, areaType: 'isys::CCoverageController2::ECoverageAreaType') -> "std::string":
        return _connect.CCoverageController2_areaType2Str(self, areaType)

    def scope2Str(self, scope: 'isys::CCoverageController2::ECoverageScope') -> "std::string":
        return _connect.CCoverageController2_scope2Str(self, scope)

    def scope2Enum(self, scope: 'std::string const &') -> "isys::CCoverageController2::ECoverageScope":
        return _connect.CCoverageController2_scope2Enum(self, scope)
CCoverageController2_swigregister = _connect.CCoverageController2_swigregister
CCoverageController2_swigregister(CCoverageController2)

class CCoverageMetaInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageMetaInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageMetaInfo, name)
    __repr__ = _swig_repr

    def getName(self) -> "std::string":
        return _connect.CCoverageMetaInfo_getName(self)

    def getId(self) -> "std::string":
        return _connect.CCoverageMetaInfo_getId(self)

    def getDate(self) -> "std::string":
        return _connect.CCoverageMetaInfo_getDate(self)

    def getTime(self) -> "std::string":
        return _connect.CCoverageMetaInfo_getTime(self)

    def getSoftware(self) -> "std::string":
        return _connect.CCoverageMetaInfo_getSoftware(self)

    def getHardware(self) -> "std::string":
        return _connect.CCoverageMetaInfo_getHardware(self)

    def getDescription(self) -> "std::string":
        return _connect.CCoverageMetaInfo_getDescription(self)

    def getComment(self) -> "std::string":
        return _connect.CCoverageMetaInfo_getComment(self)

    def __init__(self):
        this = _connect.new_CCoverageMetaInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCoverageMetaInfo
    __del__ = lambda self: None
CCoverageMetaInfo_swigregister = _connect.CCoverageMetaInfo_swigregister
CCoverageMetaInfo_swigregister(CCoverageMetaInfo)

class CCoverageSource(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageSource, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageSource, name)
    __repr__ = _swig_repr
    EAreaExecuted = _connect.CCoverageSource_EAreaExecuted
    EAreaNotExecuted = _connect.CCoverageSource_EAreaNotExecuted
    EAreaPartiallyExecuted = _connect.CCoverageSource_EAreaPartiallyExecuted
    EConditionBoth = _connect.CCoverageSource_EConditionBoth
    EMixedStateOfMultipleConditions = _connect.CCoverageSource_EMixedStateOfMultipleConditions
    EConditionNotExecuted = _connect.CCoverageSource_EConditionNotExecuted
    EConditionWasNeverTrue = _connect.CCoverageSource_EConditionWasNeverTrue
    EConditionWasAlwaysTrue = _connect.CCoverageSource_EConditionWasAlwaysTrue
    EOutOfange = _connect.CCoverageSource_EOutOfange
    EEmpty = _connect.CCoverageSource_EEmpty

    def getSourceLineText(self) -> "std::string":
        return _connect.CCoverageSource_getSourceLineText(self)

    def getSourceLineNumber(self) -> "int":
        return _connect.CCoverageSource_getSourceLineNumber(self)

    def getAddress(self) -> "std::string":
        return _connect.CCoverageSource_getAddress(self)

    def getNumAsmOpCodes(self) -> "size_t":
        return _connect.CCoverageSource_getNumAsmOpCodes(self)

    def getAsmOpCodeInfo(self, idx: 'int') -> "isys::CCoverageSourceSPtr":
        return _connect.CCoverageSource_getAsmOpCodeInfo(self, idx)

    def getCoverageMarker(self) -> "isys::CCoverageSource::ESrcLineCoverageMarkers":
        return _connect.CCoverageSource_getCoverageMarker(self)

    def __init__(self):
        this = _connect.new_CCoverageSource()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCoverageSource
    __del__ = lambda self: None
CCoverageSource_swigregister = _connect.CCoverageSource_swigregister
CCoverageSource_swigregister(CCoverageSource)

class CCoverageStatistic2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageStatistic2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageStatistic2, name)
    __repr__ = _swig_repr
    EAnyArea = _connect.CCoverageStatistic2_EAnyArea
    EImages = _connect.CCoverageStatistic2_EImages
    EImage = _connect.CCoverageStatistic2_EImage
    EFolder = _connect.CCoverageStatistic2_EFolder
    EModule = _connect.CCoverageStatistic2_EModule
    EFunction = _connect.CCoverageStatistic2_EFunction
    ESrcLine = _connect.CCoverageStatistic2_ESrcLine
    EAsm = _connect.CCoverageStatistic2_EAsm
    ERange = _connect.CCoverageStatistic2_ERange
    ERanges = _connect.CCoverageStatistic2_ERanges

    def __init__(self, areaType: 'isys::CCoverageStatistic2::EAreaType'):
        this = _connect.new_CCoverageStatistic2(areaType)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getParent(self) -> "isys::CCoverageStatistic2SPtr":
        return _connect.CCoverageStatistic2_getParent(self)

    def getNumChildren(self) -> "size_t":
        return _connect.CCoverageStatistic2_getNumChildren(self)

    def getChild(self, idx: 'int') -> "isys::CCoverageStatistic2SPtr":
        return _connect.CCoverageStatistic2_getChild(self, idx)

    def getAreaType(self) -> "isys::CCoverageStatistic2::EAreaType":
        return _connect.CCoverageStatistic2_getAreaType(self)

    def getAreaName(self) -> "std::string":
        return _connect.CCoverageStatistic2_getAreaName(self)

    def getLinesAll(self) -> "int":
        return _connect.CCoverageStatistic2_getLinesAll(self)

    def getLinesExecuted(self) -> "int":
        return _connect.CCoverageStatistic2_getLinesExecuted(self)

    def getBytesAll(self) -> "int":
        return _connect.CCoverageStatistic2_getBytesAll(self)

    def getBytesExecuted(self) -> "int":
        return _connect.CCoverageStatistic2_getBytesExecuted(self)

    def getConditionsAll(self) -> "int":
        return _connect.CCoverageStatistic2_getConditionsAll(self)

    def getConditionsExecuted(self) -> "int":
        return _connect.CCoverageStatistic2_getConditionsExecuted(self)

    def getConditionsTrue(self) -> "int":
        return _connect.CCoverageStatistic2_getConditionsTrue(self)

    def getConditionsFalse(self) -> "int":
        return _connect.CCoverageStatistic2_getConditionsFalse(self)

    def getConditionsBoth(self) -> "int":
        return _connect.CCoverageStatistic2_getConditionsBoth(self)

    def getExecutionCount(self) -> "int":
        return _connect.CCoverageStatistic2_getExecutionCount(self)

    def getItemsCount(self) -> "int":
        return _connect.CCoverageStatistic2_getItemsCount(self)

    def getTextOrAbsPath(self) -> "std::string":
        return _connect.CCoverageStatistic2_getTextOrAbsPath(self)

    def getRelPath(self) -> "std::string":
        return _connect.CCoverageStatistic2_getRelPath(self)

    def getLineNumber(self) -> "int":
        return _connect.CCoverageStatistic2_getLineNumber(self)

    def getNumSourceLines(self) -> "size_t":
        return _connect.CCoverageStatistic2_getNumSourceLines(self)

    def getSourceLineInfo(self, idx: 'int') -> "isys::CCoverageSourceSPtr":
        return _connect.CCoverageStatistic2_getSourceLineInfo(self, idx)

    def getNumAsmLines(self) -> "size_t":
        return _connect.CCoverageStatistic2_getNumAsmLines(self)

    def getAsmLine(self, idx: 'int') -> "isys::CCoverageStatistic2AsmSPtr":
        return _connect.CCoverageStatistic2_getAsmLine(self, idx)

    def addStatItems(self, src: 'isys::CCoverageStatistic2SPtr const &') -> "void":
        return _connect.CCoverageStatistic2_addStatItems(self, src)
    if _newclass:
        areaType2Str = staticmethod(_connect.CCoverageStatistic2_areaType2Str)
    else:
        areaType2Str = _connect.CCoverageStatistic2_areaType2Str
    __swig_destroy__ = _connect.delete_CCoverageStatistic2
    __del__ = lambda self: None
CCoverageStatistic2_swigregister = _connect.CCoverageStatistic2_swigregister
CCoverageStatistic2_swigregister(CCoverageStatistic2)

def CCoverageStatistic2_areaType2Str(areaType: 'isys::CCoverageStatistic2::EAreaType') -> "std::string":
    return _connect.CCoverageStatistic2_areaType2Str(areaType)
CCoverageStatistic2_areaType2Str = _connect.CCoverageStatistic2_areaType2Str

class CCoverageStatistic2Asm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageStatistic2Asm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageStatistic2Asm, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CCoverageStatistic2Asm()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getLineType(self) -> "char":
        return _connect.CCoverageStatistic2Asm_getLineType(self)

    def getCoverageMarker(self) -> "isys::CCoverageSource::ESrcLineCoverageMarkers":
        return _connect.CCoverageStatistic2Asm_getCoverageMarker(self)

    def getAddress(self) -> "std::string":
        return _connect.CCoverageStatistic2Asm_getAddress(self)

    def getLineText(self) -> "std::string":
        return _connect.CCoverageStatistic2Asm_getLineText(self)

    def getLineNumber(self) -> "int":
        return _connect.CCoverageStatistic2Asm_getLineNumber(self)

    def getModuleName(self) -> "std::string":
        return _connect.CCoverageStatistic2Asm_getModuleName(self)
    __swig_destroy__ = _connect.delete_CCoverageStatistic2Asm
    __del__ = lambda self: None
CCoverageStatistic2Asm_swigregister = _connect.CCoverageStatistic2Asm_swigregister
CCoverageStatistic2Asm_swigregister(CCoverageStatistic2Asm)

class CCoverageStatIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageStatIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageStatIterator, name)
    __repr__ = _swig_repr

    def __init__(self, coverageData: 'isys::CCoverageData2SPtr', areaType: 'isys::CCoverageStatistic2::EAreaType', firstStat: 'isys::CCoverageStatistic2SPtr'):
        this = _connect.new_CCoverageStatIterator(coverageData, areaType, firstStat)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hasNext(self) -> "bool":
        return _connect.CCoverageStatIterator_hasNext(self)

    def next(self) -> "isys::CCoverageStatistic2SPtr":
        return _connect.CCoverageStatIterator_next(self)
    __swig_destroy__ = _connect.delete_CCoverageStatIterator
    __del__ = lambda self: None
CCoverageStatIterator_swigregister = _connect.CCoverageStatIterator_swigregister
CCoverageStatIterator_swigregister(CCoverageStatIterator)

class CCoverageData2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCoverageData2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCoverageData2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        createInstance = staticmethod(_connect.CCoverageData2_createInstance)
    else:
        createInstance = _connect.CCoverageData2_createInstance

    def getParserWarnings(self) -> "std::string":
        return _connect.CCoverageData2_getParserWarnings(self)

    def closeParser(self) -> "void":
        return _connect.CCoverageData2_closeParser(self)

    def getCoverageMetaInfo(self) -> "isys::CCoverageMetaInfoSPtr":
        return _connect.CCoverageData2_getCoverageMetaInfo(self)

    def getRoot(self) -> "isys::CCoverageStatistic2SPtr":
        return _connect.CCoverageData2_getRoot(self)

    def getStatistic(self, *args) -> "isys::CCoverageStatistic2SPtr":
        return _connect.CCoverageData2_getStatistic(self, *args)

    def getIterator(self, areaType: 'isys::CCoverageStatistic2::EAreaType') -> "isys::CCoverageStatIteratorSPtr":
        return _connect.CCoverageData2_getIterator(self, areaType)
    __swig_destroy__ = _connect.delete_CCoverageData2
    __del__ = lambda self: None
CCoverageData2_swigregister = _connect.CCoverageData2_swigregister
CCoverageData2_swigregister(CCoverageData2)

def CCoverageData2_createInstance(*args) -> "isys::CCoverageData2SPtr":
    return _connect.CCoverageData2_createInstance(*args)
CCoverageData2_createInstance = _connect.CCoverageData2_createInstance

class CProfilerArea2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerArea2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerArea2, name)
    __repr__ = _swig_repr
    EFunctions = _connect.CProfilerArea2_EFunctions
    EFunctionLines = _connect.CProfilerArea2_EFunctionLines
    EVariables = _connect.CProfilerArea2_EVariables
    EStateVariables = _connect.CProfilerArea2_EStateVariables
    EAUX = _connect.CProfilerArea2_EAUX
    EStateAUX = _connect.CProfilerArea2_EStateAUX
    EInspector = _connect.CProfilerArea2_EInspector
    EStateInspector = _connect.CProfilerArea2_EStateInspector

    def getAreaType(self) -> "isys::CProfilerArea2::EAreaType":
        return _connect.CProfilerArea2_getAreaType(self)

    def getHandle(self) -> "DWORD":
        return _connect.CProfilerArea2_getHandle(self)

    def getAreaName(self) -> "std::string":
        return _connect.CProfilerArea2_getAreaName(self)

    def getFileName(self) -> "std::string":
        return _connect.CProfilerArea2_getFileName(self)

    def getPath(self) -> "std::string":
        return _connect.CProfilerArea2_getPath(self)

    def getAreaId(self) -> "isys::areaHandle_t":
        return _connect.CProfilerArea2_getAreaId(self)

    def getValue(self) -> "int64_t":
        return _connect.CProfilerArea2_getValue(self)

    def getLineNumber(self) -> "DWORD":
        return _connect.CProfilerArea2_getLineNumber(self)

    def getParentHandle(self) -> "DWORD":
        return _connect.CProfilerArea2_getParentHandle(self)

    def getParentAreaName(self) -> "std::string":
        return _connect.CProfilerArea2_getParentAreaName(self)

    def getValueUnit(self) -> "std::string":
        return _connect.CProfilerArea2_getValueUnit(self)

    def getValueType(self) -> "std::string":
        return _connect.CProfilerArea2_getValueType(self)

    def hasStates(self) -> "bool":
        return _connect.CProfilerArea2_hasStates(self)

    def getStateAreaId(self, value: 'DWORD') -> "isys::areaHandle_t":
        return _connect.CProfilerArea2_getStateAreaId(self, value)
    if _newclass:
        handle2AreaId = staticmethod(_connect.CProfilerArea2_handle2AreaId)
    else:
        handle2AreaId = _connect.CProfilerArea2_handle2AreaId

    def __init__(self):
        this = _connect.new_CProfilerArea2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CProfilerArea2
    __del__ = lambda self: None
CProfilerArea2_swigregister = _connect.CProfilerArea2_swigregister
CProfilerArea2_swigregister(CProfilerArea2)

def CProfilerArea2_handle2AreaId(handle: 'DWORD', value: 'int64_t'=0) -> "isys::areaHandle_t":
    return _connect.CProfilerArea2_handle2AreaId(handle, value)
CProfilerArea2_handle2AreaId = _connect.CProfilerArea2_handle2AreaId

class CProfilerAreaIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerAreaIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerAreaIterator, name)
    __repr__ = _swig_repr

    def __init__(self, profilerData: 'isys::CProfilerData2SPtr', areaType: 'isys::CProfilerArea2::EAreaType'):
        this = _connect.new_CProfilerAreaIterator(profilerData, areaType)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hasNext(self) -> "bool":
        return _connect.CProfilerAreaIterator_hasNext(self)

    def next(self) -> "isys::CProfilerArea2":
        return _connect.CProfilerAreaIterator_next(self)
    __swig_destroy__ = _connect.delete_CProfilerAreaIterator
    __del__ = lambda self: None
CProfilerAreaIterator_swigregister = _connect.CProfilerAreaIterator_swigregister
CProfilerAreaIterator_swigregister(CProfilerAreaIterator)

class CProfilerStatistics2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerStatistics2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerStatistics2, name)
    __repr__ = _swig_repr
    ENetTimes = _connect.CProfilerStatistics2_ENetTimes
    EGrossTimes = _connect.CProfilerStatistics2_EGrossTimes
    ECallTimes = _connect.CProfilerStatistics2_ECallTimes
    EPeriodTimes = _connect.CProfilerStatistics2_EPeriodTimes
    EOutsideTimes = _connect.CProfilerStatistics2_EOutsideTimes
    EInactiveTimes = _connect.CProfilerStatistics2_EInactiveTimes
    EUnknown = _connect.CProfilerStatistics2_EUnknown

    def getAreaId(self) -> "isys::areaHandle_t":
        return _connect.CProfilerStatistics2_getAreaId(self)

    def getHandle(self) -> "DWORD":
        return _connect.CProfilerStatistics2_getHandle(self)

    def getAreaName(self) -> "std::string":
        return _connect.CProfilerStatistics2_getAreaName(self)

    def getParentAreaName(self) -> "std::string":
        return _connect.CProfilerStatistics2_getParentAreaName(self)

    def getAreaValue(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getAreaValue(self)

    def getNumHits(self) -> "DWORD":
        return _connect.CProfilerStatistics2_getNumHits(self)

    def getTotalTime(self, timeType: 'isys::CProfilerStatistics2::ETimeType') -> "int64_t":
        return _connect.CProfilerStatistics2_getTotalTime(self, timeType)

    def getMinTime(self, timeType: 'isys::CProfilerStatistics2::ETimeType') -> "int64_t":
        return _connect.CProfilerStatistics2_getMinTime(self, timeType)

    def getMinStartTime(self, timeType: 'isys::CProfilerStatistics2::ETimeType') -> "int64_t":
        return _connect.CProfilerStatistics2_getMinStartTime(self, timeType)

    def getMinEndTime(self, timeType: 'isys::CProfilerStatistics2::ETimeType') -> "int64_t":
        return _connect.CProfilerStatistics2_getMinEndTime(self, timeType)

    def getMaxTime(self, timeType: 'isys::CProfilerStatistics2::ETimeType') -> "int64_t":
        return _connect.CProfilerStatistics2_getMaxTime(self, timeType)

    def getMaxStartTime(self, timeType: 'isys::CProfilerStatistics2::ETimeType') -> "int64_t":
        return _connect.CProfilerStatistics2_getMaxStartTime(self, timeType)

    def getMaxEndTime(self, timeType: 'isys::CProfilerStatistics2::ETimeType') -> "int64_t":
        return _connect.CProfilerStatistics2_getMaxEndTime(self, timeType)

    def getAverageTime(self, timeType: 'isys::CProfilerStatistics2::ETimeType') -> "int64_t":
        return _connect.CProfilerStatistics2_getAverageTime(self, timeType)

    def getValueAverage(self) -> "double":
        return _connect.CProfilerStatistics2_getValueAverage(self)

    def getValueMin(self) -> "double":
        return _connect.CProfilerStatistics2_getValueMin(self)

    def getValueMax(self) -> "double":
        return _connect.CProfilerStatistics2_getValueMax(self)

    def getValueTimeOfMin(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getValueTimeOfMin(self)

    def getValueTimeOfMax(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getValueTimeOfMax(self)

    def getNetTotalTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getNetTotalTime(self)

    def getNetMinTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getNetMinTime(self)

    def getNetMaxTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getNetMaxTime(self)

    def getNetAverageTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getNetAverageTime(self)

    def getGrossTotalTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getGrossTotalTime(self)

    def getGrossMinTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getGrossMinTime(self)

    def getGrossMaxTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getGrossMaxTime(self)

    def getGrossAverageTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getGrossAverageTime(self)

    def getCallTotalTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getCallTotalTime(self)

    def getCallMinTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getCallMinTime(self)

    def getCallMaxTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getCallMaxTime(self)

    def getCallAverageTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getCallAverageTime(self)

    def getPeriodMinTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getPeriodMinTime(self)

    def getPeriodMaxTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getPeriodMaxTime(self)

    def getPeriodAverageTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getPeriodAverageTime(self)

    def getOutsideTotalTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getOutsideTotalTime(self)

    def getOutsideMinTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getOutsideMinTime(self)

    def getOutsideMaxTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getOutsideMaxTime(self)

    def getOutsideAverageTime(self) -> "int64_t":
        return _connect.CProfilerStatistics2_getOutsideAverageTime(self)

    def toString(self) -> "std::string":
        return _connect.CProfilerStatistics2_toString(self)

    def __init__(self):
        this = _connect.new_CProfilerStatistics2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CProfilerStatistics2
    __del__ = lambda self: None
CProfilerStatistics2_swigregister = _connect.CProfilerStatistics2_swigregister
CProfilerStatistics2_swigregister(CProfilerStatistics2)

UNDEF_EVENT_SOURCE = _connect.UNDEF_EVENT_SOURCE
class CProfilerTimeEvent(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerTimeEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerTimeEvent, name)
    __repr__ = _swig_repr
    EEvAny = _connect.CProfilerTimeEvent_EEvAny
    EEvWrite = _connect.CProfilerTimeEvent_EEvWrite
    EEvSuspend = _connect.CProfilerTimeEvent_EEvSuspend
    EEvResume = _connect.CProfilerTimeEvent_EEvResume
    EEvEnter = _connect.CProfilerTimeEvent_EEvEnter
    EEvExit = _connect.CProfilerTimeEvent_EEvExit

    def getAreaId(self) -> "isys::areaHandle_t":
        return _connect.CProfilerTimeEvent_getAreaId(self)

    def getHandle(self) -> "DWORD":
        return _connect.CProfilerTimeEvent_getHandle(self)

    def getEventType(self) -> "isys::CProfilerTimeEvent::EEventType":
        return _connect.CProfilerTimeEvent_getEventType(self)

    def getValue(self) -> "int64_t":
        return _connect.CProfilerTimeEvent_getValue(self)

    def getSignedValue(self) -> "int64_t":
        return _connect.CProfilerTimeEvent_getSignedValue(self)

    def getFloatValue(self) -> "double":
        return _connect.CProfilerTimeEvent_getFloatValue(self)

    def getUnit(self) -> "std::string":
        return _connect.CProfilerTimeEvent_getUnit(self)

    def getTime(self) -> "int64_t":
        return _connect.CProfilerTimeEvent_getTime(self)

    def getEventSource(self) -> "int":
        return _connect.CProfilerTimeEvent_getEventSource(self)

    def toString(self) -> "std::string":
        return _connect.CProfilerTimeEvent_toString(self)

    def __init__(self):
        this = _connect.new_CProfilerTimeEvent()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CProfilerTimeEvent
    __del__ = lambda self: None
CProfilerTimeEvent_swigregister = _connect.CProfilerTimeEvent_swigregister
CProfilerTimeEvent_swigregister(CProfilerTimeEvent)

class CProfilerTimelineIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerTimelineIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerTimelineIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def hasNext(self) -> "bool":
        return _connect.CProfilerTimelineIterator_hasNext(self)

    def next(self) -> "isys::CProfilerTimeEvent":
        return _connect.CProfilerTimelineIterator_next(self)
    __swig_destroy__ = _connect.delete_CProfilerTimelineIterator
    __del__ = lambda self: None
CProfilerTimelineIterator_swigregister = _connect.CProfilerTimelineIterator_swigregister
CProfilerTimelineIterator_swigregister(CProfilerTimelineIterator)

class CProfilerData2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerData2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerData2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        createInstance = staticmethod(_connect.CProfilerData2_createInstance)
    else:
        createInstance = _connect.CProfilerData2_createInstance

    def getParserWarnings(self) -> "std::string":
        return _connect.CProfilerData2_getParserWarnings(self)

    def closeParser(self) -> "void":
        return _connect.CProfilerData2_closeParser(self)

    def getAreaIterator(self, areaType: 'isys::CProfilerArea2::EAreaType') -> "isys::CProfilerAreaIterator":
        return _connect.CProfilerData2_getAreaIterator(self, areaType)

    def hasArea(self, *args) -> "bool":
        return _connect.CProfilerData2_hasArea(self, *args)

    def getArea(self, *args) -> "isys::CProfilerArea2":
        return _connect.CProfilerData2_getArea(self, *args)

    def hasStatisticsForArea(self, *args) -> "bool":
        return _connect.CProfilerData2_hasStatisticsForArea(self, *args)

    def hasStatisticsForStateArea(self, *args) -> "bool":
        return _connect.CProfilerData2_hasStatisticsForStateArea(self, *args)

    def getStatistics(self, *args) -> "isys::CProfilerStatistics2":
        return _connect.CProfilerData2_getStatistics(self, *args)

    def hasStatisticsForFunction(self, *args) -> "bool":
        return _connect.CProfilerData2_hasStatisticsForFunction(self, *args)

    def getStatisticsForFunction(self, *args) -> "isys::CProfilerStatistics2":
        return _connect.CProfilerData2_getStatisticsForFunction(self, *args)

    def getContexts(self, contexts: 'StrVector') -> "void":
        return _connect.CProfilerData2_getContexts(self, contexts)

    def getTimelineIterator(self, *args) -> "isys::CProfilerTimelineIterator":
        return _connect.CProfilerData2_getTimelineIterator(self, *args)
    __swig_destroy__ = _connect.delete_CProfilerData2
    __del__ = lambda self: None
CProfilerData2_swigregister = _connect.CProfilerData2_swigregister
CProfilerData2_swigregister(CProfilerData2)

def CProfilerData2_createInstance(*args) -> "isys::CProfilerData2SPtr":
    return _connect.CProfilerData2_createInstance(*args)
CProfilerData2_createInstance = _connect.CProfilerData2_createInstance

class CProfilerFormatBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerFormatBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerFormatBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EFmtText = _connect.CProfilerFormatBase_EFmtText
    EFmtXML = _connect.CProfilerFormatBase_EFmtXML
    EFmtCSV = _connect.CProfilerFormatBase_EFmtCSV
    EFmtText1 = _connect.CProfilerFormatBase_EFmtText1
    EFmtBTF = _connect.CProfilerFormatBase_EFmtBTF

    def getExportFormat(self) -> "isys::CProfilerFormatBase::EExportFormat":
        return _connect.CProfilerFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self) -> "std::string":
        return _connect.CProfilerFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CProfilerFormatBase_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerFormatBase
    __del__ = lambda self: None
CProfilerFormatBase_swigregister = _connect.CProfilerFormatBase_swigregister
CProfilerFormatBase_swigregister(CProfilerFormatBase)

class CProfilerTextExportFormat(CProfilerFormatBase):
    __swig_setmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerTextExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerTextExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CProfilerTextExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CProfilerTextExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerTextExportFormat
    __del__ = lambda self: None
CProfilerTextExportFormat_swigregister = _connect.CProfilerTextExportFormat_swigregister
CProfilerTextExportFormat_swigregister(CProfilerTextExportFormat)

class CProfilerText1ExportFormat(CProfilerFormatBase):
    __swig_setmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerText1ExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerText1ExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CProfilerText1ExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setOption(self, profiler: 'isys::CProfilerController2SPtr &', option: 'std::string const &', value: 'std::string const &') -> "isys::CProfilerText1ExportFormat &":
        return _connect.CProfilerText1ExportFormat_setOption(self, profiler, option, value)

    def getOption(self, profiler: 'isys::CProfilerController2SPtr &', option: 'std::string const &') -> "std::string":
        return _connect.CProfilerText1ExportFormat_getOption(self, profiler, option)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CProfilerText1ExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerText1ExportFormat
    __del__ = lambda self: None
CProfilerText1ExportFormat_swigregister = _connect.CProfilerText1ExportFormat_swigregister
CProfilerText1ExportFormat_swigregister(CProfilerText1ExportFormat)

class CProfilerCSVExportFormat(CProfilerFormatBase):
    __swig_setmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerCSVExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerCSVExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CProfilerCSVExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setDelimiter(self, delimiter: 'std::string const &') -> "isys::CProfilerCSVExportFormat &":
        return _connect.CProfilerCSVExportFormat_setDelimiter(self, delimiter)

    def getDelimiter(self) -> "std::string":
        return _connect.CProfilerCSVExportFormat_getDelimiter(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CProfilerCSVExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerCSVExportFormat
    __del__ = lambda self: None
CProfilerCSVExportFormat_swigregister = _connect.CProfilerCSVExportFormat_swigregister
CProfilerCSVExportFormat_swigregister(CProfilerCSVExportFormat)

class CProfilerXMLExportFormat(CProfilerFormatBase):
    __swig_setmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerXMLExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerXMLExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CProfilerXMLExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setTimelineBinary(self, isTimelineBinary: 'bool') -> "isys::CProfilerXMLExportFormat &":
        return _connect.CProfilerXMLExportFormat_setTimelineBinary(self, isTimelineBinary)

    def setUseIndent(self, isUseIndent: 'bool') -> "isys::CProfilerXMLExportFormat &":
        return _connect.CProfilerXMLExportFormat_setUseIndent(self, isUseIndent)

    def isTimelineBinary(self) -> "bool":
        return _connect.CProfilerXMLExportFormat_isTimelineBinary(self)

    def isUseIndent(self) -> "bool":
        return _connect.CProfilerXMLExportFormat_isUseIndent(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CProfilerXMLExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerXMLExportFormat
    __del__ = lambda self: None
CProfilerXMLExportFormat_swigregister = _connect.CProfilerXMLExportFormat_swigregister
CProfilerXMLExportFormat_swigregister(CProfilerXMLExportFormat)

class CProfilerBTFExportFormat(CProfilerFormatBase):
    __swig_setmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerBTFExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CProfilerFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerBTFExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CProfilerBTFExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CProfilerBTFExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerBTFExportFormat
    __del__ = lambda self: None
CProfilerBTFExportFormat_swigregister = _connect.CProfilerBTFExportFormat_swigregister
CProfilerBTFExportFormat_swigregister(CProfilerBTFExportFormat)

class CProfilerExportConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerExportConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerExportConfig, name)
    __repr__ = _swig_repr
    EContextAll = _connect.CProfilerExportConfig_EContextAll
    EContextNeutral = _connect.CProfilerExportConfig_EContextNeutral
    EContextCurrent = _connect.CProfilerExportConfig_EContextCurrent
    EAreaAll = _connect.CProfilerExportConfig_EAreaAll
    EAreaFilter = _connect.CProfilerExportConfig_EAreaFilter
    ETimeAll = _connect.CProfilerExportConfig_ETimeAll
    ETimeBetweenMarkers = _connect.CProfilerExportConfig_ETimeBetweenMarkers
    EPNameAuto = _connect.CProfilerExportConfig_EPNameAuto
    EPNameAlways = _connect.CProfilerExportConfig_EPNameAlways
    EPNameNever = _connect.CProfilerExportConfig_EPNameNever
    EPNameConfigName = _connect.CProfilerExportConfig_EPNameConfigName

    def __init__(self):
        this = _connect.new_CProfilerExportConfig()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setFileName(self, fileName: 'std::string const &') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setFileName(self, fileName)

    def setFormatter(self, formatter: 'isys::CProfilerFormatBaseSPtr &') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setFormatter(self, formatter)

    def setAreaScope(self, areaScope: 'isys::CProfilerExportConfig::EAreaScope') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setAreaScope(self, areaScope)

    def setExportActiveAreasOnly(self, isExportActiveAreasOnly: 'bool') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setExportActiveAreasOnly(self, isExportActiveAreasOnly)

    def setAreaExportSections(self, *args) -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setAreaExportSections(self, *args)

    def setTimeScope(self, timeScope: 'isys::CProfilerExportConfig::ETimeScope') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setTimeScope(self, timeScope)

    def setFunctionsFilter(self, namesOfFunctions: 'std::string const &') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setFunctionsFilter(self, namesOfFunctions)

    def setVariablesFilter(self, namesOfVariables: 'std::string const &') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setVariablesFilter(self, namesOfVariables)

    def setAUXFilter(self, namesOfIOPorts: 'std::string const &') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setAUXFilter(self, namesOfIOPorts)

    def setTimeFilter(self, startTime: 'int64_t', endTime: 'int64_t') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setTimeFilter(self, startTime, endTime)

    def setContextFilter(self, contextToExport: 'std::string const &') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setContextFilter(self, contextToExport)

    def setLaunchViewer(self, isLaunchViewer: 'bool') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setSaveStatistics(self, isSaveStatistics: 'bool') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setSaveStatistics(self, isSaveStatistics)

    def setSaveInfo(self, isSaveInfo: 'bool') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setSaveInfo(self, isSaveInfo)

    def setSaveTimeline(self, isSaveTimeline: 'bool') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setSaveTimeline(self, isSaveTimeline)

    def setContextScope(self, saveContext: 'isys::CProfilerExportConfig::EContextScope') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setContextScope(self, saveContext)

    def setExportPartitionNameMode(self, exportPartNameMode: 'isys::CProfilerExportConfig::EExportPartitionNameMode') -> "isys::CProfilerExportConfig &":
        return _connect.CProfilerExportConfig_setExportPartitionNameMode(self, exportPartNameMode)

    def getFileName(self) -> "std::string":
        return _connect.CProfilerExportConfig_getFileName(self)

    def getAreaScope(self) -> "isys::CProfilerExportConfig::EAreaScope":
        return _connect.CProfilerExportConfig_getAreaScope(self)

    def isExportFunctions(self) -> "bool":
        return _connect.CProfilerExportConfig_isExportFunctions(self)

    def isExportLines(self) -> "bool":
        return _connect.CProfilerExportConfig_isExportLines(self)

    def isExportData(self) -> "bool":
        return _connect.CProfilerExportConfig_isExportData(self)

    def isExportAUX(self) -> "bool":
        return _connect.CProfilerExportConfig_isExportAUX(self)

    def isExportActiveAreasOnly(self) -> "bool":
        return _connect.CProfilerExportConfig_isExportActiveAreasOnly(self)

    def getTimeScope(self) -> "isys::CProfilerExportConfig::ETimeScope":
        return _connect.CProfilerExportConfig_getTimeScope(self)

    def getFunctionsFilter(self) -> "std::string":
        return _connect.CProfilerExportConfig_getFunctionsFilter(self)

    def getVariablesFilter(self) -> "std::string":
        return _connect.CProfilerExportConfig_getVariablesFilter(self)

    def getAUXFilter(self) -> "std::string":
        return _connect.CProfilerExportConfig_getAUXFilter(self)

    def getStartTime(self) -> "int64_t":
        return _connect.CProfilerExportConfig_getStartTime(self)

    def getEndTime(self) -> "int64_t":
        return _connect.CProfilerExportConfig_getEndTime(self)

    def getContextFilter(self) -> "std::string":
        return _connect.CProfilerExportConfig_getContextFilter(self)

    def isLaunchViewer(self) -> "bool":
        return _connect.CProfilerExportConfig_isLaunchViewer(self)

    def isSaveStatistics(self) -> "bool":
        return _connect.CProfilerExportConfig_isSaveStatistics(self)

    def isSaveTimeline(self) -> "bool":
        return _connect.CProfilerExportConfig_isSaveTimeline(self)

    def isSaveInfo(self) -> "bool":
        return _connect.CProfilerExportConfig_isSaveInfo(self)

    def getContextScope(self) -> "isys::CProfilerExportConfig::EContextScope":
        return _connect.CProfilerExportConfig_getContextScope(self)

    def getExportPartitionNameMode(self) -> "isys::CProfilerExportConfig::EExportPartitionNameMode":
        return _connect.CProfilerExportConfig_getExportPartitionNameMode(self)

    def getFormatter(self) -> "isys::CProfilerFormatBaseSPtr":
        return _connect.CProfilerExportConfig_getFormatter(self)

    def getContextScopeAsStr(self) -> "std::string":
        return _connect.CProfilerExportConfig_getContextScopeAsStr(self)

    def getExportPartitionNameModeAsStr(self) -> "std::string":
        return _connect.CProfilerExportConfig_getExportPartitionNameModeAsStr(self)

    def getAreaScopeAsStr(self) -> "std::string":
        return _connect.CProfilerExportConfig_getAreaScopeAsStr(self)

    def getTimeScopeAsStr(self) -> "std::string":
        return _connect.CProfilerExportConfig_getTimeScopeAsStr(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CProfilerExportConfig_setOptions(self, ide, docFileName)

    def toString(self) -> "std::string":
        return _connect.CProfilerExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerExportConfig
    __del__ = lambda self: None
CProfilerExportConfig_swigregister = _connect.CProfilerExportConfig_swigregister
CProfilerExportConfig_swigregister(CProfilerExportConfig)

class CProfilerController2(CAnalyzerDocController):
    __swig_setmethods__ = {}
    for _s in [CAnalyzerDocController]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerController2, name, value)
    __swig_getmethods__ = {}
    for _s in [CAnalyzerDocController]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerController2, name)
    __repr__ = _swig_repr
    ERWRead = _connect.CProfilerController2_ERWRead
    ERWWrite = _connect.CProfilerController2_ERWWrite
    ERWReadOrWrite = _connect.CProfilerController2_ERWReadOrWrite
    EDATState = _connect.CProfilerController2_EDATState
    EDATLsbExitEntry = _connect.CProfilerController2_EDATLsbExitEntry
    EDATZeroExitEntry = _connect.CProfilerController2_EDATZeroExitEntry
    EDATRegular = _connect.CProfilerController2_EDATRegular
    EStateDefNone = _connect.CProfilerController2_EStateDefNone
    EStateDefDefine = _connect.CProfilerController2_EStateDefDefine
    EStateDefEnum = _connect.CProfilerController2_EStateDefEnum
    ESingleData = _connect.CProfilerController2_ESingleData
    ESingleData1 = _connect.CProfilerController2_ESingleData1

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >', fileName: 'std::string const &', mode: 'std::string const &'):
        this = _connect.new_CProfilerController2(connectionMgr, fileName, mode)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CProfilerController2
    __del__ = lambda self: None

    def createTrigger(self, triggerName: 'std::string const &') -> "int":
        return _connect.CProfilerController2_createTrigger(self, triggerName)

    def setProfilingSections(self, triggerIndex: 'int', isProfileCode: 'bool', isProfileData: 'bool', isProfileOSObjects: 'bool', isProfileAUX: 'bool') -> "void":
        return _connect.CProfilerController2_setProfilingSections(self, triggerIndex, isProfileCode, isProfileData, isProfileOSObjects, isProfileAUX)

    def setFunctionTrigger(self, triggerIndex: 'int', functionName: 'std::string const &') -> "void":
        return _connect.CProfilerController2_setFunctionTrigger(self, triggerIndex, functionName)

    def addFunction(self, triggerIndex: 'int', functionName: 'std::string const &', isIncludeFunctionLines: 'bool'=False) -> "int":
        return _connect.CProfilerController2_addFunction(self, triggerIndex, functionName, isIncludeFunctionLines)

    def addFunctions(self, triggerIndex: 'int', functions: 'StrVector') -> "void":
        return _connect.CProfilerController2_addFunctions(self, triggerIndex, functions)

    def addVariable(self, triggerIndex: 'int', variableName: 'std::string const &', dataAreaType: 'isys::CProfilerController2::EDataAreaType') -> "int":
        return _connect.CProfilerController2_addVariable(self, triggerIndex, variableName, dataAreaType)

    def addTraceMessage(self, triggerIndex: 'int', traceMessage: 'std::string const &', dataAreaType: 'isys::CProfilerController2::EDataAreaType', messageType: 'isys::CProfilerController2::ETraceMessageType') -> "int":
        return _connect.CProfilerController2_addTraceMessage(self, triggerIndex, traceMessage, dataAreaType, messageType)

    def addStateVariable(self, triggerIndex: 'int', variableName: 'std::string const &', stateVarDef: 'isys::CProfilerController2::EStateVarDefinition', definitonName: 'std::string const') -> "int":
        return _connect.CProfilerController2_addStateVariable(self, triggerIndex, variableName, stateVarDef, definitonName)

    def addAuxVariable(self, triggerIndex: 'int', variableName: 'std::string const &', dataAreaType: 'isys::CProfilerController2::EDataAreaType') -> "int":
        return _connect.CProfilerController2_addAuxVariable(self, triggerIndex, variableName, dataAreaType)

    def removeFunction(self, triggerIndex: 'int', functionName: 'std::string const &') -> "int":
        return _connect.CProfilerController2_removeFunction(self, triggerIndex, functionName)

    def removeVariable(self, triggerIndex: 'int', variableName: 'std::string const &') -> "int":
        return _connect.CProfilerController2_removeVariable(self, triggerIndex, variableName)

    def removeAllFunctions(self, triggerIndex: 'int') -> "void":
        return _connect.CProfilerController2_removeAllFunctions(self, triggerIndex)

    def removeAllVariables(self, triggerIndex: 'int') -> "void":
        return _connect.CProfilerController2_removeAllVariables(self, triggerIndex)

    def getSessionDuration(self, triggerIndex: 'int') -> "int":
        return _connect.CProfilerController2_getSessionDuration(self, triggerIndex)

    def setSessionDuration(self, triggerIndex: 'int', sessionDurationInMilliseconds: 'int') -> "void":
        return _connect.CProfilerController2_setSessionDuration(self, triggerIndex, sessionDurationInMilliseconds)

    def exportData(self, exportConfig: 'CProfilerExportConfig') -> "void":
        return _connect.CProfilerController2_exportData(self, exportConfig)

    def dataAreaType2Str(self, dataAreaType: 'isys::CProfilerController2::EDataAreaType') -> "std::string":
        return _connect.CProfilerController2_dataAreaType2Str(self, dataAreaType)

    def stateVarDef2Str(self, stateVarDef: 'isys::CProfilerController2::EStateVarDefinition') -> "std::string":
        return _connect.CProfilerController2_stateVarDef2Str(self, stateVarDef)

    def traceMsgDef2Str(self, traceMsgType: 'isys::CProfilerController2::ETraceMessageType') -> "std::string":
        return _connect.CProfilerController2_traceMsgDef2Str(self, traceMsgType)
CProfilerController2_swigregister = _connect.CProfilerController2_swigregister
CProfilerController2_swigregister(CProfilerController2)

class CTraceFormatBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceFormatBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceFormatBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EFmtText = _connect.CTraceFormatBase_EFmtText
    EFmtCSV = _connect.CTraceFormatBase_EFmtCSV
    EFmtBinary = _connect.CTraceFormatBase_EFmtBinary
    EFmtXML = _connect.CTraceFormatBase_EFmtXML

    def getExportFormat(self) -> "isys::CTraceFormatBase::EExportFormat":
        return _connect.CTraceFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self) -> "std::string":
        return _connect.CTraceFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CTraceFormatBase_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceFormatBase
    __del__ = lambda self: None
CTraceFormatBase_swigregister = _connect.CTraceFormatBase_swigregister
CTraceFormatBase_swigregister(CTraceFormatBase)

class CTraceTextExportFormat(CTraceFormatBase):
    __swig_setmethods__ = {}
    for _s in [CTraceFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceTextExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CTraceFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceTextExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CTraceTextExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setContentLen(self, contentLen: 'int') -> "isys::CTraceTextExportFormat &":
        return _connect.CTraceTextExportFormat_setContentLen(self, contentLen)

    def getContentLen(self) -> "int":
        return _connect.CTraceTextExportFormat_getContentLen(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CTraceTextExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceTextExportFormat
    __del__ = lambda self: None
CTraceTextExportFormat_swigregister = _connect.CTraceTextExportFormat_swigregister
CTraceTextExportFormat_swigregister(CTraceTextExportFormat)

class CTraceCSVExportFormat(CTraceFormatBase):
    __swig_setmethods__ = {}
    for _s in [CTraceFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceCSVExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CTraceFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceCSVExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CTraceCSVExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSeparator(self, separator: 'std::string const &') -> "isys::CTraceCSVExportFormat &":
        return _connect.CTraceCSVExportFormat_setSeparator(self, separator)

    def setColumnHeaders(self, isColumnHeaders: 'bool') -> "isys::CTraceCSVExportFormat &":
        return _connect.CTraceCSVExportFormat_setColumnHeaders(self, isColumnHeaders)

    def setFunctionTree(self, isFunctionTree: 'bool') -> "isys::CTraceCSVExportFormat &":
        return _connect.CTraceCSVExportFormat_setFunctionTree(self, isFunctionTree)

    def getSeparator(self) -> "std::string":
        return _connect.CTraceCSVExportFormat_getSeparator(self)

    def isColumnHeaders(self) -> "int":
        return _connect.CTraceCSVExportFormat_isColumnHeaders(self)

    def isFunctionTree(self) -> "int":
        return _connect.CTraceCSVExportFormat_isFunctionTree(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CTraceCSVExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceCSVExportFormat
    __del__ = lambda self: None
CTraceCSVExportFormat_swigregister = _connect.CTraceCSVExportFormat_swigregister
CTraceCSVExportFormat_swigregister(CTraceCSVExportFormat)

class CTraceXMLExportFormat(CTraceFormatBase):
    __swig_setmethods__ = {}
    for _s in [CTraceFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceXMLExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CTraceFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceXMLExportFormat, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CTraceXMLExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setIndex(self, isIndex: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setIndex(self, isIndex)

    def setTime(self, isTime: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setTime(self, isTime)

    def setTraceSourceId(self, isTraceSourceId: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setTraceSourceId(self, isTraceSourceId)

    def setAddress(self, isAddress: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setAddress(self, isAddress)

    def setMemArea(self, isMemArea: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setMemArea(self, isMemArea)

    def setData(self, isData: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setData(self, isData)

    def setDasm(self, isDasm: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setDasm(self, isDasm)

    def setDasmData(self, isDasmData: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setDasmData(self, isDasmData)

    def setDasmAddress(self, isDasmAddress: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setDasmAddress(self, isDasmAddress)

    def setFunction(self, isFunction: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setFunction(self, isFunction)

    def setLabel(self, isLabel: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setLabel(self, isLabel)

    def setSourceLine(self, isSourceLine: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setSourceLine(self, isSourceLine)

    def setActivity(self, isActivity: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setActivity(self, isActivity)

    def setBusStatus(self, isBusStatus: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setBusStatus(self, isBusStatus)

    def setAUX(self, isAUX: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setAUX(self, isAUX)

    def setOCT(self, isOCT: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setOCT(self, isOCT)

    def setUseIndent(self, isUseIndent: 'bool') -> "isys::CTraceXMLExportFormat &":
        return _connect.CTraceXMLExportFormat_setUseIndent(self, isUseIndent)

    def isIndex(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isIndex(self)

    def isTime(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isTime(self)

    def isTraceSourceId(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isTraceSourceId(self)

    def isAddress(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isAddress(self)

    def isMemArea(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isMemArea(self)

    def isData(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isData(self)

    def isDasm(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isDasm(self)

    def isDasmData(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isDasmData(self)

    def isDasmAddress(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isDasmAddress(self)

    def isFunction(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isFunction(self)

    def isLabel(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isLabel(self)

    def isSourceLine(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isSourceLine(self)

    def isActivity(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isActivity(self)

    def isBusStatus(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isBusStatus(self)

    def isAUX(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isAUX(self)

    def isOCT(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isOCT(self)

    def isUseIndent(self) -> "bool":
        return _connect.CTraceXMLExportFormat_isUseIndent(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CTraceXMLExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceXMLExportFormat
    __del__ = lambda self: None
CTraceXMLExportFormat_swigregister = _connect.CTraceXMLExportFormat_swigregister
CTraceXMLExportFormat_swigregister(CTraceXMLExportFormat)

class CTraceBinExportFormat(CTraceFormatBase):
    __swig_setmethods__ = {}
    for _s in [CTraceFormatBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceBinExportFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [CTraceFormatBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceBinExportFormat, name)
    __repr__ = _swig_repr
    EHeaderVer1 = _connect.CTraceBinExportFormat_EHeaderVer1
    EHeaderVer2 = _connect.CTraceBinExportFormat_EHeaderVer2
    EDataItem = _connect.CTraceBinExportFormat_EDataItem
    EAddressItem = _connect.CTraceBinExportFormat_EAddressItem
    EMemAreaItem = _connect.CTraceBinExportFormat_EMemAreaItem
    ETimeStampItem = _connect.CTraceBinExportFormat_ETimeStampItem
    EBusStatusItem = _connect.CTraceBinExportFormat_EBusStatusItem
    ESampleIndexItem = _connect.CTraceBinExportFormat_ESampleIndexItem
    EOCDItem = _connect.CTraceBinExportFormat_EOCDItem
    EAUXItem = _connect.CTraceBinExportFormat_EAUXItem
    EPresenceFlagsItem = _connect.CTraceBinExportFormat_EPresenceFlagsItem
    ETraceSourceIdItem = _connect.CTraceBinExportFormat_ETraceSourceIdItem

    def __init__(self):
        this = _connect.new_CTraceBinExportFormat()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setHeader(self, isHeader: 'bool') -> "isys::CTraceBinExportFormat &":
        return _connect.CTraceBinExportFormat_setHeader(self, isHeader)

    def setHeaderVersion(self, headerVersion: 'isys::CTraceBinExportFormat::EHeaderVersion') -> "isys::CTraceBinExportFormat &":
        return _connect.CTraceBinExportFormat_setHeaderVersion(self, headerVersion)

    def setNumOfCpuBuses(self, numberOfCpuBusses: 'int') -> "isys::CTraceBinExportFormat &":
        return _connect.CTraceBinExportFormat_setNumOfCpuBuses(self, numberOfCpuBusses)

    def setNumMAUs(self, numMAUs: 'int') -> "isys::CTraceBinExportFormat &":
        return _connect.CTraceBinExportFormat_setNumMAUs(self, numMAUs)

    def setNumBusStatusBytes(self, numBusStatusBytes: 'int') -> "isys::CTraceBinExportFormat &":
        return _connect.CTraceBinExportFormat_setNumBusStatusBytes(self, numBusStatusBytes)

    def setTraceItemFlags(self, presenceFlags: 'unsigned short') -> "isys::CTraceBinExportFormat &":
        return _connect.CTraceBinExportFormat_setTraceItemFlags(self, presenceFlags)

    def addTraceItem(self, presenceFlag: 'isys::CTraceBinExportFormat::EPresenceFlags') -> "isys::CTraceBinExportFormat &":
        return _connect.CTraceBinExportFormat_addTraceItem(self, presenceFlag)

    def removeTraceItem(self, presenceFlag: 'isys::CTraceBinExportFormat::EPresenceFlags') -> "isys::CTraceBinExportFormat &":
        return _connect.CTraceBinExportFormat_removeTraceItem(self, presenceFlag)

    def isHeader(self) -> "bool":
        return _connect.CTraceBinExportFormat_isHeader(self)

    def getHeaderVersion(self) -> "isys::CTraceBinExportFormat::EHeaderVersion":
        return _connect.CTraceBinExportFormat_getHeaderVersion(self)

    def getHeaderVersionAsStr(self) -> "std::string":
        return _connect.CTraceBinExportFormat_getHeaderVersionAsStr(self)

    def getNumOfCpuBuses(self) -> "int":
        return _connect.CTraceBinExportFormat_getNumOfCpuBuses(self)

    def getNumMAUs(self) -> "int":
        return _connect.CTraceBinExportFormat_getNumMAUs(self)

    def getNumBusStatusBytes(self) -> "int":
        return _connect.CTraceBinExportFormat_getNumBusStatusBytes(self)

    def getPresenceFlags(self) -> "unsigned short":
        return _connect.CTraceBinExportFormat_getPresenceFlags(self)

    def isTraceItem(self, itemMask: 'isys::CTraceBinExportFormat::EPresenceFlags') -> "bool":
        return _connect.CTraceBinExportFormat_isTraceItem(self, itemMask)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CTraceBinExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceBinExportFormat
    __del__ = lambda self: None
CTraceBinExportFormat_swigregister = _connect.CTraceBinExportFormat_swigregister
CTraceBinExportFormat_swigregister(CTraceBinExportFormat)

class CTraceExportConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceExportConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceExportConfig, name)
    __repr__ = _swig_repr
    ETimeAll = _connect.CTraceExportConfig_ETimeAll
    ETimeBetweenMarkers = _connect.CTraceExportConfig_ETimeBetweenMarkers

    def __init__(self):
        this = _connect.new_CTraceExportConfig()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setFileName(self, fileName: 'std::string const &') -> "isys::CTraceExportConfig &":
        return _connect.CTraceExportConfig_setFileName(self, fileName)

    def setLaunchViewer(self, isLaunchViewer: 'bool') -> "isys::CTraceExportConfig &":
        return _connect.CTraceExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setTimeScope(self, timeScope: 'isys::CTraceExportConfig::ETimeScope') -> "isys::CTraceExportConfig &":
        return _connect.CTraceExportConfig_setTimeScope(self, timeScope)

    def setTimeFilter(self, startTime: 'int64_t', endTime: 'int64_t') -> "isys::CTraceExportConfig &":
        return _connect.CTraceExportConfig_setTimeFilter(self, startTime, endTime)

    def setFormatter(self, formatter: 'isys::CTraceFormatBaseSPtr &') -> "isys::CTraceExportConfig &":
        return _connect.CTraceExportConfig_setFormatter(self, formatter)

    def getFileName(self) -> "std::string":
        return _connect.CTraceExportConfig_getFileName(self)

    def isLaunchViewer(self) -> "bool":
        return _connect.CTraceExportConfig_isLaunchViewer(self)

    def getTimeScope(self) -> "isys::CTraceExportConfig::ETimeScope":
        return _connect.CTraceExportConfig_getTimeScope(self)

    def getTimeScopeAsStr(self) -> "std::string":
        return _connect.CTraceExportConfig_getTimeScopeAsStr(self)

    def getStartTime(self) -> "int64_t":
        return _connect.CTraceExportConfig_getStartTime(self)

    def getEndTime(self) -> "int64_t":
        return _connect.CTraceExportConfig_getEndTime(self)

    def getFormatter(self) -> "isys::CTraceFormatBaseSPtr":
        return _connect.CTraceExportConfig_getFormatter(self)

    def setOptions(self, ide: 'CIDEController', docFileName: 'std::string const &') -> "void":
        return _connect.CTraceExportConfig_setOptions(self, ide, docFileName)

    def toString(self) -> "std::string":
        return _connect.CTraceExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CTraceExportConfig
    __del__ = lambda self: None
CTraceExportConfig_swigregister = _connect.CTraceExportConfig_swigregister
CTraceExportConfig_swigregister(CTraceExportConfig)

class CTraceController(CAnalyzerDocController):
    __swig_setmethods__ = {}
    for _s in [CAnalyzerDocController]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceController, name, value)
    __swig_getmethods__ = {}
    for _s in [CAnalyzerDocController]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >', fileName: 'std::string const &', mode: 'std::string const &'):
        this = _connect.new_CTraceController(connectionMgr, fileName, mode)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTraceController
    __del__ = lambda self: None

    def createTrigger(self, triggerName: 'std::string const &') -> "int":
        return _connect.CTraceController_createTrigger(self, triggerName)

    def applyTriggerWizard(self, traceWizardConfig: 'isys::CTraceConfigWizardSPtr &', triggerIdx: 'int') -> "void":
        return _connect.CTraceController_applyTriggerWizard(self, traceWizardConfig, triggerIdx)

    def exportData(self, exportConfig: 'CTraceExportConfig') -> "void":
        return _connect.CTraceController_exportData(self, exportConfig)
CTraceController_swigregister = _connect.CTraceController_swigregister
CTraceController_swigregister(CTraceController)

class CTraceTimeEvent(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceTimeEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceTimeEvent, name)
    __repr__ = _swig_repr

    def isTraceItem(self, itemMask: 'isys::CTraceBinExportFormat::EPresenceFlags') -> "bool":
        return _connect.CTraceTimeEvent_isTraceItem(self, itemMask)

    def getSampleIndex(self) -> "int64_t":
        return _connect.CTraceTimeEvent_getSampleIndex(self)

    def getSubSampleIndex(self) -> "int64_t":
        return _connect.CTraceTimeEvent_getSubSampleIndex(self)

    def getTime(self) -> "int64_t":
        return _connect.CTraceTimeEvent_getTime(self)

    def getTraceSourceId(self) -> "uint8_t":
        return _connect.CTraceTimeEvent_getTraceSourceId(self)

    def getAddress(self, busIndex: 'int') -> "int64_t":
        return _connect.CTraceTimeEvent_getAddress(self, busIndex)

    def getMemArea(self, busIndex: 'int') -> "int":
        return _connect.CTraceTimeEvent_getMemArea(self, busIndex)

    def getData(self, busIndex: 'int') -> "DWORD":
        return _connect.CTraceTimeEvent_getData(self, busIndex)

    def getBusStatus(self, status: 'VectorBYTE') -> "void":
        return _connect.CTraceTimeEvent_getBusStatus(self, status)

    def getDasm(self) -> "std::string":
        return _connect.CTraceTimeEvent_getDasm(self)

    def getFunc(self) -> "std::string":
        return _connect.CTraceTimeEvent_getFunc(self)

    def getLabel(self) -> "std::string":
        return _connect.CTraceTimeEvent_getLabel(self)

    def getSrc(self) -> "std::string":
        return _connect.CTraceTimeEvent_getSrc(self)

    def getBusActivity(self) -> "std::string":
        return _connect.CTraceTimeEvent_getBusActivity(self)

    def getOnChipData(self, data: 'VectorOnChipData') -> "void":
        return _connect.CTraceTimeEvent_getOnChipData(self, data)

    def getAuxData(self, channelName: 'std::string const &') -> "float":
        return _connect.CTraceTimeEvent_getAuxData(self, channelName)

    def getAuxChannels(self, channels: 'StrVector') -> "void":
        return _connect.CTraceTimeEvent_getAuxChannels(self, channels)

    def toString(self) -> "std::string":
        return _connect.CTraceTimeEvent_toString(self)

    def __init__(self):
        this = _connect.new_CTraceTimeEvent()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTraceTimeEvent
    __del__ = lambda self: None
CTraceTimeEvent_swigregister = _connect.CTraceTimeEvent_swigregister
CTraceTimeEvent_swigregister(CTraceTimeEvent)

class CTraceTimelineIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceTimelineIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceTimelineIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def hasNext(self) -> "bool":
        return _connect.CTraceTimelineIterator_hasNext(self)

    def next(self) -> "isys::CTraceTimeEvent":
        return _connect.CTraceTimelineIterator_next(self)

    def nextAsSPtr(self) -> "isys::CTraceTimeEventSPtr":
        return _connect.CTraceTimelineIterator_nextAsSPtr(self)
    __swig_destroy__ = _connect.delete_CTraceTimelineIterator
    __del__ = lambda self: None
CTraceTimelineIterator_swigregister = _connect.CTraceTimelineIterator_swigregister
CTraceTimelineIterator_swigregister(CTraceTimelineIterator)

class CTraceData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        createInstance = staticmethod(_connect.CTraceData_createInstance)
    else:
        createInstance = _connect.CTraceData_createInstance

    def getBinaryExportConfig(self) -> "isys::CTraceBinExportFormatSPtr":
        return _connect.CTraceData_getBinaryExportConfig(self)

    def getParserWarnings(self) -> "std::string":
        return _connect.CTraceData_getParserWarnings(self)

    def closeParser(self) -> "void":
        return _connect.CTraceData_closeParser(self)

    def getTimelineIterator(self) -> "isys::CTraceTimelineIterator":
        return _connect.CTraceData_getTimelineIterator(self)
    __swig_destroy__ = _connect.delete_CTraceData
    __del__ = lambda self: None
CTraceData_swigregister = _connect.CTraceData_swigregister
CTraceData_swigregister(CTraceData)

def CTraceData_createInstance(*args) -> "isys::CTraceDataSPtr":
    return _connect.CTraceData_createInstance(*args)
CTraceData_createInstance = _connect.CTraceData_createInstance

class CTraceConfigWizard(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTraceConfigWizard, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTraceConfigWizard, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    ERead = _connect.CTraceConfigWizard_ERead
    EWrite = _connect.CTraceConfigWizard_EWrite
    EReadWrite = _connect.CTraceConfigWizard_EReadWrite
    EWidthAny = _connect.CTraceConfigWizard_EWidthAny
    EWidth1 = _connect.CTraceConfigWizard_EWidth1
    EWidth2 = _connect.CTraceConfigWizard_EWidth2
    EWidth4 = _connect.CTraceConfigWizard_EWidth4
    ERisingEdge = _connect.CTraceConfigWizard_ERisingEdge
    EFallingEdge = _connect.CTraceConfigWizard_EFallingEdge
    EAUXState = _connect.CTraceConfigWizard_EAUXState
    ERecordEverything = _connect.CTraceConfigWizard_ERecordEverything
    ERecordProgramFlow = _connect.CTraceConfigWizard_ERecordProgramFlow
    ERecordDataAccess = _connect.CTraceConfigWizard_ERecordDataAccess
    ERecordInstrumentationMsgs = _connect.CTraceConfigWizard_ERecordInstrumentationMsgs
    ESamplesBefore = _connect.CTraceConfigWizard_ESamplesBefore
    ESamplesAfter = _connect.CTraceConfigWizard_ESamplesAfter
    ESamplesBeforeAndAfter = _connect.CTraceConfigWizard_ESamplesBeforeAndAfter
    EAllTheTime = _connect.CTraceConfigWizard_EAllTheTime
    EBetweenTwoEvents = _connect.CTraceConfigWizard_EBetweenTwoEvents
    if _newclass:
        createImmediateTrigger = staticmethod(_connect.CTraceConfigWizard_createImmediateTrigger)
    else:
        createImmediateTrigger = _connect.CTraceConfigWizard_createImmediateTrigger
    if _newclass:
        createDataAccessTrigger = staticmethod(_connect.CTraceConfigWizard_createDataAccessTrigger)
    else:
        createDataAccessTrigger = _connect.CTraceConfigWizard_createDataAccessTrigger
    if _newclass:
        createCodeExecTrigger = staticmethod(_connect.CTraceConfigWizard_createCodeExecTrigger)
    else:
        createCodeExecTrigger = _connect.CTraceConfigWizard_createCodeExecTrigger
    if _newclass:
        createAUXStateTrigger = staticmethod(_connect.CTraceConfigWizard_createAUXStateTrigger)
    else:
        createAUXStateTrigger = _connect.CTraceConfigWizard_createAUXStateTrigger
    if _newclass:
        createAUXEdgeTrigger = staticmethod(_connect.CTraceConfigWizard_createAUXEdgeTrigger)
    else:
        createAUXEdgeTrigger = _connect.CTraceConfigWizard_createAUXEdgeTrigger

    def setRecordingContent(self, *args) -> "void":
        return _connect.CTraceConfigWizard_setRecordingContent(self, *args)

    def setRecordingAttibutes(self, samplesOffsetType: 'isys::CTraceConfigWizard::ESamplesOffset', recordingDuration: 'isys::CTraceConfigWizard::ERecordingDuration') -> "void":
        return _connect.CTraceConfigWizard_setRecordingAttibutes(self, samplesOffsetType, recordingDuration)

    def configureOptions(self, ide: 'CIDEController', docFileName: 'std::string const &', triggerIdx: 'int') -> "void":
        return _connect.CTraceConfigWizard_configureOptions(self, ide, docFileName, triggerIdx)
    __swig_destroy__ = _connect.delete_CTraceConfigWizard
    __del__ = lambda self: None
CTraceConfigWizard_swigregister = _connect.CTraceConfigWizard_swigregister
CTraceConfigWizard_swigregister(CTraceConfigWizard)

def CTraceConfigWizard_createImmediateTrigger() -> "isys::CTraceConfigWizardSPtr":
    return _connect.CTraceConfigWizard_createImmediateTrigger()
CTraceConfigWizard_createImmediateTrigger = _connect.CTraceConfigWizard_createImmediateTrigger

def CTraceConfigWizard_createDataAccessTrigger(*args) -> "isys::CTraceConfigWizardSPtr":
    return _connect.CTraceConfigWizard_createDataAccessTrigger(*args)
CTraceConfigWizard_createDataAccessTrigger = _connect.CTraceConfigWizard_createDataAccessTrigger

def CTraceConfigWizard_createCodeExecTrigger(funcName: 'std::string const &') -> "isys::CTraceConfigWizardSPtr":
    return _connect.CTraceConfigWizard_createCodeExecTrigger(funcName)
CTraceConfigWizard_createCodeExecTrigger = _connect.CTraceConfigWizard_createCodeExecTrigger

def CTraceConfigWizard_createAUXStateTrigger(signalsMask: 'DWORD', signalsValue: 'DWORD') -> "isys::CTraceConfigWizardSPtr":
    return _connect.CTraceConfigWizard_createAUXStateTrigger(signalsMask, signalsValue)
CTraceConfigWizard_createAUXStateTrigger = _connect.CTraceConfigWizard_createAUXStateTrigger

def CTraceConfigWizard_createAUXEdgeTrigger(edgeType: 'isys::CTraceConfigWizard::EEdgeType', signalNumber: 'int') -> "isys::CTraceConfigWizardSPtr":
    return _connect.CTraceConfigWizard_createAUXEdgeTrigger(edgeType, signalNumber)
CTraceConfigWizard_createAUXEdgeTrigger = _connect.CTraceConfigWizard_createAUXEdgeTrigger

class CProfilerStatus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerStatus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerStatus, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNoOfSamples(self) -> "int":
        return _connect.CProfilerStatus_getNoOfSamples(self)

    def isMustInit(self) -> "bool":
        return _connect.CProfilerStatus_isMustInit(self)

    def isIdle(self) -> "bool":
        return _connect.CProfilerStatus_isIdle(self)

    def isWaiting(self) -> "bool":
        return _connect.CProfilerStatus_isWaiting(self)

    def isActive(self) -> "bool":
        return _connect.CProfilerStatus_isActive(self)

    def isErrorInBuffer(self) -> "bool":
        return _connect.CProfilerStatus_isErrorInBuffer(self)

    def isBufferOverrun(self) -> "bool":
        return _connect.CProfilerStatus_isBufferOverrun(self)

    def isRecordingError(self) -> "bool":
        return _connect.CProfilerStatus_isRecordingError(self)

    def isError(self) -> "bool":
        return _connect.CProfilerStatus_isError(self)

    def isLoading(self) -> "bool":
        return _connect.CProfilerStatus_isLoading(self)

    def getAnalysisError(self) -> "int":
        return _connect.CProfilerStatus_getAnalysisError(self)

    def toString(self) -> "std::string":
        return _connect.CProfilerStatus_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerStatus
    __del__ = lambda self: None
CProfilerStatus_swigregister = _connect.CProfilerStatus_swigregister
CProfilerStatus_swigregister(CProfilerStatus)

class CProfilerStatistic(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerStatistic, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerStatistic, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CProfilerStatistic()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getHandle(self) -> "DWORD":
        return _connect.CProfilerStatistic_getHandle(self)

    def getValue(self) -> "DWORD":
        return _connect.CProfilerStatistic_getValue(self)

    def getMinTime(self) -> "int64_t":
        return _connect.CProfilerStatistic_getMinTime(self)

    def getMaxTime(self) -> "int64_t":
        return _connect.CProfilerStatistic_getMaxTime(self)

    def getTotalTime(self) -> "int64_t":
        return _connect.CProfilerStatistic_getTotalTime(self)

    def getNumHits(self) -> "DWORD":
        return _connect.CProfilerStatistic_getNumHits(self)

    def toString(self) -> "std::string":
        return _connect.CProfilerStatistic_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerStatistic
    __del__ = lambda self: None
CProfilerStatistic_swigregister = _connect.CProfilerStatistic_swigregister
CProfilerStatistic_swigregister(CProfilerStatistic)

class CProfilerHistory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerHistory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerHistory, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CProfilerHistory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getSProfilerHistory(self) -> "SProfilerHistory &":
        return _connect.CProfilerHistory_getSProfilerHistory(self)

    def getHandle(self) -> "DWORD":
        return _connect.CProfilerHistory_getHandle(self)

    def getHitTime(self) -> "int64_t":
        return _connect.CProfilerHistory_getHitTime(self)

    def getValue(self) -> "DWORD":
        return _connect.CProfilerHistory_getValue(self)

    def isActive(self) -> "bool":
        return _connect.CProfilerHistory_isActive(self)

    def isInactive(self) -> "bool":
        return _connect.CProfilerHistory_isInactive(self)

    def toString(self) -> "std::string":
        return _connect.CProfilerHistory_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerHistory
    __del__ = lambda self: None
CProfilerHistory_swigregister = _connect.CProfilerHistory_swigregister
CProfilerHistory_swigregister(CProfilerHistory)

class CProfilerCapabilities(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerCapabilities, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerCapabilities, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CProfilerCapabilities()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getNumExecAreas(self) -> "DWORD":
        return _connect.CProfilerCapabilities_getNumExecAreas(self)

    def getNumDataAreas(self) -> "DWORD":
        return _connect.CProfilerCapabilities_getNumDataAreas(self)

    def getSingleDataWidth(self) -> "int":
        return _connect.CProfilerCapabilities_getSingleDataWidth(self)

    def isAvailable(self) -> "bool":
        return _connect.CProfilerCapabilities_isAvailable(self)

    def canUseStartingPoint(self) -> "bool":
        return _connect.CProfilerCapabilities_canUseStartingPoint(self)

    def canProfileExec(self) -> "bool":
        return _connect.CProfilerCapabilities_canProfileExec(self)

    def canProfileFuncLines(self) -> "bool":
        return _connect.CProfilerCapabilities_canProfileFuncLines(self)

    def canProfileData(self) -> "bool":
        return _connect.CProfilerCapabilities_canProfileData(self)

    def isSingleData(self) -> "bool":
        return _connect.CProfilerCapabilities_isSingleData(self)

    def isSingleDataAddress(self) -> "bool":
        return _connect.CProfilerCapabilities_isSingleDataAddress(self)

    def isSingleDataSize(self) -> "bool":
        return _connect.CProfilerCapabilities_isSingleDataSize(self)

    def toString(self) -> "std::string":
        return _connect.CProfilerCapabilities_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerCapabilities
    __del__ = lambda self: None
CProfilerCapabilities_swigregister = _connect.CProfilerCapabilities_swigregister
CProfilerCapabilities_swigregister(CProfilerCapabilities)

class CAreaProperties(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CAreaProperties, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CAreaProperties, name)
    __repr__ = _swig_repr

    def __init__(self, areaName: 'std::string const &', handle: 'DWORD', address: 'ADDRESS'):
        this = _connect.new_CAreaProperties(areaName, handle, address)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getName(self) -> "std::string":
        return _connect.CAreaProperties_getName(self)

    def getHandle(self) -> "DWORD":
        return _connect.CAreaProperties_getHandle(self)

    def getAddress(self) -> "ADDRESS":
        return _connect.CAreaProperties_getAddress(self)

    def toString(self) -> "std::string":
        return _connect.CAreaProperties_toString(self)
    __swig_destroy__ = _connect.delete_CAreaProperties
    __del__ = lambda self: None
CAreaProperties_swigregister = _connect.CAreaProperties_swigregister
CAreaProperties_swigregister(CAreaProperties)

class CProfilerController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CProfilerController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CProfilerController
    __del__ = lambda self: None

    def getIConnectProfiler(self) -> "IConnectProfiler2 *":
        return _connect.CProfilerController_getIConnectProfiler(self)

    def getCapabilities(self) -> "isys::CProfilerCapabilities":
        return _connect.CProfilerController_getCapabilities(self)

    def startConfiguration(self, *args) -> "void":
        return _connect.CProfilerController_startConfiguration(self, *args)

    def addFunction(self, functionName: 'std::string const &', isIncludeFunctionLines: 'bool'=False) -> "void":
        return _connect.CProfilerController_addFunction(self, functionName, isIncludeFunctionLines)

    def addVariable(self, variableName: 'std::string const &', isTaskId: 'bool'=False, isSingleData: 'bool'=False) -> "void":
        return _connect.CProfilerController_addVariable(self, variableName, isTaskId, isSingleData)

    def addRegion(self, name: 'std::string const &', isTaskId: 'bool', isSingleData: 'bool', byMemArea: 'BYTE', aAddress: 'DWORD', aSize: 'DWORD') -> "void":
        return _connect.CProfilerController_addRegion(self, name, isTaskId, isSingleData, byMemArea, aAddress, aSize)

    def addRoutine(self, name: 'std::string const &', byMemArea: 'BYTE', aAddress: 'DWORD', aSize: 'DWORD', exits: 'AddressVector') -> "void":
        return _connect.CProfilerController_addRoutine(self, name, byMemArea, aAddress, aSize, exits)

    def getNumAreas(self) -> "int":
        return _connect.CProfilerController_getNumAreas(self)

    def getAreaProperties(self, *args) -> "isys::CAreaProperties":
        return _connect.CProfilerController_getAreaProperties(self, *args)

    def start(self) -> "void":
        return _connect.CProfilerController_start(self)

    def stop(self) -> "bool":
        return _connect.CProfilerController_stop(self)

    def getStatus(self, *args) -> "isys::CProfilerStatus":
        return _connect.CProfilerController_getStatus(self, *args)

    def getStatisticsAll(self, expectedSize: 'size_t', statisticsList: 'ProfilerStatisticVector') -> "void":
        return _connect.CProfilerController_getStatisticsAll(self, expectedSize, statisticsList)

    def getStatisticsForHandle(self, handle: 'DWORD', expectedSize: 'size_t', statisticsList: 'ProfilerStatisticVector') -> "void":
        return _connect.CProfilerController_getStatisticsForHandle(self, handle, expectedSize, statisticsList)

    def getStatisticsForTask(self, *args) -> "void":
        return _connect.CProfilerController_getStatisticsForTask(self, *args)

    def getStatisticsForValue(self, handle: 'DWORD', value: 'DWORD', expectedSize: 'size_t', statisticsList: 'ProfilerStatisticVector') -> "void":
        return _connect.CProfilerController_getStatisticsForValue(self, handle, value, expectedSize, statisticsList)

    def getHistoryAll(self, startIDx: 'DWORD', len: 'DWORD', historyList: 'ProfilerHistoryVector') -> "void":
        return _connect.CProfilerController_getHistoryAll(self, startIDx, len, historyList)

    def getHistoryForHandle(self, handle: 'DWORD', startIDx: 'DWORD', len: 'DWORD', historyList: 'ProfilerHistoryVector') -> "void":
        return _connect.CProfilerController_getHistoryForHandle(self, handle, startIDx, len, historyList)

    def getHistoryForTask(self, *args) -> "void":
        return _connect.CProfilerController_getHistoryForTask(self, *args)

    def getHistoryForValue(self, handle: 'DWORD', value: 'DWORD', startIDx: 'DWORD', len: 'DWORD', historyList: 'ProfilerHistoryVector') -> "void":
        return _connect.CProfilerController_getHistoryForValue(self, handle, value, startIDx, len, historyList)

    def waitUntilLoaded(self, timeout: 'int'=0, pollingInterval: 'DWORD'=100) -> "bool":
        return _connect.CProfilerController_waitUntilLoaded(self, timeout, pollingInterval)
CProfilerController_swigregister = _connect.CProfilerController_swigregister
CProfilerController_swigregister(CProfilerController)

class ITestCaseController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ITestCaseController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ITestCaseController, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_ITestCaseController
    __del__ = lambda self: None

    def init(self) -> "bool":
        return _connect.ITestCaseController_init(self)

    def clean(self) -> "void":
        return _connect.ITestCaseController_clean(self)

    def destroy(self) -> "void":
        return _connect.ITestCaseController_destroy(self)

    def getTestCaseHandle(self) -> "DWORD":
        return _connect.ITestCaseController_getTestCaseHandle(self)

    def setTestTimeout(self, timeout: 'int') -> "void":
        return _connect.ITestCaseController_setTestTimeout(self, timeout)

    def createStub(self, *args) -> "isys::CTestStubControllerSPtr":
        return _connect.ITestCaseController_createStub(self, *args)

    def createUserStub(self, functionName: 'std::string const &', stubFunctionName: 'std::string const &') -> "void":
        return _connect.ITestCaseController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self) -> "isys::CTestStubControllerSPtr":
        return _connect.ITestCaseController_getActiveStub(self)

    def createPersistentVariable(self, variableName: 'std::string const &', typeName: 'std::string const &') -> "void":
        return _connect.ITestCaseController_createPersistentVariable(self, variableName, typeName)

    def deletePersistentVariable(self, variableName: 'std::string const &') -> "void":
        return _connect.ITestCaseController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self) -> "void":
        return _connect.ITestCaseController_commitDeletedVars(self)

    def initPersistentVars(self) -> "void":
        return _connect.ITestCaseController_initPersistentVars(self)

    def cleanPersistentVars(self) -> "void":
        return _connect.ITestCaseController_cleanPersistentVars(self)

    def setTestBatchNS(self, isBatchBegin: 'bool') -> "void":
        return _connect.ITestCaseController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self) -> "void":
        return _connect.ITestCaseController_setDebugModeOn(self)

    def evaluate(self, expression: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "std::string":
        return _connect.ITestCaseController_evaluate(self, expression, dwEvalFlags)

    def modify(self, lval: 'std::string const &', rval: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "std::string":
        return _connect.ITestCaseController_modify(self, lval, rval, dwEvalFlags)

    def modifyAsString(self, lval: 'std::string const &', rval: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "void":
        return _connect.ITestCaseController_modifyAsString(self, lval, rval, dwEvalFlags)

    def getStatus(self, *args) -> "IConnectTest::EState":
        return _connect.ITestCaseController_getStatus(self, *args)

    def run(self) -> "void":
        return _connect.ITestCaseController_run(self)

    def waitUntilStopped(self, timeout: 'int'=0, pollingInterval: 'DWORD'=100) -> "bool":
        return _connect.ITestCaseController_waitUntilStopped(self, timeout, pollingInterval)
ITestCaseController_swigregister = _connect.ITestCaseController_swigregister
ITestCaseController_swigregister(ITestCaseController)

class CTestCaseController(ITestCaseController):
    __swig_setmethods__ = {}
    for _s in [ITestCaseController]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestCaseController, name, value)
    __swig_getmethods__ = {}
    for _s in [ITestCaseController]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestCaseController, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CTestCaseController(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestCaseController
    __del__ = lambda self: None

    def destroy(self) -> "void":
        return _connect.CTestCaseController_destroy(self)

    def getTestCaseHandle(self) -> "DWORD":
        return _connect.CTestCaseController_getTestCaseHandle(self)

    def createParameter(self, *args) -> "void":
        return _connect.CTestCaseController_createParameter(self, *args)

    def createVariable(self, *args) -> "void":
        return _connect.CTestCaseController_createVariable(self, *args)

    def deletePersistentVariable(self, variableName: 'std::string const &') -> "void":
        return _connect.CTestCaseController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self) -> "void":
        return _connect.CTestCaseController_commitDeletedVars(self)

    def setTestTimeout(self, timeout: 'int') -> "void":
        return _connect.CTestCaseController_setTestTimeout(self, timeout)

    def createStub(self, *args) -> "isys::CTestStubControllerSPtr":
        return _connect.CTestCaseController_createStub(self, *args)

    def createUserStub(self, functionName: 'std::string const &', stubFunctionName: 'std::string const &') -> "void":
        return _connect.CTestCaseController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self) -> "isys::CTestStubControllerSPtr":
        return _connect.CTestCaseController_getActiveStub(self)

    def createPersistentVariable(self, variableName: 'std::string const &', typeName: 'std::string const &') -> "void":
        return _connect.CTestCaseController_createPersistentVariable(self, variableName, typeName)

    def initPersistentVars(self) -> "void":
        return _connect.CTestCaseController_initPersistentVars(self)

    def cleanPersistentVars(self) -> "void":
        return _connect.CTestCaseController_cleanPersistentVars(self)

    def evaluate(self, expression: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "std::string":
        return _connect.CTestCaseController_evaluate(self, expression, dwEvalFlags)

    def modify(self, expression: 'std::string const &', value: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "std::string":
        return _connect.CTestCaseController_modify(self, expression, value, dwEvalFlags)

    def modifyAsString(self, lval: 'std::string const &', rval: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "void":
        return _connect.CTestCaseController_modifyAsString(self, lval, rval, dwEvalFlags)

    def getStatus(self, *args) -> "IConnectTest::EState":
        return _connect.CTestCaseController_getStatus(self, *args)

    def init(self) -> "bool":
        return _connect.CTestCaseController_init(self)

    def clean(self) -> "void":
        return _connect.CTestCaseController_clean(self)

    def setTestBatchNS(self, isBatchBegin: 'bool') -> "void":
        return _connect.CTestCaseController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self) -> "void":
        return _connect.CTestCaseController_setDebugModeOn(self)
    if _newclass:
        setTestBatch = staticmethod(_connect.CTestCaseController_setTestBatch)
    else:
        setTestBatch = _connect.CTestCaseController_setTestBatch

    def run(self) -> "void":
        return _connect.CTestCaseController_run(self)

    def abort(self) -> "void":
        return _connect.CTestCaseController_abort(self)

    def pause(self) -> "void":
        return _connect.CTestCaseController_pause(self)
    if _newclass:
        clearAllTests = staticmethod(_connect.CTestCaseController_clearAllTests)
    else:
        clearAllTests = _connect.CTestCaseController_clearAllTests

    def waitUntilStopped(self, timeout: 'int'=0, pollingInterval: 'DWORD'=100) -> "bool":
        return _connect.CTestCaseController_waitUntilStopped(self, timeout, pollingInterval)
    if _newclass:
        testState2str = staticmethod(_connect.CTestCaseController_testState2str)
    else:
        testState2str = _connect.CTestCaseController_testState2str

    def stubState2str(self, state: 'IConnectTest::EStubState') -> "std::string":
        return _connect.CTestCaseController_stubState2str(self, state)
    if _newclass:
        s2i64 = staticmethod(_connect.CTestCaseController_s2i64)
    else:
        s2i64 = _connect.CTestCaseController_s2i64
    if _newclass:
        verifyRetVal = staticmethod(_connect.CTestCaseController_verifyRetVal)
    else:
        verifyRetVal = _connect.CTestCaseController_verifyRetVal
CTestCaseController_swigregister = _connect.CTestCaseController_swigregister
CTestCaseController_swigregister(CTestCaseController)
CTestCaseController.POSITION_PARAM_NAME_PREFIX = _connect.cvar.CTestCaseController_POSITION_PARAM_NAME_PREFIX

def CTestCaseController_setTestBatch(connectionMgr: 'isys::ConnectionMgrSPtr', isBatchBegin: 'bool') -> "void":
    return _connect.CTestCaseController_setTestBatch(connectionMgr, isBatchBegin)
CTestCaseController_setTestBatch = _connect.CTestCaseController_setTestBatch

def CTestCaseController_clearAllTests(connection: 'std::shared_ptr< isys::ConnectionMgr >') -> "void":
    return _connect.CTestCaseController_clearAllTests(connection)
CTestCaseController_clearAllTests = _connect.CTestCaseController_clearAllTests

def CTestCaseController_testState2str(state: 'IConnectTest::EState') -> "std::string":
    return _connect.CTestCaseController_testState2str(state)
CTestCaseController_testState2str = _connect.CTestCaseController_testState2str

def CTestCaseController_s2i64(numStr: 'std::string const &') -> "int64_t":
    return _connect.CTestCaseController_s2i64(numStr)
CTestCaseController_s2i64 = _connect.CTestCaseController_s2i64

def CTestCaseController_verifyRetVal(icTest: 'IConnectTest', retVal: 'unsigned long', description: 'std::string const &', handle: 'DWORD', objectId: 'std::string const &') -> "void":
    return _connect.CTestCaseController_verifyRetVal(icTest, retVal, description, handle, objectId)
CTestCaseController_verifyRetVal = _connect.CTestCaseController_verifyRetVal

class CTestStubController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestStubController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTestStubController, name)
    __repr__ = _swig_repr
    E_SCRIPT_STUB = _connect.CTestStubController_E_SCRIPT_STUB
    E_RT_USER_STUB = _connect.CTestStubController_E_RT_USER_STUB
    E_RT_EMPTY_STUB = _connect.CTestStubController_E_RT_EMPTY_STUB

    def __init__(self, *args):
        this = _connect.new_CTestStubController(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestStubController
    __del__ = lambda self: None

    def create(self, flags: 'IConnectTest::EStubFlags', stubbedFunctionName: 'std::string const &') -> "void":
        return _connect.CTestStubController_create(self, flags, stubbedFunctionName)

    def createParameter(self, parameterIndex: 'DWORD', parameterName: 'std::string const &') -> "void":
        return _connect.CTestStubController_createParameter(self, parameterIndex, parameterName)

    def createReturnValue(self, retValName: 'std::string const &') -> "void":
        return _connect.CTestStubController_createReturnValue(self, retValName)

    def getStubName(self) -> "std::string":
        return _connect.CTestStubController_getStubName(self)

    def getRetValName(self) -> "std::string":
        return _connect.CTestStubController_getRetValName(self)

    def getHandle(self) -> "DWORD":
        return _connect.CTestStubController_getHandle(self)
CTestStubController_swigregister = _connect.CTestStubController_swigregister
CTestStubController_swigregister(CTestStubController)

class CSystemTestController(ITestCaseController):
    __swig_setmethods__ = {}
    for _s in [ITestCaseController]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSystemTestController, name, value)
    __swig_getmethods__ = {}
    for _s in [ITestCaseController]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CSystemTestController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CSystemTestController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CSystemTestController
    __del__ = lambda self: None

    def init(self) -> "bool":
        return _connect.CSystemTestController_init(self)

    def clean(self) -> "void":
        return _connect.CSystemTestController_clean(self)

    def destroy(self) -> "void":
        return _connect.CSystemTestController_destroy(self)

    def getTestCaseHandle(self) -> "DWORD":
        return _connect.CSystemTestController_getTestCaseHandle(self)

    def createPersistentVariable(self, variableName: 'std::string const &', typeName: 'std::string const &') -> "void":
        return _connect.CSystemTestController_createPersistentVariable(self, variableName, typeName)

    def deletePersistentVariable(self, variableName: 'std::string const &') -> "void":
        return _connect.CSystemTestController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self) -> "void":
        return _connect.CSystemTestController_commitDeletedVars(self)

    def initPersistentVars(self) -> "void":
        return _connect.CSystemTestController_initPersistentVars(self)

    def cleanPersistentVars(self) -> "void":
        return _connect.CSystemTestController_cleanPersistentVars(self)

    def setTestTimeout(self, timeout: 'int') -> "void":
        return _connect.CSystemTestController_setTestTimeout(self, timeout)

    def createStub(self, *args) -> "isys::CTestStubControllerSPtr":
        return _connect.CSystemTestController_createStub(self, *args)

    def createUserStub(self, functionName: 'std::string const &', stubFunctionName: 'std::string const &') -> "void":
        return _connect.CSystemTestController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self) -> "isys::CTestStubControllerSPtr":
        return _connect.CSystemTestController_getActiveStub(self)

    def setTestBatchNS(self, isBatchBegin: 'bool') -> "void":
        return _connect.CSystemTestController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self) -> "void":
        return _connect.CSystemTestController_setDebugModeOn(self)

    def evaluate(self, expression: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "std::string":
        return _connect.CSystemTestController_evaluate(self, expression, dwEvalFlags)

    def modify(self, expression: 'std::string const &', value: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "std::string":
        return _connect.CSystemTestController_modify(self, expression, value, dwEvalFlags)

    def modifyAsString(self, expression: 'std::string const &', value: 'std::string const &', dwEvalFlags: 'DWORD'=0) -> "void":
        return _connect.CSystemTestController_modifyAsString(self, expression, value, dwEvalFlags)

    def getStatus(self, *args) -> "IConnectTest::EState":
        return _connect.CSystemTestController_getStatus(self, *args)

    def run(self) -> "void":
        return _connect.CSystemTestController_run(self)

    def stop(self) -> "void":
        return _connect.CSystemTestController_stop(self)

    def waitUntilStopped(self, timeout: 'int'=0, pollingInterval: 'DWORD'=100) -> "bool":
        return _connect.CSystemTestController_waitUntilStopped(self, timeout, pollingInterval)
CSystemTestController_swigregister = _connect.CSystemTestController_swigregister
CSystemTestController_swigregister(CSystemTestController)

class CDebugFacade(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDebugFacade, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDebugFacade, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CDebugFacade(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CDebugFacade
    __del__ = lambda self: None

    def getAddressController(self) -> "isys::CAddressController &":
        return _connect.CDebugFacade_getAddressController(self)

    def getBreakpointController(self) -> "isys::CBreakpointController &":
        return _connect.CDebugFacade_getBreakpointController(self)

    def getDataController(self) -> "isys::CDataController &":
        return _connect.CDebugFacade_getDataController(self)

    def getExecutionController(self) -> "isys::CExecutionController &":
        return _connect.CDebugFacade_getExecutionController(self)

    def getLoaderController(self) -> "isys::CLoaderController &":
        return _connect.CDebugFacade_getLoaderController(self)

    def getCodeArea(self, bPhysical: 'bool') -> "int":
        return _connect.CDebugFacade_getCodeArea(self, bPhysical)

    def getFunctionAddress(self, functionName: 'std::string const &') -> "isys::CMemAddress":
        return _connect.CDebugFacade_getFunctionAddress(self, functionName)

    def getVariableAddress(self, variableName: 'std::string const &') -> "isys::CMemAddress":
        return _connect.CDebugFacade_getVariableAddress(self, variableName)

    def getExpressionAddress(self, expression: 'std::string const &') -> "isys::CMemAddress":
        return _connect.CDebugFacade_getExpressionAddress(self, expression)

    def getLabelAddress(self, labelName: 'std::string const &') -> "isys::CMemAddress":
        return _connect.CDebugFacade_getLabelAddress(self, labelName)

    def getSymbolInfo(self, flags: 'DWORD', expression: 'std::string const &') -> "isys::CSymbolInfo":
        return _connect.CDebugFacade_getSymbolInfo(self, flags, expression)

    def getSymbolAtAddress(self, *args) -> "std::string":
        return _connect.CDebugFacade_getSymbolAtAddress(self, *args)

    def getAddressOfSourceLine(self, fileName: 'std::string const &', line: 'int', isReportSize: 'bool'=False) -> "isys::AddressVector":
        return _connect.CDebugFacade_getAddressOfSourceLine(self, fileName, line, isReportSize)

    def getSourceLineAtAddress(self, *args) -> "isys::CLineLocation":
        return _connect.CDebugFacade_getSourceLineAtAddress(self, *args)

    def setBP(self, *args) -> "int":
        return _connect.CDebugFacade_setBP(self, *args)

    def setHWBP(self, *args) -> "int":
        return _connect.CDebugFacade_setHWBP(self, *args)

    def deleteBP(self, *args) -> "int":
        return _connect.CDebugFacade_deleteBP(self, *args)

    def deleteHWBP(self, *args) -> "int":
        return _connect.CDebugFacade_deleteHWBP(self, *args)

    def deleteAll(self) -> "int":
        return _connect.CDebugFacade_deleteAll(self)

    def deleteAllHWBP(self) -> "int":
        return _connect.CDebugFacade_deleteAllHWBP(self)

    def setEnabled(self, *args) -> "int":
        return _connect.CDebugFacade_setEnabled(self, *args)

    def setHWEnabled(self, *args) -> "int":
        return _connect.CDebugFacade_setHWEnabled(self, *args)

    def setHWEnabledAll(self, isEnabled: 'bool') -> "int":
        return _connect.CDebugFacade_setHWEnabledAll(self, isEnabled)

    def setEnabledAll(self, isEnabled: 'bool') -> "int":
        return _connect.CDebugFacade_setEnabledAll(self, isEnabled)

    def reapplyAll(self) -> "int":
        return _connect.CDebugFacade_reapplyAll(self)

    def getCPUInfo(self) -> "CCPUInfo":
        return _connect.CDebugFacade_getCPUInfo(self)

    def getMemoryAreaBytesPerMAU(self, memArea: 'int') -> "int":
        return _connect.CDebugFacade_getMemoryAreaBytesPerMAU(self, memArea)

    def readMemory(self, accessFlags: 'IConnectDebug::EAccessFlags', memArea: 'BYTE', aAddress: 'ADDRESS_64', aNumMAUs: 'ADDRESS_64', bytesPerMAU: 'BYTE') -> "std::vector< BYTE,std::allocator< BYTE > >":
        return _connect.CDebugFacade_readMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU)

    def writeMemory(self, accessFlags: 'IConnectDebug::EAccessFlags', memArea: 'BYTE', aAddress: 'ADDRESS_64', aNumMAUs: 'ADDRESS_64', bytesPerMAU: 'BYTE', buff: 'VectorBYTE') -> "std::vector< BYTE,std::allocator< BYTE > >":
        return _connect.CDebugFacade_writeMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def readRegister(self, accessFlags: 'IConnectDebug::EAccessFlags', registerName: 'std::string const &') -> "isys::CValueType":
        return _connect.CDebugFacade_readRegister(self, accessFlags, registerName)

    def writeRegister(self, accessFlags: 'IConnectDebug::EAccessFlags', registerName: 'std::string const &', registerInfo: 'CValueType') -> "void":
        return _connect.CDebugFacade_writeRegister(self, accessFlags, registerName, registerInfo)

    def readValue(self, accessFlags: 'IConnectDebug::EAccessFlags', memArea: 'BYTE', aAddress: 'ADDRESS_64', type: 'SType') -> "isys::CValueType":
        return _connect.CDebugFacade_readValue(self, accessFlags, memArea, aAddress, type)

    def writeValue(self, *args) -> "void":
        return _connect.CDebugFacade_writeValue(self, *args)

    def evaluate(self, *args) -> "isys::CValueType":
        return _connect.CDebugFacade_evaluate(self, *args)

    def modify(self, *args) -> "std::string":
        return _connect.CDebugFacade_modify(self, *args)

    def run(self, *args) -> "int":
        return _connect.CDebugFacade_run(self, *args)

    def runUntilReturn(self, *args) -> "int":
        return _connect.CDebugFacade_runUntilReturn(self, *args)

    def runUntilAddress(self, *args) -> "int":
        return _connect.CDebugFacade_runUntilAddress(self, *args)

    def runUntilFunction(self, *args) -> "int":
        return _connect.CDebugFacade_runUntilFunction(self, *args)

    def setSlowRun(self, isSlowRun: 'bool') -> "int":
        return _connect.CDebugFacade_setSlowRun(self, isSlowRun)

    def gotoAddress(self, memArea: 'BYTE', address: 'ADDRESS_64') -> "void":
        return _connect.CDebugFacade_gotoAddress(self, memArea, address)

    def gotoFunction(self, functionName: 'std::string const &') -> "void":
        return _connect.CDebugFacade_gotoFunction(self, functionName)

    def reset(self) -> "void":
        return _connect.CDebugFacade_reset(self)

    def stop(self) -> "void":
        return _connect.CDebugFacade_stop(self)

    def stepHigh(self, *args) -> "void":
        return _connect.CDebugFacade_stepHigh(self, *args)

    def stepOverHigh(self, *args) -> "void":
        return _connect.CDebugFacade_stepOverHigh(self, *args)

    def stepInst(self, *args) -> "void":
        return _connect.CDebugFacade_stepInst(self, *args)

    def stepOverInst(self, *args) -> "void":
        return _connect.CDebugFacade_stepOverInst(self, *args)

    def call(self, functionName: 'std::string const &') -> "std::string":
        return _connect.CDebugFacade_call(self, functionName)

    def getCPUStatus(self, wantStopReason: 'bool'=True) -> "isys::CPUStatus":
        return _connect.CDebugFacade_getCPUStatus(self, wantStopReason)

    def setPollingEnabled(self, isEnabled: 'bool') -> "void":
        return _connect.CDebugFacade_setPollingEnabled(self, isEnabled)

    def waitUntilStopped(self, timeout: 'int'=0, pollingInterval: 'DWORD'=100) -> "bool":
        return _connect.CDebugFacade_waitUntilStopped(self, timeout, pollingInterval)

    def waitWhileRunning(self, timeout: 'int', pollingInterval: 'DWORD'=100) -> "bool":
        return _connect.CDebugFacade_waitWhileRunning(self, timeout, pollingInterval)

    def download(self) -> "int":
        return _connect.CDebugFacade_download(self)

    def runUntilExpression(self, *args) -> "int":
        return _connect.CDebugFacade_runUntilExpression(self, *args)

    def adjustAddressExpression(self, expression: 'std::string const &') -> "std::string":
        return _connect.CDebugFacade_adjustAddressExpression(self, expression)
CDebugFacade_swigregister = _connect.CDebugFacade_swigregister
CDebugFacade_swigregister(CDebugFacade)

class CInstruction(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CInstruction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CInstruction, name)
    __repr__ = _swig_repr

    def __init__(self, sInstr: 'IInstruction'):
        this = _connect.new_CInstruction(sInstr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getAddress(self) -> "ADDRESS_64":
        return _connect.CInstruction_getAddress(self)

    def getJumpTarget(self) -> "ADDRESS_64":
        return _connect.CInstruction_getJumpTarget(self)

    def getFlags(self) -> "DWORD":
        return _connect.CInstruction_getFlags(self)

    def getSize(self) -> "int":
        return _connect.CInstruction_getSize(self)

    def getMemAccessSize(self) -> "int":
        return _connect.CInstruction_getMemAccessSize(self)

    def getOpCode(self) -> "std::string":
        return _connect.CInstruction_getOpCode(self)

    def isFlowSequential(self) -> "bool":
        return _connect.CInstruction_isFlowSequential(self)

    def isFlowDirectJump(self) -> "bool":
        return _connect.CInstruction_isFlowDirectJump(self)

    def isFlowIndirectJump(self) -> "bool":
        return _connect.CInstruction_isFlowIndirectJump(self)

    def isConditional(self) -> "bool":
        return _connect.CInstruction_isConditional(self)

    def isCall(self) -> "bool":
        return _connect.CInstruction_isCall(self)

    def isRelative(self) -> "bool":
        return _connect.CInstruction_isRelative(self)

    def isWriteAccess(self) -> "bool":
        return _connect.CInstruction_isWriteAccess(self)

    def isReadAccess(self) -> "bool":
        return _connect.CInstruction_isReadAccess(self)

    def incExecCounter(self) -> "void":
        return _connect.CInstruction_incExecCounter(self)

    def setExecCounter(self, n: 'int64_t') -> "void":
        return _connect.CInstruction_setExecCounter(self, n)

    def getExecCounter(self) -> "int64_t":
        return _connect.CInstruction_getExecCounter(self)

    def toString(self) -> "std::string":
        return _connect.CInstruction_toString(self)
    __swig_destroy__ = _connect.delete_CInstruction
    __del__ = lambda self: None
CInstruction_swigregister = _connect.CInstruction_swigregister
CInstruction_swigregister(CInstruction)

class CPartitionCodeInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPartitionCodeInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CPartitionCodeInfo, name)
    __repr__ = _swig_repr

    def __init__(self, instructions: 'iEclipse::IInstructions *'):
        this = _connect.new_CPartitionCodeInfo(instructions)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getInstructionAtAddress(self, address: 'uint64_t') -> "isys::CInstruction":
        return _connect.CPartitionCodeInfo_getInstructionAtAddress(self, address)

    def getInstructionAtIndex(self, index: 'int64_t') -> "isys::CInstruction":
        return _connect.CPartitionCodeInfo_getInstructionAtIndex(self, index)

    def getIndexForAddress(self, address: 'uint64_t') -> "size_t":
        return _connect.CPartitionCodeInfo_getIndexForAddress(self, address)

    def getFunction(self, address: 'uint64_t') -> "std::string":
        return _connect.CPartitionCodeInfo_getFunction(self, address)

    def getFile(self, address: 'uint64_t') -> "std::string":
        return _connect.CPartitionCodeInfo_getFile(self, address)

    def getLine(self, address: 'uint64_t') -> "int":
        return _connect.CPartitionCodeInfo_getLine(self, address)

    def getSrcCode(self, address: 'uint64_t') -> "std::string":
        return _connect.CPartitionCodeInfo_getSrcCode(self, address)

    def getCalledFunctions(self, funcName: 'std::string', level: 'int', calledFunctions: 'StrVector') -> "void":
        return _connect.CPartitionCodeInfo_getCalledFunctions(self, funcName, level, calledFunctions)
    __swig_destroy__ = _connect.delete_CPartitionCodeInfo
    __del__ = lambda self: None
CPartitionCodeInfo_swigregister = _connect.CPartitionCodeInfo_swigregister
CPartitionCodeInfo_swigregister(CPartitionCodeInfo)

class CPartitionExecInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPartitionExecInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CPartitionExecInfo, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CPartitionExecInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CPartitionExecInfo
    __del__ = lambda self: None
CPartitionExecInfo_swigregister = _connect.CPartitionExecInfo_swigregister
CPartitionExecInfo_swigregister(CPartitionExecInfo)

class CInstructionIter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CInstructionIter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CInstructionIter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CInstructionIter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def hasNext(self) -> "bool":
        return _connect.CInstructionIter_hasNext(self)

    def next(self) -> "isys::CInstruction":
        return _connect.CInstructionIter_next(self)

    def peek(self) -> "isys::CInstruction":
        return _connect.CInstructionIter_peek(self)

    def branch(self, address: 'int64_t') -> "bool":
        return _connect.CInstructionIter_branch(self, address)

    def isAddressInRange(self, address: 'int64_t') -> "bool":
        return _connect.CInstructionIter_isAddressInRange(self, address)
    __swig_destroy__ = _connect.delete_CInstructionIter
    __del__ = lambda self: None
CInstructionIter_swigregister = _connect.CInstructionIter_swigregister
CInstructionIter_swigregister(CInstructionIter)

class CSOCCodeInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSOCCodeInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSOCCodeInfo, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CSOCCodeInfo
    __del__ = lambda self: None

    def release(self) -> "void":
        return _connect.CSOCCodeInfo_release(self)

    def getCodeInfo(self, partition: 'std::string const &') -> "isys::CPartitionCodeInfoSPtr":
        return _connect.CSOCCodeInfo_getCodeInfo(self, partition)

    def loadCodeInfo(self, dataCtrl2: 'isys::CDataController2SPtr &', partition: 'std::string const &') -> "isys::CPartitionCodeInfoSPtr":
        return _connect.CSOCCodeInfo_loadCodeInfo(self, dataCtrl2, partition)

    def __init__(self):
        this = _connect.new_CSOCCodeInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
CSOCCodeInfo_swigregister = _connect.CSOCCodeInfo_swigregister
CSOCCodeInfo_swigregister(CSOCCodeInfo)

class CLogger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CLogger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CLogger, name)
    __repr__ = _swig_repr
    JAVA = _connect.CLogger_JAVA
    PYTHON = _connect.CLogger_PYTHON

    def __init__(self, *args):
        this = _connect.new_CLogger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def writeHeader(self, header: 'std::string const &') -> "bool":
        return _connect.CLogger_writeHeader(self, header)

    def setIgnorableTimeDiff(self, timeDiff: 'double') -> "void":
        return _connect.CLogger_setIgnorableTimeDiff(self, timeDiff)
    __swig_destroy__ = _connect.delete_CLogger
    __del__ = lambda self: None

    def closeLog(self, footer: 'std::string const &') -> "void":
        return _connect.CLogger_closeLog(self, footer)

    def resetStartTime(self) -> "void":
        return _connect.CLogger_resetStartTime(self)

    def setIndent(self, indent: 'int') -> "void":
        return _connect.CLogger_setIndent(self, indent)

    def loggingOn(self) -> "void":
        return _connect.CLogger_loggingOn(self)

    def loggingOff(self) -> "void":
        return _connect.CLogger_loggingOff(self)

    def isLoggingOn(self) -> "bool":
        return _connect.CLogger_isLoggingOn(self)

    def logc(self, comment: 'std::string const &') -> "void":
        return _connect.CLogger_logc(self, comment)

    def logf(self, objName: 'std::string const &', methodName: 'std::string const &', format: 'char const *') -> "void":
        return _connect.CLogger_logf(self, objName, methodName, format)

    def log(self, *args) -> "void":
        return _connect.CLogger_log(self, *args)

    def createVar(self, varName: 'std::string const &', varType: 'std::string const &') -> "void":
        return _connect.CLogger_createVar(self, varName, varType)

    def fillVectorBYTE(self, varName: 'std::string const &', buff: 'VectorBYTE') -> "void":
        return _connect.CLogger_fillVectorBYTE(self, varName, buff)

    def createSType(self, valueName: 'std::string const &', sType: 'SType') -> "void":
        return _connect.CLogger_createSType(self, valueName, sType)
    if _newclass:
        icDebugAccessFlags2str = staticmethod(_connect.CLogger_icDebugAccessFlags2str)
    else:
        icDebugAccessFlags2str = _connect.CLogger_icDebugAccessFlags2str
    if _newclass:
        icDebugSymbolFlags2str = staticmethod(_connect.CLogger_icDebugSymbolFlags2str)
    else:
        icDebugSymbolFlags2str = _connect.CLogger_icDebugSymbolFlags2str
    if _newclass:
        icDebugAddressFlags2str = staticmethod(_connect.CLogger_icDebugAddressFlags2str)
    else:
        icDebugAddressFlags2str = _connect.CLogger_icDebugAddressFlags2str
    if _newclass:
        icDebugEvaluateFlags2str = staticmethod(_connect.CLogger_icDebugEvaluateFlags2str)
    else:
        icDebugEvaluateFlags2str = _connect.CLogger_icDebugEvaluateFlags2str
    if _newclass:
        icSTypeType2str = staticmethod(_connect.CLogger_icSTypeType2str)
    else:
        icSTypeType2str = _connect.CLogger_icSTypeType2str
    if _newclass:
        lang2str = staticmethod(_connect.CLogger_lang2str)
    else:
        lang2str = _connect.CLogger_lang2str
CLogger_swigregister = _connect.CLogger_swigregister
CLogger_swigregister(CLogger)

def CLogger_icDebugAccessFlags2str(flags: 'int') -> "std::string":
    return _connect.CLogger_icDebugAccessFlags2str(flags)
CLogger_icDebugAccessFlags2str = _connect.CLogger_icDebugAccessFlags2str

def CLogger_icDebugSymbolFlags2str(flags: 'int') -> "std::string":
    return _connect.CLogger_icDebugSymbolFlags2str(flags)
CLogger_icDebugSymbolFlags2str = _connect.CLogger_icDebugSymbolFlags2str

def CLogger_icDebugAddressFlags2str(flags: 'int') -> "std::string":
    return _connect.CLogger_icDebugAddressFlags2str(flags)
CLogger_icDebugAddressFlags2str = _connect.CLogger_icDebugAddressFlags2str

def CLogger_icDebugEvaluateFlags2str(flags: 'int') -> "std::string":
    return _connect.CLogger_icDebugEvaluateFlags2str(flags)
CLogger_icDebugEvaluateFlags2str = _connect.CLogger_icDebugEvaluateFlags2str

def CLogger_icSTypeType2str(flags: 'int') -> "std::string":
    return _connect.CLogger_icSTypeType2str(flags)
CLogger_icSTypeType2str = _connect.CLogger_icSTypeType2str

def CLogger_lang2str(flags: 'isys::CLogger::LogFileLanguage') -> "std::string":
    return _connect.CLogger_lang2str(flags)
CLogger_lang2str = _connect.CLogger_lang2str

class CWinIDEAVersion(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CWinIDEAVersion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CWinIDEAVersion, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CWinIDEAVersion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        getFileVersion = staticmethod(_connect.CWinIDEAVersion_getFileVersion)
    else:
        getFileVersion = _connect.CWinIDEAVersion_getFileVersion

    def getMajor(self) -> "int":
        return _connect.CWinIDEAVersion_getMajor(self)

    def getMinor(self) -> "int":
        return _connect.CWinIDEAVersion_getMinor(self)

    def getBuild(self) -> "int":
        return _connect.CWinIDEAVersion_getBuild(self)

    def getSubbuild(self) -> "int":
        return _connect.CWinIDEAVersion_getSubbuild(self)

    def compare(self, other: 'CWinIDEAVersion') -> "int":
        return _connect.CWinIDEAVersion_compare(self, other)

    def toString(self) -> "std::string":
        return _connect.CWinIDEAVersion_toString(self)
    __swig_destroy__ = _connect.delete_CWinIDEAVersion
    __del__ = lambda self: None
CWinIDEAVersion_swigregister = _connect.CWinIDEAVersion_swigregister
CWinIDEAVersion_swigregister(CWinIDEAVersion)

def CWinIDEAVersion_getFileVersion(fileName: 'std::string const &') -> "isys::CWinIDEAVersion":
    return _connect.CWinIDEAVersion_getFileVersion(fileName)
CWinIDEAVersion_getFileVersion = _connect.CWinIDEAVersion_getFileVersion

class CUMIController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CUMIController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CUMIController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CUMIController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CUMIController
    __del__ = lambda self: None

    def write(self, *args) -> "void":
        return _connect.CUMIController_write(self, *args)

    def read(self, deviceIndex: 'DWORD', address: 'ADDRESS', size: 'ADDRESS', data: 'VectorBYTE') -> "void":
        return _connect.CUMIController_read(self, deviceIndex, address, size, data)

    def flush(self, deviceIndex: 'DWORD') -> "void":
        return _connect.CUMIController_flush(self, deviceIndex)

    def erase(self, *args) -> "void":
        return _connect.CUMIController_erase(self, *args)

    def verify(self, *args) -> "void":
        return _connect.CUMIController_verify(self, *args)

    def blankCheck(self, *args) -> "void":
        return _connect.CUMIController_blankCheck(self, *args)

    def secure(self, *args) -> "void":
        return _connect.CUMIController_secure(self, *args)

    def unsecure(self, *args) -> "void":
        return _connect.CUMIController_unsecure(self, *args)

    def secureCheck(self, *args) -> "void":
        return _connect.CUMIController_secureCheck(self, *args)

    def readState(self, deviceIndex: 'DWORD', programMode: 'DWORD', address: 'ADDRESS', size: 'ADDRESS', stateResult: 'VectorBYTE') -> "void":
        return _connect.CUMIController_readState(self, deviceIndex, programMode, address, size, stateResult)

    def readHash(self, *args) -> "void":
        return _connect.CUMIController_readHash(self, *args)

    def getLastError(self) -> "std::string":
        return _connect.CUMIController_getLastError(self)
CUMIController_swigregister = _connect.CUMIController_swigregister
CUMIController_swigregister(CUMIController)


def exceptionsTest(exceptionIdx: 'int') -> "void":
    return _connect.exceptionsTest(exceptionIdx)
exceptionsTest = _connect.exceptionsTest
E_FALSE = _connect.E_FALSE
E_TRUE = _connect.E_TRUE
E_DEFAULT = _connect.E_DEFAULT

def putStrStrMap(container: 'StrStrMap', key: 'std::string const &', value: 'std::string const &') -> "void":
    return _connect.putStrStrMap(container, key, value)
putStrStrMap = _connect.putStrStrMap

def getModuleVersion() -> "std::string":
    return _connect.getModuleVersion()
getModuleVersion = _connect.getModuleVersion

def readChar() -> "int":
    return _connect.readChar()
readChar = _connect.readChar

def getUID() -> "std::string":
    return _connect.getUID()
getUID = _connect.getUID
class CUtil(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CUtil, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CUtil, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CUtil()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CUtil
    __del__ = lambda self: None
CUtil_swigregister = _connect.CUtil_swigregister
CUtil_swigregister(CUtil)
CUtil.g_qualifiedFuncNamePattern = _connect.cvar.CUtil_g_qualifiedFuncNamePattern
CUtil.g_qualifiedVarNamePattern = _connect.cvar.CUtil_g_qualifiedVarNamePattern
CUtil.MODULE_GRP_IDX = _connect.cvar.CUtil_MODULE_GRP_IDX
CUtil.SYM_NAME_GRP_IDX = _connect.cvar.CUtil_SYM_NAME_GRP_IDX
CUtil.SIGNATURE_GRP_IDX = _connect.cvar.CUtil_SIGNATURE_GRP_IDX
CUtil.DOWNLOAD_FILE_GRP_IDX = _connect.cvar.CUtil_DOWNLOAD_FILE_GRP_IDX

class CTestObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTestObject, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EYAMLScalar = _connect.CTestObject_EYAMLScalar
    EYAMLBool = _connect.CTestObject_EYAMLBool
    EYAMLEnum = _connect.CTestObject_EYAMLEnum
    EYAMLSeqence = _connect.CTestObject_EYAMLSeqence
    EYAMLMap = _connect.CTestObject_EYAMLMap
    ETestBase = _connect.CTestObject_ETestBase
    ETestBaseList = _connect.CTestObject_ETestBaseList
    __swig_destroy__ = _connect.delete_CTestObject
    __del__ = lambda self: None

    def setConst(self, isConst: 'bool') -> "void":
        return _connect.CTestObject_setConst(self, isConst)

    def assign(self, ptr: 'isys::CTestObjectSPtr const &') -> "void":
        return _connect.CTestObject_assign(self, ptr)

    def getTestObjType(self) -> "isys::CTestObject::ETestObjType":
        return _connect.CTestObject_getTestObjType(self)

    def copy(self) -> "isys::CTestObjectSPtr":
        return _connect.CTestObject_copy(self)

    def isEmpty(self) -> "bool":
        return _connect.CTestObject_isEmpty(self)

    def toString(self) -> "std::string":
        return _connect.CTestObject_toString(self)
CTestObject_swigregister = _connect.CTestObject_swigregister
CTestObject_swigregister(CTestObject)

class CTestBase(CTestObject):
    __swig_setmethods__ = {}
    for _s in [CTestObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestBase, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    NEW_LINE_COMMENT = _connect.CTestBase_NEW_LINE_COMMENT
    END_OF_LINE_COMMENT = _connect.CTestBase_END_OF_LINE_COMMENT
    KEY = _connect.CTestBase_KEY
    VALUE = _connect.CTestBase_VALUE
    LIST_ITEM = _connect.CTestBase_LIST_ITEM
    EMayBeEmpty = _connect.CTestBase_EMayBeEmpty
    EMandatory = _connect.CTestBase_EMandatory
    __swig_destroy__ = _connect.delete_CTestBase
    __del__ = lambda self: None

    def getClassName(self) -> "std::string":
        return _connect.CTestBase_getClassName(self)

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestBase_createInstance(self, parent)

    def setParent(self, parent: 'isys::CTestBaseSPtr') -> "void":
        return _connect.CTestBase_setParent(self, parent)

    def getParent(self) -> "isys::CTestBaseSPtr":
        return _connect.CTestBase_getParent(self)

    def copy(self) -> "isys::CTestObjectSPtr":
        return _connect.CTestBase_copy(self)
    if _newclass:
        cast = staticmethod(_connect.CTestBase_cast)
    else:
        cast = _connect.CTestBase_cast

    def assign(self, base: 'isys::CTestObjectSPtr const &') -> "void":
        return _connect.CTestBase_assign(self, base)

    def containsSection(self, section: 'int') -> "bool":
        return _connect.CTestBase_containsSection(self, section)

    def isSectionEmpty(self, sectionId: 'int') -> "bool":
        return _connect.CTestBase_isSectionEmpty(self, sectionId)

    def getNonNullEmptySections(self, emptySections: 'IntVector') -> "void":
        return _connect.CTestBase_getNonNullEmptySections(self, emptySections)

    def equalsData(self, other: 'isys::CTestBaseSPtr const &') -> "bool":
        return _connect.CTestBase_equalsData(self, other)

    def getContainerTestNode(self) -> "isys::CTestTreeNodeSPtr":
        return _connect.CTestBase_getContainerTestNode(self)

    def getHierarchyLevel(self) -> "int":
        return _connect.CTestBase_getHierarchyLevel(self)

    def isMerged(self) -> "bool":
        return _connect.CTestBase_isMerged(self)

    def isEmpty(self) -> "bool":
        return _connect.CTestBase_isEmpty(self)

    def isTestSpecification(self) -> "bool":
        return _connect.CTestBase_isTestSpecification(self)

    def getCachedMergedTestSpec(self, sectionId: 'int') -> "isys::CTestBaseSPtr":
        return _connect.CTestBase_getCachedMergedTestSpec(self, sectionId)

    def isSectionSet(self, section: 'int') -> "bool":
        return _connect.CTestBase_isSectionSet(self, section)

    def serialize(self, emitter: 'isys::IEmitterSPtr const &') -> "void":
        return _connect.CTestBase_serialize(self, emitter)

    def validate(self) -> "std::string":
        return _connect.CTestBase_validate(self)

    def toString(self) -> "std::string":
        return _connect.CTestBase_toString(self)

    def setMainMapStyle(self, mappingStyle: 'isys::IEmitter::EYamlStyle') -> "void":
        return _connect.CTestBase_setMainMapStyle(self, mappingStyle)

    def getSectionId(self, sectionName: 'std::string const &') -> "int":
        return _connect.CTestBase_getSectionId(self, sectionName)

    def getSectionType(self, section: 'int') -> "isys::CTestObject::ETestObjType":
        return _connect.CTestBase_getSectionType(self, section)

    def setSectionValue(self, section: 'int', objPtr: 'isys::CTestObjectSPtr const &') -> "void":
        return _connect.CTestBase_setSectionValue(self, section, objPtr)

    def getTestBase(self, section: 'int', isConst: 'bool') -> "isys::CTestBaseSPtr":
        return _connect.CTestBase_getTestBase(self, section, isConst)

    def getTestBaseList(self, section: 'int', isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestBase_getTestBaseList(self, section, isConst)

    def createTestBase(self, *args) -> "isys::CTestBaseSPtr":
        return _connect.CTestBase_createTestBase(self, *args)

    def getTestObjType(self) -> "isys::CTestObject::ETestObjType":
        return _connect.CTestBase_getTestObjType(self)

    def getSectionIds(self, sectionIds: 'IntVector') -> "void":
        return _connect.CTestBase_getSectionIds(self, sectionIds)

    def getDeprecatedSectionIds(self, sectionIds: 'IntVector') -> "void":
        return _connect.CTestBase_getDeprecatedSectionIds(self, sectionIds)

    def getTagName(self, section: 'int') -> "std::string":
        return _connect.CTestBase_getTagName(self, section)

    def getIntValue(self, section: 'int') -> "int64_t":
        return _connect.CTestBase_getIntValue(self, section)

    def getTagValue(self, *args) -> "std::string":
        return _connect.CTestBase_getTagValue(self, *args)

    def getTagValueOrDefault(self, section: 'int', key: 'std::string const &') -> "std::string":
        return _connect.CTestBase_getTagValueOrDefault(self, section, key)

    def getBoolTagValue(self, section: 'int') -> "isys::ETristate":
        return _connect.CTestBase_getBoolTagValue(self, section)

    def getBoolValueAsBool(self, section: 'int') -> "bool":
        return _connect.CTestBase_getBoolValueAsBool(self, section)

    def getEnumTagValue(self, section: 'int') -> "int":
        return _connect.CTestBase_getEnumTagValue(self, section)

    def getSectionValue(self, section: 'int', isConst: 'bool') -> "isys::CTestObjectSPtr":
        return _connect.CTestBase_getSectionValue(self, section, isConst)

    def containsMapEntry(self, section: 'int', key: 'std::string const &') -> "bool":
        return _connect.CTestBase_containsMapEntry(self, section, key)

    def removeMapEntry(self, section: 'int', key: 'std::string const &') -> "bool":
        return _connect.CTestBase_removeMapEntry(self, section, key)

    def removeValue(self, section: 'int') -> "bool":
        return _connect.CTestBase_removeValue(self, section)

    def setTagValue(self, *args) -> "void":
        return _connect.CTestBase_setTagValue(self, *args)

    def setBoolTagValue(self, section: 'int', value: 'isys::ETristate') -> "void":
        return _connect.CTestBase_setBoolTagValue(self, section, value)

    def setEnumTagValue(self, section: 'int', enumValue: 'int') -> "void":
        return _connect.CTestBase_setEnumTagValue(self, section, enumValue)

    def setComment(self, *args) -> "void":
        return _connect.CTestBase_setComment(self, *args)

    def getComment(self, *args) -> "std::string":
        return _connect.CTestBase_getComment(self, *args)

    def getCommentForSeqElement(self, section: 'int', idx: 'int', commentType: 'isys::CTestBase::CommentType') -> "std::string":
        return _connect.CTestBase_getCommentForSeqElement(self, section, idx, commentType)

    def getDefaultValue(self, sectionId: 'int') -> "int":
        return _connect.CTestBase_getDefaultValue(self, sectionId)

    def getEnumValues(self, sectionId: 'int', values: 'StrVector') -> "std::string":
        return _connect.CTestBase_getEnumValues(self, sectionId, values)

    def enum2Str(self, sectionId: 'int', enumValue: 'int') -> "std::string":
        return _connect.CTestBase_enum2Str(self, sectionId, enumValue)

    def isSerializedAsList(self, isParsing: 'bool') -> "bool":
        return _connect.CTestBase_isSerializedAsList(self, isParsing)
CTestBase_swigregister = _connect.CTestBase_swigregister
CTestBase_swigregister(CTestBase)

def CTestBase_cast(obj: 'isys::CTestObjectSPtr const &') -> "isys::CTestBaseSPtr":
    return _connect.CTestBase_cast(obj)
CTestBase_cast = _connect.CTestBase_cast

class CTestBaseList(CTestObject):
    __swig_setmethods__ = {}
    for _s in [CTestObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestBaseList, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestBaseList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CTestBaseList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestBaseList
    __del__ = lambda self: None

    def assign(self, ptr: 'isys::CTestObjectSPtr const &') -> "void":
        return _connect.CTestBaseList_assign(self, ptr)
    if _newclass:
        cast = staticmethod(_connect.CTestBaseList_cast)
    else:
        cast = _connect.CTestBaseList_cast

    def getParent(self) -> "isys::CTestBaseSPtr":
        return _connect.CTestBaseList_getParent(self)

    def setParent(self, parent: 'isys::CTestBaseSPtr &') -> "void":
        return _connect.CTestBaseList_setParent(self, parent)

    def moveElements(self, src: 'isys::CTestBaseListSPtr') -> "void":
        return _connect.CTestBaseList_moveElements(self, src)

    def copy(self) -> "isys::CTestObjectSPtr":
        return _connect.CTestBaseList_copy(self)

    def equalsData(self, other: 'isys::CTestBaseListSPtr const &') -> "bool":
        return _connect.CTestBaseList_equalsData(self, other)

    def clearEmptySections(self) -> "void":
        return _connect.CTestBaseList_clearEmptySections(self)

    def setParentToElements(self, parent: 'isys::CTestBaseSPtr') -> "void":
        return _connect.CTestBaseList_setParentToElements(self, parent)

    def add(self, idx: 'int', testBase: 'isys::CTestBaseSPtr') -> "void":
        return _connect.CTestBaseList_add(self, idx, testBase)

    def get(self, idx: 'int') -> "isys::CTestBaseSPtr":
        return _connect.CTestBaseList_get(self, idx)

    def size(self) -> "size_t":
        return _connect.CTestBaseList_size(self)

    def find(self, item: 'isys::CTestBaseSPtr const &') -> "int":
        return _connect.CTestBaseList_find(self, item)

    def remove(self, idx: 'int') -> "void":
        return _connect.CTestBaseList_remove(self, idx)

    def clear(self) -> "void":
        return _connect.CTestBaseList_clear(self)

    def serialize(self, emitter: 'isys::IEmitterSPtr const &') -> "void":
        return _connect.CTestBaseList_serialize(self, emitter)

    def getTestObjType(self) -> "isys::CTestObject::ETestObjType":
        return _connect.CTestBaseList_getTestObjType(self)

    def isEmpty(self) -> "bool":
        return _connect.CTestBaseList_isEmpty(self)

    def toString(self) -> "std::string":
        return _connect.CTestBaseList_toString(self)
CTestBaseList_swigregister = _connect.CTestBaseList_swigregister
CTestBaseList_swigregister(CTestBaseList)

def CTestBaseList_cast(obj: 'isys::CTestObjectSPtr const &') -> "isys::CTestBaseListSPtr":
    return _connect.CTestBaseList_cast(obj)
CTestBaseList_cast = _connect.CTestBaseList_cast

class CScalarAdapter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CScalarAdapter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CScalarAdapter, name)
    __repr__ = _swig_repr

    def __init__(self, obj: 'isys::CTestBaseSPtr const &', section: 'int', isConst: 'bool'):
        this = _connect.new_CScalarAdapter(obj, section, isConst)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getValue(self) -> "std::string":
        return _connect.CScalarAdapter_getValue(self)

    def getBoolValue(self) -> "bool":
        return _connect.CScalarAdapter_getBoolValue(self)

    def getComment(self, commentType: 'isys::CTestBase::CommentType') -> "std::string":
        return _connect.CScalarAdapter_getComment(self, commentType)

    def setValue(self, value: 'std::string const &') -> "void":
        return _connect.CScalarAdapter_setValue(self, value)

    def setComment(self, commentType: 'isys::CTestBase::CommentType', comment: 'std::string const &') -> "void":
        return _connect.CScalarAdapter_setComment(self, commentType, comment)

    def toString(self) -> "std::string":
        return _connect.CScalarAdapter_toString(self)
    __swig_destroy__ = _connect.delete_CScalarAdapter
    __del__ = lambda self: None
CScalarAdapter_swigregister = _connect.CScalarAdapter_swigregister
CScalarAdapter_swigregister(CScalarAdapter)

class CSequenceAdapter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSequenceAdapter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSequenceAdapter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CSequenceAdapter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def assign(self, src: 'isys::CSequenceAdapterSPtr &') -> "void":
        return _connect.CSequenceAdapter_assign(self, src)

    def equalsData(self, other: 'isys::CSequenceAdapterSPtr &') -> "bool":
        return _connect.CSequenceAdapter_equalsData(self, other)

    def size(self) -> "size_t":
        return _connect.CSequenceAdapter_size(self)

    def getValue(self, idx: 'int') -> "std::string":
        return _connect.CSequenceAdapter_getValue(self, idx)

    def getComment(self, commentType: 'isys::CTestBase::CommentType', idx: 'int') -> "std::string":
        return _connect.CSequenceAdapter_getComment(self, commentType, idx)

    def getStrVector(self, strVector: 'StrVector') -> "void":
        return _connect.CSequenceAdapter_getStrVector(self, strVector)

    def getMapAdapter(self, idx: 'int') -> "isys::CMapAdapterSPtr":
        return _connect.CSequenceAdapter_getMapAdapter(self, idx)

    def getSeqAdapter(self, idx: 'int') -> "isys::CSequenceAdapterSPtr":
        return _connect.CSequenceAdapter_getSeqAdapter(self, idx)

    def resize(self, newSize: 'int') -> "void":
        return _connect.CSequenceAdapter_resize(self, newSize)

    def add(self, *args) -> "void":
        return _connect.CSequenceAdapter_add(self, *args)

    def setValue(self, *args) -> "void":
        return _connect.CSequenceAdapter_setValue(self, *args)

    def setComment(self, idx: 'int', nlComment: 'std::string const &', eolComment: 'std::string const &') -> "void":
        return _connect.CSequenceAdapter_setComment(self, idx, nlComment, eolComment)

    def remove(self, idx: 'int') -> "void":
        return _connect.CSequenceAdapter_remove(self, idx)

    def toString(self) -> "std::string":
        return _connect.CSequenceAdapter_toString(self)
    __swig_destroy__ = _connect.delete_CSequenceAdapter
    __del__ = lambda self: None
CSequenceAdapter_swigregister = _connect.CSequenceAdapter_swigregister
CSequenceAdapter_swigregister(CSequenceAdapter)

class CMapAdapter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMapAdapter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CMapAdapter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CMapAdapter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def assign(self, src: 'isys::CMapAdapterSPtr &') -> "void":
        return _connect.CMapAdapter_assign(self, src)

    def equalsData(self, src: 'isys::CMapAdapterSPtr &') -> "bool":
        return _connect.CMapAdapter_equalsData(self, src)

    def contains(self, key: 'std::string const &') -> "bool":
        return _connect.CMapAdapter_contains(self, key)

    def size(self) -> "size_t":
        return _connect.CMapAdapter_size(self)

    def getValue(self, key: 'std::string const &') -> "std::string":
        return _connect.CMapAdapter_getValue(self, key)

    def getComment(self, commentType: 'isys::CTestBase::CommentType', key: 'std::string const &') -> "std::string":
        return _connect.CMapAdapter_getComment(self, commentType, key)

    def getStrStrMap(self, strMap: 'StrStrMap') -> "void":
        return _connect.CMapAdapter_getStrStrMap(self, strMap)

    def getKeys(self, strVector: 'StrVector') -> "void":
        return _connect.CMapAdapter_getKeys(self, strVector)

    def getKey(self, index: 'size_t') -> "std::string":
        return _connect.CMapAdapter_getKey(self, index)

    def getKeyIndex(self, key: 'std::string const &') -> "int":
        return _connect.CMapAdapter_getKeyIndex(self, key)

    def getMapAdapter(self, key: 'std::string const &') -> "isys::CMapAdapterSPtr":
        return _connect.CMapAdapter_getMapAdapter(self, key)

    def getSeqAdapter(self, key: 'std::string const &') -> "isys::CSequenceAdapterSPtr":
        return _connect.CMapAdapter_getSeqAdapter(self, key)

    def setValue(self, *args) -> "void":
        return _connect.CMapAdapter_setValue(self, *args)

    def setComment(self, key: 'std::string const &', nlComment: 'std::string const &', eolComment: 'std::string const &') -> "void":
        return _connect.CMapAdapter_setComment(self, key, nlComment, eolComment)

    def renameKey(self, oldKey: 'std::string const &', newKey: 'std::string const &') -> "void":
        return _connect.CMapAdapter_renameKey(self, oldKey, newKey)

    def removeEntry(self, key: 'std::string const &') -> "bool":
        return _connect.CMapAdapter_removeEntry(self, key)

    def removeAll(self) -> "void":
        return _connect.CMapAdapter_removeAll(self)

    def insertKey(self, key: 'std::string const &', predecessors: 'StrVector') -> "bool":
        return _connect.CMapAdapter_insertKey(self, key, predecessors)

    def moveKey(self, key: 'std::string const &', predecessors: 'StrVector') -> "bool":
        return _connect.CMapAdapter_moveKey(self, key, predecessors)

    def serialize(self) -> "std::string":
        return _connect.CMapAdapter_serialize(self)

    def parse(self, yamlStr: 'std::string const &') -> "void":
        return _connect.CMapAdapter_parse(self, yamlStr)

    def toString(self) -> "std::string":
        return _connect.CMapAdapter_toString(self)
    __swig_destroy__ = _connect.delete_CMapAdapter
    __del__ = lambda self: None
CMapAdapter_swigregister = _connect.CMapAdapter_swigregister
CMapAdapter_swigregister(CMapAdapter)

class CTestFilter(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestFilter, name)
    __repr__ = _swig_repr
    BUILT_IN_FILTER = _connect.CTestFilter_BUILT_IN_FILTER
    SCRIPT_FILTER = _connect.CTestFilter_SCRIPT_FILTER

    def filterQualifier(self, filterRegExs: 'StrVector', testCaseQualifier: 'std::string const &') -> "bool":
        return _connect.CTestFilter_filterQualifier(self, filterRegExs, testCaseQualifier)
    E_SECTION_FILTER_ID = _connect.CTestFilter_E_SECTION_FILTER_ID
    E_SECTION_FILTER_TYPE = _connect.CTestFilter_E_SECTION_FILTER_TYPE
    E_SECTION_CORE_ID = _connect.CTestFilter_E_SECTION_CORE_ID
    E_SECTION_PARTITIONS = _connect.CTestFilter_E_SECTION_PARTITIONS
    E_SECTION_MODULES = _connect.CTestFilter_E_SECTION_MODULES
    E_SECTION_INCLUDED_IDS = _connect.CTestFilter_E_SECTION_INCLUDED_IDS
    E_SECTION_EXCLUDED_IDS = _connect.CTestFilter_E_SECTION_EXCLUDED_IDS
    E_SECTION_INCLUDED_FUNCTIONS = _connect.CTestFilter_E_SECTION_INCLUDED_FUNCTIONS
    E_SECTION_EXCLUDED_FUNCTIONS = _connect.CTestFilter_E_SECTION_EXCLUDED_FUNCTIONS
    E_SECTION_MUST_HAVE_ALL_TAGS = _connect.CTestFilter_E_SECTION_MUST_HAVE_ALL_TAGS
    E_SECTION_MUST_HAVE_ONE_OF_TAGS = _connect.CTestFilter_E_SECTION_MUST_HAVE_ONE_OF_TAGS
    E_SECTION_MUST_NOT_HAVE_ALL_TAGS = _connect.CTestFilter_E_SECTION_MUST_NOT_HAVE_ALL_TAGS
    E_SECTION_MUST_NOT_HAVE_ONE_OF_TAGS = _connect.CTestFilter_E_SECTION_MUST_NOT_HAVE_ONE_OF_TAGS
    E_SECTION_IS_OR_TAGS_1 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_1
    E_SECTION_IS_OR_TAGS_2 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_2
    E_SECTION_IS_OR_TAGS_3 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_3
    E_SECTION_SCRIPT_FUNCTION = _connect.CTestFilter_E_SECTION_SCRIPT_FUNCTION
    E_SECTION_SCRIPT_FUNCTION_PARAMS = _connect.CTestFilter_E_SECTION_SCRIPT_FUNCTION_PARAMS

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CTestFilter(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestFilter_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestFilter_cast)
    else:
        cast = _connect.CTestFilter_cast

    def getFilterType(self) -> "isys::CTestFilter::EFilterTypes":
        return _connect.CTestFilter_getFilterType(self)

    def getFilterId(self) -> "std::string":
        return _connect.CTestFilter_getFilterId(self)

    def getCoreId(self) -> "std::string":
        return _connect.CTestFilter_getCoreId(self)

    def getPartitions(self, partitions: 'StrVector') -> "void":
        return _connect.CTestFilter_getPartitions(self, partitions)

    def getModules(self, modules: 'StrVector') -> "void":
        return _connect.CTestFilter_getModules(self, modules)

    def getMustHaveAllTags(self, tags: 'StrVector') -> "void":
        return _connect.CTestFilter_getMustHaveAllTags(self, tags)

    def getMustHaveOneOfTags(self, tags: 'StrVector') -> "void":
        return _connect.CTestFilter_getMustHaveOneOfTags(self, tags)

    def getMustNotHaveAllTags(self, tags: 'StrVector') -> "void":
        return _connect.CTestFilter_getMustNotHaveAllTags(self, tags)

    def getMustNotHaveOneOfTags(self, tags: 'StrVector') -> "void":
        return _connect.CTestFilter_getMustNotHaveOneOfTags(self, tags)

    def isOrTags1(self) -> "bool":
        return _connect.CTestFilter_isOrTags1(self)

    def isOrTags2(self) -> "bool":
        return _connect.CTestFilter_isOrTags2(self)

    def isOrTags3(self) -> "bool":
        return _connect.CTestFilter_isOrTags3(self)

    def getIncludedIds(self, ids: 'StrVector') -> "void":
        return _connect.CTestFilter_getIncludedIds(self, ids)

    def getExcludedIds(self, ids: 'StrVector') -> "void":
        return _connect.CTestFilter_getExcludedIds(self, ids)

    def getIncludedFunctions(self, functions: 'StrVector') -> "void":
        return _connect.CTestFilter_getIncludedFunctions(self, functions)

    def getExcludedFunctions(self, functions: 'StrVector') -> "void":
        return _connect.CTestFilter_getExcludedFunctions(self, functions)

    def getScriptFunction(self) -> "std::string":
        return _connect.CTestFilter_getScriptFunction(self)

    def getScriptFunctionParams(self, params: 'StrVector') -> "void":
        return _connect.CTestFilter_getScriptFunctionParams(self, params)

    def setFilterId(self, filterId: 'std::string const &') -> "void":
        return _connect.CTestFilter_setFilterId(self, filterId)

    def setFilterType(self, filterType: 'isys::CTestFilter::EFilterTypes') -> "void":
        return _connect.CTestFilter_setFilterType(self, filterType)

    def setMustHaveAllTags(self, tags: 'std::string const &') -> "void":
        return _connect.CTestFilter_setMustHaveAllTags(self, tags)

    def setMustHaveOneOfTags(self, tags: 'std::string const &') -> "void":
        return _connect.CTestFilter_setMustHaveOneOfTags(self, tags)

    def setMustNotHaveAllTags(self, tags: 'std::string const &') -> "void":
        return _connect.CTestFilter_setMustNotHaveAllTags(self, tags)

    def setMustNotHaveOneOfTags(self, tags: 'std::string const &') -> "void":
        return _connect.CTestFilter_setMustNotHaveOneOfTags(self, tags)

    def setOrTags1(self, isOr1: 'bool') -> "void":
        return _connect.CTestFilter_setOrTags1(self, isOr1)

    def setOrTags2(self, isOr2: 'bool') -> "void":
        return _connect.CTestFilter_setOrTags2(self, isOr2)

    def setOrTags3(self, isOr3: 'bool') -> "void":
        return _connect.CTestFilter_setOrTags3(self, isOr3)

    def setIncludedIds(self, ids: 'std::string const &') -> "void":
        return _connect.CTestFilter_setIncludedIds(self, ids)

    def setExcludedIds(self, ids: 'std::string const &') -> "void":
        return _connect.CTestFilter_setExcludedIds(self, ids)

    def setIncludedFunctions(self, functions: 'std::string const &') -> "void":
        return _connect.CTestFilter_setIncludedFunctions(self, functions)

    def setExcludedFunctions(self, functions: 'std::string const &') -> "void":
        return _connect.CTestFilter_setExcludedFunctions(self, functions)

    def setScriptFunction(self, functionName: 'std::string const &') -> "void":
        return _connect.CTestFilter_setScriptFunction(self, functionName)

    def setScriptFunctionParams(self, params: 'std::string const &') -> "void":
        return _connect.CTestFilter_setScriptFunctionParams(self, params)
    __swig_destroy__ = _connect.delete_CTestFilter
    __del__ = lambda self: None
CTestFilter_swigregister = _connect.CTestFilter_swigregister
CTestFilter_swigregister(CTestFilter)

def CTestFilter_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestFilterSPtr":
    return _connect.CTestFilter_cast(testBase)
CTestFilter_cast = _connect.CTestFilter_cast

class CTestFilterController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestFilterController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTestFilterController, name)
    __repr__ = _swig_repr

    def isEmpty(self) -> "bool":
        return _connect.CTestFilterController_isEmpty(self)

    def clear(self) -> "void":
        return _connect.CTestFilterController_clear(self)

    def countExecutableTests(self, testSpec: 'isys::CTestSpecificationSPtr const &', derivedLevel: 'int', testFilter: 'isys::CTestFilterSPtr const &') -> "int":
        return _connect.CTestFilterController_countExecutableTests(self, testSpec, derivedLevel, testFilter)

    def isTestExecutable(self, testSpec: 'isys::CTestSpecificationSPtr const &', testFilter: 'isys::CTestFilterSPtr const &') -> "bool":
        return _connect.CTestFilterController_isTestExecutable(self, testSpec, testFilter)

    def refreshSymbols(self, envConfig: 'isys::CTestEnvironmentConfigSPtr const &', globalsContainer: 'isys::CTestGlobalsContainerSPtr const &') -> "void":
        return _connect.CTestFilterController_refreshSymbols(self, envConfig, globalsContainer)

    def setDefaultCoreId(self, coreId: 'std::string const &') -> "void":
        return _connect.CTestFilterController_setDefaultCoreId(self, coreId)

    def setDefaultPartition(self, coreId: 'std::string const &', defaultPartition: 'std::string const &') -> "void":
        return _connect.CTestFilterController_setDefaultPartition(self, coreId, defaultPartition)

    def setFunctionToModuleMap(self, coreId: 'std::string const &', functionToModuleMap: 'StrStrMap') -> "void":
        return _connect.CTestFilterController_setFunctionToModuleMap(self, coreId, functionToModuleMap)

    def filterTestSpec(self, testSpec: 'isys::CTestSpecificationSPtr const &', isTestSpecMerged: 'bool', filter: 'isys::CTestFilterSPtr const &') -> "bool":
        return _connect.CTestFilterController_filterTestSpec(self, testSpec, isTestSpecMerged, filter)

    def getTestItemsForFilter(self, testGroup: 'isys::CTestGroupSPtr const &', partitions: 'StrVector', modules: 'StrVector', qualFuncNames: 'StrVector') -> "std::string":
        return _connect.CTestFilterController_getTestItemsForFilter(self, testGroup, partitions, modules, qualFuncNames)

    def countTestCasesInGroup(self, group: 'isys::CTestGroupSPtr const &', partitionsWTestInGroup: 'StrSet', modulesWTestInGroup: 'StrSet', functionsWTestInGroup: 'StrSet') -> "void":
        return _connect.CTestFilterController_countTestCasesInGroup(self, group, partitionsWTestInGroup, modulesWTestInGroup, functionsWTestInGroup)

    def toString(self) -> "std::string":
        return _connect.CTestFilterController_toString(self)

    def __init__(self):
        this = _connect.new_CTestFilterController()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestFilterController
    __del__ = lambda self: None
CTestFilterController_swigregister = _connect.CTestFilterController_swigregister
CTestFilterController_swigregister(CTestFilterController)

class CTestGlobalsContainer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestGlobalsContainer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTestGlobalsContainer, name)
    __repr__ = _swig_repr

    def refresh(self, mccmgr: 'isys::CMulticoreConnectionMgrSPtr const &', isRefreshTypes: 'bool') -> "void":
        return _connect.CTestGlobalsContainer_refresh(self, mccmgr, isRefreshTypes)

    def getCores(self, coreIds: 'StrVector') -> "void":
        return _connect.CTestGlobalsContainer_getCores(self, coreIds)

    def getPartitions(self, coreId: 'std::string const &', isGetPaths: 'bool', partitions: 'StrVector') -> "void":
        return _connect.CTestGlobalsContainer_getPartitions(self, coreId, isGetPaths, partitions)

    def getModules(self, coreId: 'std::string const &', partitionIdx: 'int', isGetPaths: 'bool', modules: 'StrVector') -> "void":
        return _connect.CTestGlobalsContainer_getModules(self, coreId, partitionIdx, isGetPaths, modules)

    def getFunctionsForModule(self, coreId: 'std::string const &', partitionIdx: 'int', moduleIdx: 'int', functions: 'StrVector') -> "void":
        return _connect.CTestGlobalsContainer_getFunctionsForModule(self, coreId, partitionIdx, moduleIdx, functions)

    def getFunctionToModulesMap(self, coreId: 'std::string const &', functionsToModulesMap: 'StrStrMap') -> "void":
        return _connect.CTestGlobalsContainer_getFunctionToModulesMap(self, coreId, functionsToModulesMap)

    def toString(self) -> "std::string":
        return _connect.CTestGlobalsContainer_toString(self)

    def __init__(self):
        this = _connect.new_CTestGlobalsContainer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestGlobalsContainer
    __del__ = lambda self: None
CTestGlobalsContainer_swigregister = _connect.CTestGlobalsContainer_swigregister
CTestGlobalsContainer_swigregister(CTestGlobalsContainer)

class CTestBench(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestBench, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestBench, name)
    __repr__ = _swig_repr
    E_SECTION_ENV_CONFIG = _connect.CTestBench_E_SECTION_ENV_CONFIG
    E_SECTION_REPORT_CONFIG = _connect.CTestBench_E_SECTION_REPORT_CONFIG
    E_SECTION_FILTERS = _connect.CTestBench_E_SECTION_FILTERS
    E_SECTION_GROUPS = _connect.CTestBench_E_SECTION_GROUPS
    E_SECTION_TESTS = _connect.CTestBench_E_SECTION_TESTS
    E_SECTION_TEST_CASES = _connect.CTestBench_E_SECTION_TEST_CASES

    def __init__(self):
        this = _connect.new_CTestBench()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestBench_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestBench_cast)
    else:
        cast = _connect.CTestBench_cast

    def getTestEnvironmentConfig(self, isConst: 'bool') -> "isys::CTestEnvironmentConfigSPtr":
        return _connect.CTestBench_getTestEnvironmentConfig(self, isConst)

    def getTestReportConfig(self, isConst: 'bool') -> "isys::CTestReportConfigSPtr":
        return _connect.CTestBench_getTestReportConfig(self, isConst)

    def getTestFilters(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestBench_getTestFilters(self, isConst)

    def getTestFilter(self, filterId: 'std::string const &') -> "isys::CTestFilterSPtr":
        return _connect.CTestBench_getTestFilter(self, filterId)

    def getGroup(self, isConst: 'bool') -> "isys::CTestGroupSPtr":
        return _connect.CTestBench_getGroup(self, isConst)

    def getTestSpecification(self, isConst: 'bool') -> "isys::CTestSpecificationSPtr":
        return _connect.CTestBench_getTestSpecification(self, isConst)

    def getWarnings(self) -> "std::string":
        return _connect.CTestBench_getWarnings(self)

    def getFileName(self) -> "std::string":
        return _connect.CTestBench_getFileName(self)

    def setFileName(self, fileName: 'std::string const &') -> "void":
        return _connect.CTestBench_setFileName(self, fileName)

    def getModelDirectory(self) -> "std::string":
        return _connect.CTestBench_getModelDirectory(self)

    def setTestSpecification(self, testSpec: 'isys::CTestSpecificationSPtr &') -> "void":
        return _connect.CTestBench_setTestSpecification(self, testSpec)
    if _newclass:
        load = staticmethod(_connect.CTestBench_load)
    else:
        load = _connect.CTestBench_load
    if _newclass:
        parse = staticmethod(_connect.CTestBench_parse)
    else:
        parse = _connect.CTestBench_parse

    def save(self, fileName: 'std::string const &', isAppend: 'bool'=False, isSaveLineNumbers: 'bool'=False) -> "void":
        return _connect.CTestBench_save(self, fileName, isAppend, isSaveLineNumbers)
    if _newclass:
        addUserInfoToReportConfig = staticmethod(_connect.CTestBench_addUserInfoToReportConfig)
    else:
        addUserInfoToReportConfig = _connect.CTestBench_addUserInfoToReportConfig

    def getTestReportContainer(self) -> "isys::CTestReportContainerSPtr":
        return _connect.CTestBench_getTestReportContainer(self)

    def getFilterController(self) -> "isys::CTestFilterControllerSPtr":
        return _connect.CTestBench_getFilterController(self)
    if _newclass:
        createDirIfNotExists = staticmethod(_connect.CTestBench_createDirIfNotExists)
    else:
        createDirIfNotExists = _connect.CTestBench_createDirIfNotExists
    if _newclass:
        saveTestResults = staticmethod(_connect.CTestBench_saveTestResults)
    else:
        saveTestResults = _connect.CTestBench_saveTestResults
    if _newclass:
        saveCSV = staticmethod(_connect.CTestBench_saveCSV)
    else:
        saveCSV = _connect.CTestBench_saveCSV
    if _newclass:
        saveYAML = staticmethod(_connect.CTestBench_saveYAML)
    else:
        saveYAML = _connect.CTestBench_saveYAML
    if _newclass:
        saveXML = staticmethod(_connect.CTestBench_saveXML)
    else:
        saveXML = _connect.CTestBench_saveXML
    if _newclass:
        initTargetForTest = staticmethod(_connect.CTestBench_initTargetForTest)
    else:
        initTargetForTest = _connect.CTestBench_initTargetForTest
    if _newclass:
        executeInitAction = staticmethod(_connect.CTestBench_executeInitAction)
    else:
        executeInitAction = _connect.CTestBench_executeInitAction
    if _newclass:
        restoreTargetAfterTest = staticmethod(_connect.CTestBench_restoreTargetAfterTest)
    else:
        restoreTargetAfterTest = _connect.CTestBench_restoreTargetAfterTest
    if _newclass:
        configureInterrupts = staticmethod(_connect.CTestBench_configureInterrupts)
    else:
        configureInterrupts = _connect.CTestBench_configureInterrupts
    if _newclass:
        restoreInterrupts = staticmethod(_connect.CTestBench_restoreInterrupts)
    else:
        restoreInterrupts = _connect.CTestBench_restoreInterrupts
    if _newclass:
        execTestCaseInitSequence = staticmethod(_connect.CTestBench_execTestCaseInitSequence)
    else:
        execTestCaseInitSequence = _connect.CTestBench_execTestCaseInitSequence
    if _newclass:
        configureBreakpointsMode = staticmethod(_connect.CTestBench_configureBreakpointsMode)
    else:
        configureBreakpointsMode = _connect.CTestBench_configureBreakpointsMode
    if _newclass:
        configureStackUsage = staticmethod(_connect.CTestBench_configureStackUsage)
    else:
        configureStackUsage = _connect.CTestBench_configureStackUsage
    if _newclass:
        isTestWithScripts = staticmethod(_connect.CTestBench_isTestWithScripts)
    else:
        isTestWithScripts = _connect.CTestBench_isTestWithScripts

    def refreshSymbolsAndGroupsIfEmpty(self, mccmgr: 'isys::CMulticoreConnectionMgrSPtr const &', customEnvConfig: 'isys::CTestEnvironmentConfigSPtr const &') -> "void":
        return _connect.CTestBench_refreshSymbolsAndGroupsIfEmpty(self, mccmgr, customEnvConfig)
    if _newclass:
        getCvrgFilterCandidates = staticmethod(_connect.CTestBench_getCvrgFilterCandidates)
    else:
        getCvrgFilterCandidates = _connect.CTestBench_getCvrgFilterCandidates

    def calculateGroupResults(self, mcmgr: 'isys::CMulticoreConnectionMgrSPtr const &', envConfig: 'isys::CTestEnvironmentConfigSPtr const &') -> "void":
        return _connect.CTestBench_calculateGroupResults(self, mcmgr, envConfig)

    def assignTestCasesToGroups(self, filterCtrl: 'isys::CTestFilterControllerSPtr const &') -> "void":
        return _connect.CTestBench_assignTestCasesToGroups(self, filterCtrl)

    def createTestBase(self, *args) -> "isys::CTestBaseSPtr":
        return _connect.CTestBench_createTestBase(self, *args)
    __swig_destroy__ = _connect.delete_CTestBench
    __del__ = lambda self: None
CTestBench_swigregister = _connect.CTestBench_swigregister
CTestBench_swigregister(CTestBench)
TMP_XSLT_CSS_EXTENSION = cvar.TMP_XSLT_CSS_EXTENSION

def CTestBench_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestBenchSPtr":
    return _connect.CTestBench_cast(testBase)
CTestBench_cast = _connect.CTestBench_cast

def CTestBench_load(fileName: 'std::string const &', filePos: 'size_t'=0) -> "isys::CTestBenchSPtr":
    return _connect.CTestBench_load(fileName, filePos)
CTestBench_load = _connect.CTestBench_load

def CTestBench_parse(yamlSpec: 'std::string const &') -> "isys::CTestBenchSPtr":
    return _connect.CTestBench_parse(yamlSpec)
CTestBench_parse = _connect.CTestBench_parse

def CTestBench_addUserInfoToReportConfig(reportConfig: 'isys::CTestReportConfigSPtr const &', testSpecificationFile: 'std::string const &', winIDEAWorkspace: 'std::string const &', winIDEAWorkspaceFile: 'std::string const &', defaultDlFile: 'std::string const &') -> "void":
    return _connect.CTestBench_addUserInfoToReportConfig(reportConfig, testSpecificationFile, winIDEAWorkspace, winIDEAWorkspaceFile, defaultDlFile)
CTestBench_addUserInfoToReportConfig = _connect.CTestBench_addUserInfoToReportConfig

def CTestBench_createDirIfNotExists(filePath: 'std::string const') -> "void":
    return _connect.CTestBench_createDirIfNotExists(filePath)
CTestBench_createDirIfNotExists = _connect.CTestBench_createDirIfNotExists

def CTestBench_saveTestResults(testResults: 'isys::CTestReportContainerSPtr const &', reportConfig: 'isys::CTestReportConfigSPtr &') -> "void":
    return _connect.CTestBench_saveTestResults(testResults, reportConfig)
CTestBench_saveTestResults = _connect.CTestBench_saveTestResults

def CTestBench_saveCSV(testResults: 'isys::CTestReportContainerSPtr const &', newReportConfig: 'isys::CTestReportConfigSPtr const &') -> "void":
    return _connect.CTestBench_saveCSV(testResults, newReportConfig)
CTestBench_saveCSV = _connect.CTestBench_saveCSV

def CTestBench_saveYAML(testResults: 'isys::CTestReportContainerSPtr const &', newReportConfig: 'isys::CTestReportConfigSPtr const &') -> "void":
    return _connect.CTestBench_saveYAML(testResults, newReportConfig)
CTestBench_saveYAML = _connect.CTestBench_saveYAML

def CTestBench_saveXML(testResults: 'isys::CTestReportContainerSPtr const &', newReportConfig: 'isys::CTestReportConfigSPtr const &') -> "void":
    return _connect.CTestBench_saveXML(testResults, newReportConfig)
CTestBench_saveXML = _connect.CTestBench_saveXML

def CTestBench_initTargetForTest(config: 'isys::CTestEnvironmentConfigSPtr &', debug: 'isys::CDebugFacadeSPtr &', ideCtrl: 'isys::CIDEControllerSPtr &', targetStopTimeout: 'int') -> "void":
    return _connect.CTestBench_initTargetForTest(config, debug, ideCtrl, targetStopTimeout)
CTestBench_initTargetForTest = _connect.CTestBench_initTargetForTest

def CTestBench_executeInitAction(envConfig: 'isys::CTestEnvironmentConfigSPtr &', mccMgr: 'isys::CMulticoreConnectionMgrSPtr &', action: 'isys::CInitSequenceActionSPtr &', stepIdx: 'int', isWaitUntilStopped: 'bool', targetStopTimeout: 'int') -> "void":
    return _connect.CTestBench_executeInitAction(envConfig, mccMgr, action, stepIdx, isWaitUntilStopped, targetStopTimeout)
CTestBench_executeInitAction = _connect.CTestBench_executeInitAction

def CTestBench_restoreTargetAfterTest(config: 'CTestEnvironmentConfig', debug: 'isys::CDebugFacadeSPtr &', ideCtrl: 'isys::CIDEControllerSPtr &', targetStopTimeout: 'int') -> "void":
    return _connect.CTestBench_restoreTargetAfterTest(config, debug, ideCtrl, targetStopTimeout)
CTestBench_restoreTargetAfterTest = _connect.CTestBench_restoreTargetAfterTest

def CTestBench_configureInterrupts(envConfig: 'CTestEnvironmentConfig', mccMgr: 'isys::CMulticoreConnectionMgrSPtr', interruptStates: 'StrStrMap') -> "void":
    return _connect.CTestBench_configureInterrupts(envConfig, mccMgr, interruptStates)
CTestBench_configureInterrupts = _connect.CTestBench_configureInterrupts

def CTestBench_restoreInterrupts(envConfig: 'CTestEnvironmentConfig', mccMgr: 'isys::CMulticoreConnectionMgrSPtr', interruptStates: 'StrStrMap') -> "void":
    return _connect.CTestBench_restoreInterrupts(envConfig, mccMgr, interruptStates)
CTestBench_restoreInterrupts = _connect.CTestBench_restoreInterrupts

def CTestBench_execTestCaseInitSequence(testCaseInitConfig: 'isys::CTestCaseTargetInitConfigSPtr &', debug: 'isys::CDebugFacadeSPtr &', targetStopTimeout: 'int') -> "void":
    return _connect.CTestBench_execTestCaseInitSequence(testCaseInitConfig, debug, targetStopTimeout)
CTestBench_execTestCaseInitSequence = _connect.CTestBench_execTestCaseInitSequence

def CTestBench_configureBreakpointsMode(ideCtrl: 'isys::CIDEControllerSPtr &', bpType: 'isys::CTestEnvironmentConfig::EBreakpointsType', coreIdx: 'int', isBeforeInit: 'bool') -> "void":
    return _connect.CTestBench_configureBreakpointsMode(ideCtrl, bpType, coreIdx, isBeforeInit)
CTestBench_configureBreakpointsMode = _connect.CTestBench_configureBreakpointsMode

def CTestBench_configureStackUsage(dataCtrl: 'isys::CDataController2SPtr &', runConfiguration: 'isys::CTestEnvironmentConfigSPtr &', coreId: 'std::string const &') -> "void":
    return _connect.CTestBench_configureStackUsage(dataCtrl, runConfiguration, coreId)
CTestBench_configureStackUsage = _connect.CTestBench_configureStackUsage

def CTestBench_isTestWithScripts(testSpec: 'isys::CTestSpecificationSPtr const &') -> "bool":
    return _connect.CTestBench_isTestWithScripts(testSpec)
CTestBench_isTestWithScripts = _connect.CTestBench_isTestWithScripts

def CTestBench_getCvrgFilterCandidates(mergedTestSpec: 'isys::CTestSpecificationSPtr &') -> "isys::CTestSpecificationSPtr":
    return _connect.CTestBench_getCvrgFilterCandidates(mergedTestSpec)
CTestBench_getCvrgFilterCandidates = _connect.CTestBench_getCvrgFilterCandidates

class CScriptConfig(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CScriptConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CScriptConfig, name)
    __repr__ = _swig_repr
    E_SCRIPT_SECTION_WORKING_DIR = _connect.CScriptConfig_E_SCRIPT_SECTION_WORKING_DIR
    E_SCRIPT_SECTION_MODULES = _connect.CScriptConfig_E_SCRIPT_SECTION_MODULES
    E_SCRIPT_SECTION_SYS_PATH = _connect.CScriptConfig_E_SCRIPT_SECTION_SYS_PATH
    E_SCRIPT_SECTION_TIMEOUT = _connect.CScriptConfig_E_SCRIPT_SECTION_TIMEOUT
    E_SCRIPT_SECTION_EXTENSION_CLASS = _connect.CScriptConfig_E_SCRIPT_SECTION_EXTENSION_CLASS

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CScriptConfig(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CScriptConfig_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CScriptConfig_cast)
    else:
        cast = _connect.CScriptConfig_cast

    def getWorkingDir(self) -> "std::string":
        return _connect.CScriptConfig_getWorkingDir(self)

    def getModules(self, modules: 'StrVector') -> "void":
        return _connect.CScriptConfig_getModules(self, modules)

    def getSysPaths(self, paths: 'StrVector') -> "void":
        return _connect.CScriptConfig_getSysPaths(self, paths)

    def getExtensionClass(self) -> "std::string":
        return _connect.CScriptConfig_getExtensionClass(self)

    def getTimeout(self) -> "int":
        return _connect.CScriptConfig_getTimeout(self)

    def setWorkingDir(self, workingDir: 'std::string const &') -> "void":
        return _connect.CScriptConfig_setWorkingDir(self, workingDir)

    def setModules(self, modules: 'StrVector') -> "void":
        return _connect.CScriptConfig_setModules(self, modules)

    def setSysPaths(self, sysPaths: 'StrVector') -> "void":
        return _connect.CScriptConfig_setSysPaths(self, sysPaths)

    def setExtensionClass(self, extensionClass: 'std::string const &') -> "void":
        return _connect.CScriptConfig_setExtensionClass(self, extensionClass)

    def setTimeout(self, timeout: 'int') -> "void":
        return _connect.CScriptConfig_setTimeout(self, timeout)
    __swig_destroy__ = _connect.delete_CScriptConfig
    __del__ = lambda self: None
CScriptConfig_swigregister = _connect.CScriptConfig_swigregister
CScriptConfig_swigregister(CScriptConfig)
CScriptConfig.EXT_METHOD_BEFORE_TESTS = _connect.cvar.CScriptConfig_EXT_METHOD_BEFORE_TESTS
CScriptConfig.EXT_METHOD_GET_TEST_REPORT_CUSTOM_DATA = _connect.cvar.CScriptConfig_EXT_METHOD_GET_TEST_REPORT_CUSTOM_DATA
CScriptConfig.EXT_METHOD_AFTER_REPORT_SAVE = _connect.cvar.CScriptConfig_EXT_METHOD_AFTER_REPORT_SAVE
CScriptConfig.EXT_METHOD_CUSTOM_PREFIX = _connect.cvar.CScriptConfig_EXT_METHOD_CUSTOM_PREFIX
CScriptConfig.EXT_METHOD_TABLE_PREFIX = _connect.cvar.CScriptConfig_EXT_METHOD_TABLE_PREFIX
CScriptConfig.EXT_METHOD_TABLE_TYPE = _connect.cvar.CScriptConfig_EXT_METHOD_TABLE_TYPE
CScriptConfig.EXT_METHOD_TYPE = _connect.cvar.CScriptConfig_EXT_METHOD_TYPE

def CScriptConfig_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CScriptConfigSPtr":
    return _connect.CScriptConfig_cast(testBase)
CScriptConfig_cast = _connect.CScriptConfig_cast

class CEvaluatorConfig(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CEvaluatorConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CEvaluatorConfig, name)
    __repr__ = _swig_repr
    ECDAscii = _connect.CEvaluatorConfig_ECDAscii
    ECDInteger = _connect.CEvaluatorConfig_ECDInteger
    ECDBoth = _connect.CEvaluatorConfig_ECDBoth
    EBDBlanks = _connect.CEvaluatorConfig_EBDBlanks
    EBDNoBlanksTrailingB = _connect.CEvaluatorConfig_EBDNoBlanksTrailingB
    EADHexNoPrefix = _connect.CEvaluatorConfig_EADHexNoPrefix
    EADHexPrefix = _connect.CEvaluatorConfig_EADHexPrefix
    EEDEnum = _connect.CEvaluatorConfig_EEDEnum
    EEDInteger = _connect.CEvaluatorConfig_EEDInteger
    EEDBoth = _connect.CEvaluatorConfig_EEDBoth
    E_EVALUATOR_SECTION_IS_OVERRIDE_WINIDEA_SETTINGS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_IS_OVERRIDE_WINIDEA_SETTINGS
    E_EVALUATOR_SECTION_CHAR_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_CHAR_DISPLAY
    E_EVALUATOR_SECTION_ANSI = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ANSI
    E_EVALUATOR_SECTION_HEX = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_HEX
    E_EVALUATOR_SECTION_BINARY_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_BINARY_DISPLAY
    E_EVALUATOR_SECTION_DISPLAY_POINTER_MEM_AREA = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DISPLAY_POINTER_MEM_AREA
    E_EVALUATOR_SECTION_CHAR_ARRAY_AS_STRING = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_CHAR_ARRAY_AS_STRING
    E_EVALUATOR_SECTION_DEREFERENCE_STRING_POINTERS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DEREFERENCE_STRING_POINTERS
    E_EVALUATOR_SECTION_ADDRESS_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ADDRESS_DISPLAY
    E_EVALUATOR_SECTION_ENUM_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ENUM_DISPLAY
    E_EVALUATOR_SECTION_DISPLAY_COLLAPSED_ARRAY_STRUCT = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DISPLAY_COLLAPSED_ARRAY_STRUCT
    E_EVALUATOR_SECTION_VAGUE_FLOAT_PRECISION = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_VAGUE_FLOAT_PRECISION
    E_EVALUATOR_SECTION_IS_USE_DEFAULT_WI_SETTINGS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_IS_USE_DEFAULT_WI_SETTINGS

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CEvaluatorConfig(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CEvaluatorConfig_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CEvaluatorConfig_cast)
    else:
        cast = _connect.CEvaluatorConfig_cast

    def applySettingsToWinIDEA(self, ideSPtr: 'isys::CIDEControllerSPtr &') -> "void":
        return _connect.CEvaluatorConfig_applySettingsToWinIDEA(self, ideSPtr)

    def getCharDisplay(self) -> "isys::CEvaluatorConfig::ECharDisplay":
        return _connect.CEvaluatorConfig_getCharDisplay(self)

    def isOverrideWinIDEASettings(self) -> "bool":
        return _connect.CEvaluatorConfig_isOverrideWinIDEASettings(self)

    def isAnsi(self) -> "bool":
        return _connect.CEvaluatorConfig_isAnsi(self)

    def isHex(self) -> "bool":
        return _connect.CEvaluatorConfig_isHex(self)

    def getBinaryDisplay(self) -> "isys::CEvaluatorConfig::EBinaryDisplay":
        return _connect.CEvaluatorConfig_getBinaryDisplay(self)

    def isDisplayPointerMemArea(self) -> "bool":
        return _connect.CEvaluatorConfig_isDisplayPointerMemArea(self)

    def isCharArrayAsString(self) -> "bool":
        return _connect.CEvaluatorConfig_isCharArrayAsString(self)

    def isDereferenceStringPointers(self) -> "bool":
        return _connect.CEvaluatorConfig_isDereferenceStringPointers(self)

    def getAddressDisplay(self) -> "isys::CEvaluatorConfig::EAddressDisplay":
        return _connect.CEvaluatorConfig_getAddressDisplay(self)

    def getEnumDisplay(self) -> "isys::CEvaluatorConfig::EEnumDisplay":
        return _connect.CEvaluatorConfig_getEnumDisplay(self)

    def isDisplayCollapsedArrayStruct(self) -> "bool":
        return _connect.CEvaluatorConfig_isDisplayCollapsedArrayStruct(self)

    def getVagueFloatPrecision(self) -> "double":
        return _connect.CEvaluatorConfig_getVagueFloatPrecision(self)

    def setOverrideWinIDEASettings(self, isOverrideWinIDEASettings: 'isys::ETristate') -> "void":
        return _connect.CEvaluatorConfig_setOverrideWinIDEASettings(self, isOverrideWinIDEASettings)

    def setCharDisplay(self, charDisplay: 'isys::CEvaluatorConfig::ECharDisplay') -> "void":
        return _connect.CEvaluatorConfig_setCharDisplay(self, charDisplay)

    def setAnsi(self, isAnsi: 'isys::ETristate') -> "void":
        return _connect.CEvaluatorConfig_setAnsi(self, isAnsi)

    def setHex(self, isHex: 'isys::ETristate') -> "void":
        return _connect.CEvaluatorConfig_setHex(self, isHex)

    def setBinaryDisplay(self, binaryDisplay: 'isys::CEvaluatorConfig::EBinaryDisplay') -> "void":
        return _connect.CEvaluatorConfig_setBinaryDisplay(self, binaryDisplay)

    def setDisplayPointerMemArea(self, isDisplayPointerMemArea: 'isys::ETristate') -> "void":
        return _connect.CEvaluatorConfig_setDisplayPointerMemArea(self, isDisplayPointerMemArea)

    def setCharArrayAsString(self, isCharArrayAsString: 'isys::ETristate') -> "void":
        return _connect.CEvaluatorConfig_setCharArrayAsString(self, isCharArrayAsString)

    def setDereferenceStringPointers(self, isDereferenceStringPointers: 'isys::ETristate') -> "void":
        return _connect.CEvaluatorConfig_setDereferenceStringPointers(self, isDereferenceStringPointers)

    def setAddressDisplay(self, addrDisplay: 'isys::CEvaluatorConfig::EAddressDisplay') -> "void":
        return _connect.CEvaluatorConfig_setAddressDisplay(self, addrDisplay)

    def setEnumDisplay(self, enumDisplay: 'isys::CEvaluatorConfig::EEnumDisplay') -> "void":
        return _connect.CEvaluatorConfig_setEnumDisplay(self, enumDisplay)

    def setDisplayCollapsedArrayStruct(self, isDisplayCollapsedArrayStruct: 'isys::ETristate') -> "void":
        return _connect.CEvaluatorConfig_setDisplayCollapsedArrayStruct(self, isDisplayCollapsedArrayStruct)

    def setVagueFloatPrecision(self, precision: 'double') -> "void":
        return _connect.CEvaluatorConfig_setVagueFloatPrecision(self, precision)
    if _newclass:
        charDisplayEnum2Str = staticmethod(_connect.CEvaluatorConfig_charDisplayEnum2Str)
    else:
        charDisplayEnum2Str = _connect.CEvaluatorConfig_charDisplayEnum2Str
    if _newclass:
        binaryDisplayEnum2Str = staticmethod(_connect.CEvaluatorConfig_binaryDisplayEnum2Str)
    else:
        binaryDisplayEnum2Str = _connect.CEvaluatorConfig_binaryDisplayEnum2Str
    if _newclass:
        addressDisplayEnum2Str = staticmethod(_connect.CEvaluatorConfig_addressDisplayEnum2Str)
    else:
        addressDisplayEnum2Str = _connect.CEvaluatorConfig_addressDisplayEnum2Str
    if _newclass:
        enumDisplayEnum2Str = staticmethod(_connect.CEvaluatorConfig_enumDisplayEnum2Str)
    else:
        enumDisplayEnum2Str = _connect.CEvaluatorConfig_enumDisplayEnum2Str
    __swig_destroy__ = _connect.delete_CEvaluatorConfig
    __del__ = lambda self: None
CEvaluatorConfig_swigregister = _connect.CEvaluatorConfig_swigregister
CEvaluatorConfig_swigregister(CEvaluatorConfig)

def CEvaluatorConfig_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CEvaluatorConfigSPtr":
    return _connect.CEvaluatorConfig_cast(testBase)
CEvaluatorConfig_cast = _connect.CEvaluatorConfig_cast

def CEvaluatorConfig_charDisplayEnum2Str(val: 'isys::CEvaluatorConfig::ECharDisplay') -> "std::string":
    return _connect.CEvaluatorConfig_charDisplayEnum2Str(val)
CEvaluatorConfig_charDisplayEnum2Str = _connect.CEvaluatorConfig_charDisplayEnum2Str

def CEvaluatorConfig_binaryDisplayEnum2Str(val: 'isys::CEvaluatorConfig::EBinaryDisplay') -> "std::string":
    return _connect.CEvaluatorConfig_binaryDisplayEnum2Str(val)
CEvaluatorConfig_binaryDisplayEnum2Str = _connect.CEvaluatorConfig_binaryDisplayEnum2Str

def CEvaluatorConfig_addressDisplayEnum2Str(val: 'isys::CEvaluatorConfig::EAddressDisplay') -> "std::string":
    return _connect.CEvaluatorConfig_addressDisplayEnum2Str(val)
CEvaluatorConfig_addressDisplayEnum2Str = _connect.CEvaluatorConfig_addressDisplayEnum2Str

def CEvaluatorConfig_enumDisplayEnum2Str(val: 'isys::CEvaluatorConfig::EEnumDisplay') -> "std::string":
    return _connect.CEvaluatorConfig_enumDisplayEnum2Str(val)
CEvaluatorConfig_enumDisplayEnum2Str = _connect.CEvaluatorConfig_enumDisplayEnum2Str

class CInitSequenceAction(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CInitSequenceAction, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CInitSequenceAction, name)
    __repr__ = _swig_repr
    E_INIT_SEQ_CORE_ID = _connect.CInitSequenceAction_E_INIT_SEQ_CORE_ID
    E_INIT_SEQ_ACTION = _connect.CInitSequenceAction_E_INIT_SEQ_ACTION
    E_INIT_SEQ_PARAMS = _connect.CInitSequenceAction_E_INIT_SEQ_PARAMS
    EIAConnectToCore = _connect.CInitSequenceAction_EIAConnectToCore
    EIADownload = _connect.CInitSequenceAction_EIADownload
    EIAReset = _connect.CInitSequenceAction_EIAReset
    EIARun = _connect.CInitSequenceAction_EIARun
    EIADeleteAllBreakpoints = _connect.CInitSequenceAction_EIADeleteAllBreakpoints
    EIACallTargetFunction = _connect.CInitSequenceAction_EIACallTargetFunction
    EIACallScriptFunction = _connect.CInitSequenceAction_EIACallScriptFunction
    EIALoadSymbolsOnly = _connect.CInitSequenceAction_EIALoadSymbolsOnly
    EIAWaitUntilStopped = _connect.CInitSequenceAction_EIAWaitUntilStopped

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CInitSequenceAction(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CInitSequenceAction_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CInitSequenceAction_cast)
    else:
        cast = _connect.CInitSequenceAction_cast

    def getCoreId(self) -> "std::string":
        return _connect.CInitSequenceAction_getCoreId(self)

    def getAction(self) -> "isys::CInitSequenceAction::EInitAction":
        return _connect.CInitSequenceAction_getAction(self)

    def getActionName(self) -> "std::string":
        return _connect.CInitSequenceAction_getActionName(self)

    def setCoreId(self, coreId: 'std::string const &') -> "void":
        return _connect.CInitSequenceAction_setCoreId(self, coreId)

    def setAction(self, action: 'isys::CInitSequenceAction::EInitAction') -> "void":
        return _connect.CInitSequenceAction_setAction(self, action)
    __swig_destroy__ = _connect.delete_CInitSequenceAction
    __del__ = lambda self: None
CInitSequenceAction_swigregister = _connect.CInitSequenceAction_swigregister
CInitSequenceAction_swigregister(CInitSequenceAction)

def CInitSequenceAction_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CInitSequenceActionSPtr":
    return _connect.CInitSequenceAction_cast(testBase)
CInitSequenceAction_cast = _connect.CInitSequenceAction_cast

class CTestCaseTargetInitConfig(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestCaseTargetInitConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestCaseTargetInitConfig, name)
    __repr__ = _swig_repr
    E_TEST_CASE_SECTION_IS_DL_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_DL_ON_TC_INIT
    E_TEST_CASE_SECTION_IS_RESET_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_RESET_ON_TC_INIT
    E_TEST_CASE_SECTION_IS_RUN_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_RUN_ON_TC_INIT
    E_TEST_CASE_SECTION_STOP_FUNC_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_STOP_FUNC_ON_TC_INIT

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CTestCaseTargetInitConfig(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestCaseTargetInitConfig_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestCaseTargetInitConfig_cast)
    else:
        cast = _connect.CTestCaseTargetInitConfig_cast

    def isDownloadOnTCInit(self) -> "bool":
        return _connect.CTestCaseTargetInitConfig_isDownloadOnTCInit(self)

    def isResetOnTCInit(self) -> "bool":
        return _connect.CTestCaseTargetInitConfig_isResetOnTCInit(self)

    def isRunOnTCInit(self) -> "bool":
        return _connect.CTestCaseTargetInitConfig_isRunOnTCInit(self)

    def getStopFunctionOnTCInit(self) -> "std::string":
        return _connect.CTestCaseTargetInitConfig_getStopFunctionOnTCInit(self)

    def setDownloadOnTCInit(self, isDownload: 'isys::ETristate') -> "void":
        return _connect.CTestCaseTargetInitConfig_setDownloadOnTCInit(self, isDownload)

    def setResetOnTCInit(self, isReset: 'isys::ETristate') -> "void":
        return _connect.CTestCaseTargetInitConfig_setResetOnTCInit(self, isReset)

    def setRunOnTCInit(self, isRun: 'isys::ETristate') -> "void":
        return _connect.CTestCaseTargetInitConfig_setRunOnTCInit(self, isRun)

    def setStopFunctionOnTCInit(self, stopFunction: 'std::string const &') -> "void":
        return _connect.CTestCaseTargetInitConfig_setStopFunctionOnTCInit(self, stopFunction)
    __swig_destroy__ = _connect.delete_CTestCaseTargetInitConfig
    __del__ = lambda self: None
CTestCaseTargetInitConfig_swigregister = _connect.CTestCaseTargetInitConfig_swigregister
CTestCaseTargetInitConfig_swigregister(CTestCaseTargetInitConfig)

def CTestCaseTargetInitConfig_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestCaseTargetInitConfigSPtr":
    return _connect.CTestCaseTargetInitConfig_cast(testBase)
CTestCaseTargetInitConfig_cast = _connect.CTestCaseTargetInitConfig_cast

class CStackUsageConfig(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CStackUsageConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CStackUsageConfig, name)
    __repr__ = _swig_repr
    E_SECTION_CORE_ID = _connect.CStackUsageConfig_E_SECTION_CORE_ID
    E_SECTION_IS_ACTIVE = _connect.CStackUsageConfig_E_SECTION_IS_ACTIVE
    E_SECTION_BASE = _connect.CStackUsageConfig_E_SECTION_BASE
    E_SECTION_END = _connect.CStackUsageConfig_E_SECTION_END
    E_SECTION_PATTERN = _connect.CStackUsageConfig_E_SECTION_PATTERN

    def __init__(self, *args):
        this = _connect.new_CStackUsageConfig(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CStackUsageConfig
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CStackUsageConfig_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CStackUsageConfig_cast)
    else:
        cast = _connect.CStackUsageConfig_cast

    def getCoreId(self) -> "std::string":
        return _connect.CStackUsageConfig_getCoreId(self)

    def isActive(self) -> "bool":
        return _connect.CStackUsageConfig_isActive(self)

    def getBase(self) -> "DWORD":
        return _connect.CStackUsageConfig_getBase(self)

    def getEnd(self) -> "DWORD":
        return _connect.CStackUsageConfig_getEnd(self)

    def getBaseExpr(self) -> "std::string":
        return _connect.CStackUsageConfig_getBaseExpr(self)

    def getEndExpr(self) -> "std::string":
        return _connect.CStackUsageConfig_getEndExpr(self)

    def getPattern(self) -> "int":
        return _connect.CStackUsageConfig_getPattern(self)

    def setCoreId(self, coreId: 'std::string const &') -> "void":
        return _connect.CStackUsageConfig_setCoreId(self, coreId)

    def setActive(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CStackUsageConfig_setActive(self, isActive)

    def setBase(self, minSize: 'DWORD') -> "void":
        return _connect.CStackUsageConfig_setBase(self, minSize)

    def setEnd(self, maxSize: 'DWORD') -> "void":
        return _connect.CStackUsageConfig_setEnd(self, maxSize)

    def setPattern(self, pattern: 'unsigned char') -> "void":
        return _connect.CStackUsageConfig_setPattern(self, pattern)
CStackUsageConfig_swigregister = _connect.CStackUsageConfig_swigregister
CStackUsageConfig_swigregister(CStackUsageConfig)

def CStackUsageConfig_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CStackUsageConfigSPtr":
    return _connect.CStackUsageConfig_cast(testBase)
CStackUsageConfig_cast = _connect.CStackUsageConfig_cast

class CToolsConfig(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CToolsConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CToolsConfig, name)
    __repr__ = _swig_repr
    E_SECTION_IS_AUTO_SET_ANALYZER_FNAME = _connect.CToolsConfig_E_SECTION_IS_AUTO_SET_ANALYZER_FNAME
    E_SECTION_ANALYZER_FNAME = _connect.CToolsConfig_E_SECTION_ANALYZER_FNAME
    E_SECTION_IS_SET_TEST_ID_ON_PASTE = _connect.CToolsConfig_E_SECTION_IS_SET_TEST_ID_ON_PASTE

    def __init__(self, *args):
        this = _connect.new_CToolsConfig(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CToolsConfig
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CToolsConfig_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CToolsConfig_cast)
    else:
        cast = _connect.CToolsConfig_cast

    def isAutoSetAnalyzerFName(self) -> "bool":
        return _connect.CToolsConfig_isAutoSetAnalyzerFName(self)

    def getAnalyzerFName(self) -> "std::string":
        return _connect.CToolsConfig_getAnalyzerFName(self)

    def isSetTestIdOnPaste(self) -> "bool":
        return _connect.CToolsConfig_isSetTestIdOnPaste(self)

    def setAnalyzerFName(self, fName: 'std::string const &') -> "void":
        return _connect.CToolsConfig_setAnalyzerFName(self, fName)

    def setAutoSetAnalyzerFName(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CToolsConfig_setAutoSetAnalyzerFName(self, isActive)
CToolsConfig_swigregister = _connect.CToolsConfig_swigregister
CToolsConfig_swigregister(CToolsConfig)

def CToolsConfig_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CToolsConfigSPtr":
    return _connect.CToolsConfig_cast(testBase)
CToolsConfig_cast = _connect.CToolsConfig_cast

class CTestEnvironmentConfig(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestEnvironmentConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestEnvironmentConfig, name)
    __repr__ = _swig_repr
    EKeepWinIDEASetting = _connect.CTestEnvironmentConfig_EKeepWinIDEASetting
    EUseHWBPs = _connect.CTestEnvironmentConfig_EUseHWBPs
    EUseSWBPs = _connect.CTestEnvironmentConfig_EUseSWBPs
    EUseHWBPsForInitThenSWBPs = _connect.CTestEnvironmentConfig_EUseHWBPsForInitThenSWBPs
    E_SECTION_VERSION = _connect.CTestEnvironmentConfig_E_SECTION_VERSION
    E_SECTION_WINIDEA_WORKSPACE_FILE_NAME = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_WORKSPACE_FILE_NAME
    E_SECTION_USE_QUALIFIED_FUNC_NAME = _connect.CTestEnvironmentConfig_E_SECTION_USE_QUALIFIED_FUNC_NAME
    E_SECTION_WINIDEA_ADDRESS = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_ADDRESS
    E_SECTION_WINIDEA_PORT = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_PORT
    E_SECTION_CORE_IDS = _connect.CTestEnvironmentConfig_E_SECTION_CORE_IDS
    E_SECTION_IS_AUTO_CONNECT = _connect.CTestEnvironmentConfig_E_SECTION_IS_AUTO_CONNECT
    E_SECTION_AUTO_ID_FORMAT_STRING = _connect.CTestEnvironmentConfig_E_SECTION_AUTO_ID_FORMAT_STRING
    E_SECTION_DEFAULT_RET_VAL_NAME = _connect.CTestEnvironmentConfig_E_SECTION_DEFAULT_RET_VAL_NAME
    E_SECTION_LOG_PARAMETERS = _connect.CTestEnvironmentConfig_E_SECTION_LOG_PARAMETERS
    E_SECTION_ALWAYS_RUN_INIT_SEQ = _connect.CTestEnvironmentConfig_E_SECTION_ALWAYS_RUN_INIT_SEQ
    E_SECTION_DISABLE_INTERRUPTS = _connect.CTestEnvironmentConfig_E_SECTION_DISABLE_INTERRUPTS
    E_SECTION_TEST_TIMEOUT = _connect.CTestEnvironmentConfig_E_SECTION_TEST_TIMEOUT
    E_SECTION_BREAKPOINTS_TYPE = _connect.CTestEnvironmentConfig_E_SECTION_BREAKPOINTS_TYPE
    E_SECTION_INIT_SEQUENCE = _connect.CTestEnvironmentConfig_E_SECTION_INIT_SEQUENCE
    E_SECTION_SCRIPT = _connect.CTestEnvironmentConfig_E_SECTION_SCRIPT
    E_SECTION_TOOLS_CONFIG = _connect.CTestEnvironmentConfig_E_SECTION_TOOLS_CONFIG
    E_SECTION_EVALUATOR = _connect.CTestEnvironmentConfig_E_SECTION_EVALUATOR
    E_SECTION_TARGET_INIT = _connect.CTestEnvironmentConfig_E_SECTION_TARGET_INIT
    E_SECTION_STACK_USAGE = _connect.CTestEnvironmentConfig_E_SECTION_STACK_USAGE
    E_SECTION_CHECK_TARGET_STATE_BEFORE_RUN = _connect.CTestEnvironmentConfig_E_SECTION_CHECK_TARGET_STATE_BEFORE_RUN
    E_SECTION_VERIFY_SYMBOLS_BEFORE_RUN = _connect.CTestEnvironmentConfig_E_SECTION_VERIFY_SYMBOLS_BEFORE_RUN
    E_SECTION_STACK_USAGE_DEPR = _connect.CTestEnvironmentConfig_E_SECTION_STACK_USAGE_DEPR
    E_SECTION_IS_DOWNLOAD_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_DOWNLOAD_ON_INIT
    E_SECTION_IS_RESET_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_RESET_ON_INIT
    E_SECTION_IS_RUN_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_RUN_ON_INIT
    E_SECTION_STOP_FUNCTION = _connect.CTestEnvironmentConfig_E_SECTION_STOP_FUNCTION
    E_SECTION_DELETE_BPS = _connect.CTestEnvironmentConfig_E_SECTION_DELETE_BPS

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CTestEnvironmentConfig(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestEnvironmentConfig_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestEnvironmentConfig_cast)
    else:
        cast = _connect.CTestEnvironmentConfig_cast

    def serialize(self, emitter: 'isys::IEmitterSPtr &') -> "void":
        return _connect.CTestEnvironmentConfig_serialize(self, emitter)

    def getVersion(self) -> "std::string":
        return _connect.CTestEnvironmentConfig_getVersion(self)
    if _newclass:
        getStaticVersion = staticmethod(_connect.CTestEnvironmentConfig_getStaticVersion)
    else:
        getStaticVersion = _connect.CTestEnvironmentConfig_getStaticVersion

    def getWorkspace(self) -> "std::string":
        return _connect.CTestEnvironmentConfig_getWorkspace(self)

    def getPrimaryCoreId(self) -> "std::string":
        return _connect.CTestEnvironmentConfig_getPrimaryCoreId(self)

    def getCoreIds(self, coreIds: 'StrVector') -> "void":
        return _connect.CTestEnvironmentConfig_getCoreIds(self, coreIds)

    def getCoreIdIndex(self, coreId: 'std::string const &', isThrow: 'bool') -> "int":
        return _connect.CTestEnvironmentConfig_getCoreIdIndex(self, coreId, isThrow)

    def isUseQualifiedFuncNames(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isUseQualifiedFuncNames(self)

    def getAddress(self) -> "std::string":
        return _connect.CTestEnvironmentConfig_getAddress(self)

    def getPort(self) -> "int":
        return _connect.CTestEnvironmentConfig_getPort(self)

    def isAutoConnectToWinIDEA(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isAutoConnectToWinIDEA(self)

    def isAlwaysRunInitSeqBeforeRun(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isAlwaysRunInitSeqBeforeRun(self)

    def isDownloadOnInit(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isDownloadOnInit(self)

    def isResetOnInit(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isResetOnInit(self)

    def isRunOnInit(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isRunOnInit(self)

    def getStopFunction(self) -> "std::string":
        return _connect.CTestEnvironmentConfig_getStopFunction(self)

    def isDeleteAllBPsOnInit(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isDeleteAllBPsOnInit(self)

    def isCheckTargetStateBeforeRun(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isCheckTargetStateBeforeRun(self)

    def isVerifySymbolsBeforeRun(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isVerifySymbolsBeforeRun(self)

    def isDisableInterrupts(self) -> "bool":
        return _connect.CTestEnvironmentConfig_isDisableInterrupts(self)

    def getTestTimeout(self) -> "int":
        return _connect.CTestEnvironmentConfig_getTestTimeout(self)

    def getBreakpointType(self) -> "isys::CTestEnvironmentConfig::EBreakpointsType":
        return _connect.CTestEnvironmentConfig_getBreakpointType(self)

    def getDefaultReturnValueName(self) -> "std::string":
        return _connect.CTestEnvironmentConfig_getDefaultReturnValueName(self)

    def getAutoIdFormatString(self) -> "std::string":
        return _connect.CTestEnvironmentConfig_getAutoIdFormatString(self)

    def getScriptConfig(self, isConst: 'bool') -> "isys::CScriptConfigSPtr":
        return _connect.CTestEnvironmentConfig_getScriptConfig(self, isConst)

    def getToolsConfig(self, isConst: 'bool') -> "isys::CToolsConfigSPtr":
        return _connect.CTestEnvironmentConfig_getToolsConfig(self, isConst)

    def getEvaluatorConfig(self, isConst: 'bool') -> "isys::CEvaluatorConfigSPtr":
        return _connect.CTestEnvironmentConfig_getEvaluatorConfig(self, isConst)

    def getTestCaseTargetInitConfig(self, isConst: 'bool') -> "isys::CTestCaseTargetInitConfigSPtr":
        return _connect.CTestEnvironmentConfig_getTestCaseTargetInitConfig(self, isConst)

    def getStackUsageConfig(self, isConst: 'bool') -> "isys::CStackUsageConfigSPtr":
        return _connect.CTestEnvironmentConfig_getStackUsageConfig(self, isConst)

    def getStackUsageOptions(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestEnvironmentConfig_getStackUsageOptions(self, isConst)

    def getLoggingParameters(self, params: 'StrVector') -> "void":
        return _connect.CTestEnvironmentConfig_getLoggingParameters(self, params)

    def getWarnings(self) -> "std::string":
        return _connect.CTestEnvironmentConfig_getWarnings(self)

    def setVersion(self, version: 'std::string const &') -> "void":
        return _connect.CTestEnvironmentConfig_setVersion(self, version)

    def setWorkspace(self, workspace: 'std::string const &') -> "void":
        return _connect.CTestEnvironmentConfig_setWorkspace(self, workspace)

    def setAddress(self, address: 'std::string const &') -> "void":
        return _connect.CTestEnvironmentConfig_setAddress(self, address)

    def setPort(self, port: 'int') -> "void":
        return _connect.CTestEnvironmentConfig_setPort(self, port)

    def setAutoConnectToWinIDEA(self, autoConnect: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setAutoConnectToWinIDEA(self, autoConnect)

    def setAlwaysRunInitSeqBeforeRun(self, isAlwaysRunInitSeq: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setAlwaysRunInitSeqBeforeRun(self, isAlwaysRunInitSeq)

    def setDownloadOnInit(self, isDownload: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setDownloadOnInit(self, isDownload)

    def setResetOnInit(self, isReset: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setResetOnInit(self, isReset)

    def setRunOnInit(self, isRun: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setRunOnInit(self, isRun)

    def setStopFunction(self, stopFunction: 'std::string const &') -> "void":
        return _connect.CTestEnvironmentConfig_setStopFunction(self, stopFunction)

    def setDeleteAllBPsOnInit(self, isDeleteAllBPs: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setDeleteAllBPsOnInit(self, isDeleteAllBPs)

    def setCheckTargetStateBeforeRun(self, isCheckTargetState: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setCheckTargetStateBeforeRun(self, isCheckTargetState)

    def setVerifySymbolsBeforeRun(self, isVerifySymbols: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setVerifySymbolsBeforeRun(self, isVerifySymbols)

    def setDisableInterrupts(self, isDisableInterrupts: 'isys::ETristate') -> "void":
        return _connect.CTestEnvironmentConfig_setDisableInterrupts(self, isDisableInterrupts)

    def setTestTimeout(self, timeout: 'int') -> "void":
        return _connect.CTestEnvironmentConfig_setTestTimeout(self, timeout)

    def setBreakpointsType(self, breakpointsType: 'isys::CTestEnvironmentConfig::EBreakpointsType') -> "void":
        return _connect.CTestEnvironmentConfig_setBreakpointsType(self, breakpointsType)

    def setDefaultReturnValueName(self, defaultRetValName: 'std::string const &') -> "void":
        return _connect.CTestEnvironmentConfig_setDefaultReturnValueName(self, defaultRetValName)

    def setAutoIdFormatString(self, format: 'std::string const &') -> "void":
        return _connect.CTestEnvironmentConfig_setAutoIdFormatString(self, format)

    def setLoggingParameters(self, params: 'std::string const &') -> "void":
        return _connect.CTestEnvironmentConfig_setLoggingParameters(self, params)

    def getConfiguredCoreID(self, testCaseCoreId: 'std::string const &') -> "std::string":
        return _connect.CTestEnvironmentConfig_getConfiguredCoreID(self, testCaseCoreId)
    __swig_destroy__ = _connect.delete_CTestEnvironmentConfig
    __del__ = lambda self: None
CTestEnvironmentConfig_swigregister = _connect.CTestEnvironmentConfig_swigregister
CTestEnvironmentConfig_swigregister(CTestEnvironmentConfig)

def CTestEnvironmentConfig_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestEnvironmentConfigSPtr":
    return _connect.CTestEnvironmentConfig_cast(testBase)
CTestEnvironmentConfig_cast = _connect.CTestEnvironmentConfig_cast

def CTestEnvironmentConfig_getStaticVersion() -> "std::string":
    return _connect.CTestEnvironmentConfig_getStaticVersion()
CTestEnvironmentConfig_getStaticVersion = _connect.CTestEnvironmentConfig_getStaticVersion

class CTestReportConfig(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestReportConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestReportConfig, name)
    __repr__ = _swig_repr
    DYNAMIC_PREFIX = _connect.CTestReportConfig_DYNAMIC_PREFIX
    RCONFIG_FULL = _connect.CTestReportConfig_RCONFIG_FULL
    RCONFIG_ERRORS_ONLY = _connect.CTestReportConfig_RCONFIG_ERRORS_ONLY
    FMT_XML = _connect.CTestReportConfig_FMT_XML
    FMT_YAML = _connect.CTestReportConfig_FMT_YAML
    FMT_CSV = _connect.CTestReportConfig_FMT_CSV
    FMT_XLS = _connect.CTestReportConfig_FMT_XLS
    FMT_XLSX = _connect.CTestReportConfig_FMT_XLSX
    HTML_VIEW_ALL = _connect.CTestReportConfig_HTML_VIEW_ALL
    HTML_VIEW_ERROS_ONLY = _connect.CTestReportConfig_HTML_VIEW_ERROS_ONLY
    E_SECTION_TEST_IDEA_VERSION = _connect.CTestReportConfig_E_SECTION_TEST_IDEA_VERSION
    E_SECTION_WIN_IDEA_VERSION = _connect.CTestReportConfig_E_SECTION_WIN_IDEA_VERSION
    E_SECTION_REPORT_CONTENTS = _connect.CTestReportConfig_E_SECTION_REPORT_CONTENTS
    E_SECTION_OUTPUT_FORMAT = _connect.CTestReportConfig_E_SECTION_OUTPUT_FORMAT
    E_SECTION_FILE_NAME = _connect.CTestReportConfig_E_SECTION_FILE_NAME
    E_SECTION_IYAML_FILE_NAME = _connect.CTestReportConfig_E_SECTION_IYAML_FILE_NAME
    E_SECTION_XML_XSLT_FOR_FULL_REPORT = _connect.CTestReportConfig_E_SECTION_XML_XSLT_FOR_FULL_REPORT
    E_SECTION_XML_XSLT_FOR_ERRORS = _connect.CTestReportConfig_E_SECTION_XML_XSLT_FOR_ERRORS
    E_SECTION_XML_LOGO_IMAGE = _connect.CTestReportConfig_E_SECTION_XML_LOGO_IMAGE
    E_SECTION_XML_REPORT_HEADER = _connect.CTestReportConfig_E_SECTION_XML_REPORT_HEADER
    E_SECTION_CSS_FILE = _connect.CTestReportConfig_E_SECTION_CSS_FILE
    E_SECTION_IS_EMBED_XML_XSLT_CSS = _connect.CTestReportConfig_E_SECTION_IS_EMBED_XML_XSLT_CSS
    E_SECTION_IS_CREATE_HTML = _connect.CTestReportConfig_E_SECTION_IS_CREATE_HTML
    E_SECTION_CSV_SEPARATOR = _connect.CTestReportConfig_E_SECTION_CSV_SEPARATOR
    E_SECTION_CSV_IS_HEADER_LINE = _connect.CTestReportConfig_E_SECTION_CSV_IS_HEADER_LINE
    E_SECTION_XLS_IS_VERTICAL_HEADER = _connect.CTestReportConfig_E_SECTION_XLS_IS_VERTICAL_HEADER
    E_SECTION_IS_INCLUDE_TEST_SPEC = _connect.CTestReportConfig_E_SECTION_IS_INCLUDE_TEST_SPEC
    E_SECTION_IS_ABS_PATHS_FOR_LINK_TYPO = _connect.CTestReportConfig_E_SECTION_IS_ABS_PATHS_FOR_LINK_TYPO
    E_SECTION_IS_ABS_PATHS_FOR_LINK = _connect.CTestReportConfig_E_SECTION_IS_ABS_PATHS_FOR_LINK
    E_SECTION_HTML_VIEW_MODE = _connect.CTestReportConfig_E_SECTION_HTML_VIEW_MODE
    E_SECTION_TEST_INFO = _connect.CTestReportConfig_E_SECTION_TEST_INFO
    E_SECTION_IS_USE_CUSTOM_TIME = _connect.CTestReportConfig_E_SECTION_IS_USE_CUSTOM_TIME

    def __init__(self, *args):
        this = _connect.new_CTestReportConfig(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestReportConfig_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestReportConfig_cast)
    else:
        cast = _connect.CTestReportConfig_cast

    def getReportContents(self) -> "isys::CTestReportConfig::EReportContents":
        return _connect.CTestReportConfig_getReportContents(self)

    def getTestIDEAVersion(self) -> "std::string":
        return _connect.CTestReportConfig_getTestIDEAVersion(self)

    def getWinIDEAVersion(self) -> "std::string":
        return _connect.CTestReportConfig_getWinIDEAVersion(self)

    def getOutputFormat(self) -> "isys::CTestReportConfig::EOutputFormat":
        return _connect.CTestReportConfig_getOutputFormat(self)

    def getFileName(self) -> "std::string":
        return _connect.CTestReportConfig_getFileName(self)

    def getIYamlFileName(self) -> "std::string":
        return _connect.CTestReportConfig_getIYamlFileName(self)

    def getAbsReportFileName(self) -> "std::string":
        return _connect.CTestReportConfig_getAbsReportFileName(self)

    def getXsltForFullReport(self) -> "std::string":
        return _connect.CTestReportConfig_getXsltForFullReport(self)

    def getXsltForErrors(self) -> "std::string":
        return _connect.CTestReportConfig_getXsltForErrors(self)

    def getCssFile(self) -> "std::string":
        return _connect.CTestReportConfig_getCssFile(self)

    def isEmbedXsltCss(self) -> "bool":
        return _connect.CTestReportConfig_isEmbedXsltCss(self)

    def isCreateHtml(self) -> "bool":
        return _connect.CTestReportConfig_isCreateHtml(self)

    def getSelectedXsltFileName(self) -> "std::string":
        return _connect.CTestReportConfig_getSelectedXsltFileName(self)

    def getCSVSeparator(self) -> "std::string":
        return _connect.CTestReportConfig_getCSVSeparator(self)

    def isCSVHeaderLine(self) -> "bool":
        return _connect.CTestReportConfig_isCSVHeaderLine(self)

    def isXLSVerticalHeader(self) -> "bool":
        return _connect.CTestReportConfig_isXLSVerticalHeader(self)

    def isIncludeTestSpec(self) -> "bool":
        return _connect.CTestReportConfig_isIncludeTestSpec(self)

    def isAbsPathForLinks(self) -> "bool":
        return _connect.CTestReportConfig_isAbsPathForLinks(self)

    def getUserInfo(self, userInfoMap: 'StrStrMap') -> "void":
        return _connect.CTestReportConfig_getUserInfo(self, userInfoMap)

    def hasUserInfo(self, key: 'std::string const &') -> "bool":
        return _connect.CTestReportConfig_hasUserInfo(self, key)

    def getXmlReportHeader(self) -> "std::string":
        return _connect.CTestReportConfig_getXmlReportHeader(self)

    def getWarnings(self) -> "std::string":
        return _connect.CTestReportConfig_getWarnings(self)

    def setReportContents(self, reportContents: 'isys::CTestReportConfig::EReportContents') -> "void":
        return _connect.CTestReportConfig_setReportContents(self, reportContents)

    def setTestIDEAVersion(self, testIDEAVersion: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setTestIDEAVersion(self, testIDEAVersion)

    def setWinIDEAVersion(self, winIDEAVersion: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setWinIDEAVersion(self, winIDEAVersion)

    def setOutputFormat(self, outFormat: 'isys::CTestReportConfig::EOutputFormat') -> "void":
        return _connect.CTestReportConfig_setOutputFormat(self, outFormat)

    def setFileName(self, fileName: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setFileName(self, fileName)

    def setIYamlFileName(self, fileName: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setIYamlFileName(self, fileName)

    def setXsltForFullReport(self, xsltFileName: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setXsltForFullReport(self, xsltFileName)

    def setXsltForErrors(self, xsltFileName: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setXsltForErrors(self, xsltFileName)

    def setCsvSeparator(self, csvSeparator: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setCsvSeparator(self, csvSeparator)

    def setCsvHeaderLine(self, isCsvHeaderLine: 'bool') -> "void":
        return _connect.CTestReportConfig_setCsvHeaderLine(self, isCsvHeaderLine)

    def setXLSVerticalHeader(self, isXLSVerticalHeader: 'bool') -> "void":
        return _connect.CTestReportConfig_setXLSVerticalHeader(self, isXLSVerticalHeader)

    def setIncludeTestSpec(self, isIncTestSpec: 'bool') -> "void":
        return _connect.CTestReportConfig_setIncludeTestSpec(self, isIncTestSpec)

    def setXmlReportHeader(self, header: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setXmlReportHeader(self, header)

    def setUserInfo(self, yamlSpec: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_setUserInfo(self, yamlSpec)

    def clearDynamicUserItems(self) -> "void":
        return _connect.CTestReportConfig_clearDynamicUserItems(self)

    def setAbsPathForLinks(self, iaAbsPathsForLinks: 'bool') -> "void":
        return _connect.CTestReportConfig_setAbsPathForLinks(self, iaAbsPathsForLinks)

    def addUserInfo(self, key: 'std::string const &', value: 'std::string const &') -> "void":
        return _connect.CTestReportConfig_addUserInfo(self, key, value)
    __swig_destroy__ = _connect.delete_CTestReportConfig
    __del__ = lambda self: None
CTestReportConfig_swigregister = _connect.CTestReportConfig_swigregister
CTestReportConfig_swigregister(CTestReportConfig)
BUILT_IN_XSLT_PREFIX = cvar.BUILT_IN_XSLT_PREFIX
DEFAULT_XSLT_NAME = cvar.DEFAULT_XSLT_NAME
DEFAULT_CSS_NAME = cvar.DEFAULT_CSS_NAME
CVRG_TO_COBERTURA_XSLT_FNAME = cvar.CVRG_TO_COBERTURA_XSLT_FNAME

def CTestReportConfig_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestReportConfigSPtr":
    return _connect.CTestReportConfig_cast(testBase)
CTestReportConfig_cast = _connect.CTestReportConfig_cast

class CTestReportContainer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestReportContainer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTestReportContainer, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CTestReportContainer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def assign(self, src: 'isys::CTestReportContainerSPtr const &') -> "void":
        return _connect.CTestReportContainer_assign(self, src)

    def clearResults(self) -> "void":
        return _connect.CTestReportContainer_clearResults(self)

    def putTestResult(self, testSpec: 'isys::CTestTreeNodeSPtr const &', result: 'isys::CTestResultBaseSPtr const &') -> "void":
        return _connect.CTestReportContainer_putTestResult(self, testSpec, result)

    def getNoOfTestResults(self) -> "int":
        return _connect.CTestReportContainer_getNoOfTestResults(self)

    def resetTestResultIterator(self) -> "void":
        return _connect.CTestReportContainer_resetTestResultIterator(self)

    def hasNextTestResult(self) -> "bool":
        return _connect.CTestReportContainer_hasNextTestResult(self)

    def nextTestResult(self) -> "isys::CTestResultSPtr":
        return _connect.CTestReportContainer_nextTestResult(self)

    def getTestResult(self, testSpec: 'isys::CTestTreeNodeSPtr const &') -> "isys::CTestResultSPtr":
        return _connect.CTestReportContainer_getTestResult(self, testSpec)

    def getNoOfTestGroupResults(self) -> "int":
        return _connect.CTestReportContainer_getNoOfTestGroupResults(self)

    def resetGroupResultIterator(self) -> "void":
        return _connect.CTestReportContainer_resetGroupResultIterator(self)

    def hasNextGroupResult(self) -> "bool":
        return _connect.CTestReportContainer_hasNextGroupResult(self)

    def nextGroupResult(self) -> "isys::CTestGroupResultSPtr":
        return _connect.CTestReportContainer_nextGroupResult(self)

    def getGroupResult(self, testGroup: 'isys::CTestTreeNodeSPtr const &') -> "isys::CTestGroupResultSPtr":
        return _connect.CTestReportContainer_getGroupResult(self, testGroup)

    def createGroupResults(self, mcmgr: 'isys::CMulticoreConnectionMgrSPtr const &', filterCtrl: 'isys::CTestFilterControllerSPtr const &', hostVars: 'isys::CTestHostVarsSPtr const &', group: 'isys::CTestGroupSPtr const &') -> "void":
        return _connect.CTestReportContainer_createGroupResults(self, mcmgr, filterCtrl, hostVars, group)

    def toString(self) -> "std::string":
        return _connect.CTestReportContainer_toString(self)
    __swig_destroy__ = _connect.delete_CTestReportContainer
    __del__ = lambda self: None
CTestReportContainer_swigregister = _connect.CTestReportContainer_swigregister
CTestReportContainer_swigregister(CTestReportContainer)

class CTestReportStatistic(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestReportStatistic, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTestReportStatistic, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CTestReportStatistic()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def analyzeResult(self, testResult: 'isys::CTestResultSPtr const &') -> "void":
        return _connect.CTestReportStatistic_analyzeResult(self, testResult)

    def getErrors(self) -> "int32_t":
        return _connect.CTestReportStatistic_getErrors(self)

    def getFailures(self) -> "int32_t":
        return _connect.CTestReportStatistic_getFailures(self)

    def serialize(self, emitter: 'isys::IEmitterSPtr const &') -> "void":
        return _connect.CTestReportStatistic_serialize(self, emitter)
    __swig_destroy__ = _connect.delete_CTestReportStatistic
    __del__ = lambda self: None
CTestReportStatistic_swigregister = _connect.CTestReportStatistic_swigregister
CTestReportStatistic_swigregister(CTestReportStatistic)

class CTestFunction(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestFunction, name)
    __repr__ = _swig_repr
    E_SECTION_FUNC_NAME = _connect.CTestFunction_E_SECTION_FUNC_NAME
    E_SECTION_PARAMS = _connect.CTestFunction_E_SECTION_PARAMS
    E_SECTION_RET_VAL_NAME = _connect.CTestFunction_E_SECTION_RET_VAL_NAME

    def __init__(self, *args):
        this = _connect.new_CTestFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestFunction_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestFunction_cast)
    else:
        cast = _connect.CTestFunction_cast

    def assign(self, src: 'isys::CTestObjectSPtr const &') -> "void":
        return _connect.CTestFunction_assign(self, src)

    def assignYAMLStyle(self, testFunc: 'isys::CTestFunctionSPtr &') -> "void":
        return _connect.CTestFunction_assignYAMLStyle(self, testFunc)

    def getName(self) -> "std::string":
        return _connect.CTestFunction_getName(self)

    def hasPositionParams(self) -> "bool":
        return _connect.CTestFunction_hasPositionParams(self)

    def getPositionParams(self, positionParams: 'StrVector') -> "void":
        return _connect.CTestFunction_getPositionParams(self, positionParams)

    def getRetValueName(self) -> "std::string":
        return _connect.CTestFunction_getRetValueName(self)

    def isSerializedAsList(self, isParsing: 'bool') -> "bool":
        return _connect.CTestFunction_isSerializedAsList(self, isParsing)

    def setName(self, functionName: 'std::string const &') -> "void":
        return _connect.CTestFunction_setName(self, functionName)

    def setPositionParameters(self, parameters: 'StrVector') -> "void":
        return _connect.CTestFunction_setPositionParameters(self, parameters)

    def setRetValueName(self, retValName: 'std::string const &') -> "void":
        return _connect.CTestFunction_setRetValueName(self, retValName)
    __swig_destroy__ = _connect.delete_CTestFunction
    __del__ = lambda self: None
CTestFunction_swigregister = _connect.CTestFunction_swigregister
CTestFunction_swigregister(CTestFunction)

def CTestFunction_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestFunctionSPtr":
    return _connect.CTestFunction_cast(testBase)
CTestFunction_cast = _connect.CTestFunction_cast

class CTestAssert(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestAssert, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestAssert, name)
    __repr__ = _swig_repr
    E_SECTION_ASSERT_IS_EXPECT_EXCEPTION = _connect.CTestAssert_E_SECTION_ASSERT_IS_EXPECT_EXCEPTION
    E_SECTION_ASSERT_EXPRESSIONS = _connect.CTestAssert_E_SECTION_ASSERT_EXPRESSIONS

    def __init__(self, *args):
        this = _connect.new_CTestAssert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestAssert
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestAssert_createInstance(self, parent)

    def isMerged(self) -> "bool":
        return _connect.CTestAssert_isMerged(self)
    if _newclass:
        cast = staticmethod(_connect.CTestAssert_cast)
    else:
        cast = _connect.CTestAssert_cast

    def isExpectException(self) -> "isys::ETristate":
        return _connect.CTestAssert_isExpectException(self)

    def setExpectException(self, isExpectException: 'isys::ETristate') -> "void":
        return _connect.CTestAssert_setExpectException(self, isExpectException)

    def getExpressions(self, expressions: 'StrVector') -> "void":
        return _connect.CTestAssert_getExpressions(self, expressions)

    def setExpressions(self, expressions: 'StrVector') -> "void":
        return _connect.CTestAssert_setExpressions(self, expressions)
CTestAssert_swigregister = _connect.CTestAssert_swigregister
CTestAssert_swigregister(CTestAssert)

def CTestAssert_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestAssertSPtr":
    return _connect.CTestAssert_cast(testBase)
CTestAssert_cast = _connect.CTestAssert_cast

class CTestCase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestCase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTestCase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CTestCase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestCase
    __del__ = lambda self: None

    def getTestResults(self, *args) -> "isys::CTestResultSPtr":
        return _connect.CTestCase_getTestResults(self, *args)

    def itestCpp(self, *args) -> "void":
        return _connect.CTestCase_itestCpp(self, *args)

    def runTest(self, *args) -> "void":
        return _connect.CTestCase_runTest(self, *args)
    if _newclass:
        getISystemRetValName = staticmethod(_connect.CTestCase_getISystemRetValName)
    else:
        getISystemRetValName = _connect.CTestCase_getISystemRetValName

    def runTest_init_target(self, testSpec: 'isys::CTestSpecificationSPtr &', isDebug: 'bool', isTestBatchOn: 'bool') -> "bool":
        return _connect.CTestCase_runTest_init_target(self, testSpec, isDebug, isTestBatchOn)

    def runTest_init_test(self, isInitAnalyzers: 'bool', isMeasureStackUsage: 'bool', testTimeout: 'int') -> "void":
        return _connect.CTestCase_runTest_init_test(self, isInitAnalyzers, isMeasureStackUsage, testTimeout)

    def runTest_exec_begin(self) -> "void":
        return _connect.CTestCase_runTest_exec_begin(self)

    def runTest_exec_loopStart(self, testSpec: 'isys::CTestSpecificationSPtr &', isResumeCoverage: 'bool', isStubOrTestPoint: 'bool') -> "void":
        return _connect.CTestCase_runTest_exec_loopStart(self, testSpec, isResumeCoverage, isStubOrTestPoint)

    def runTest_exec_waitForStop(self, testSpec: 'isys::CTestSpecificationSPtr &', unitTestTimeout: 'int') -> "bool":
        return _connect.CTestCase_runTest_exec_waitForStop(self, testSpec, unitTestTimeout)

    def runTest_exec_langSpecific(self) -> "bool":
        return _connect.CTestCase_runTest_exec_langSpecific(self)

    def setTargetException(self, isTargetException: 'bool') -> "void":
        return _connect.CTestCase_setTargetException(self, isTargetException)

    def runTest_exec_end(self) -> "void":
        return _connect.CTestCase_runTest_exec_end(self)

    def runTest_finalize(self, differences: 'StrVector', isDryRun: 'bool', analyzerFilesToMerge: 'StrVector') -> "void":
        return _connect.CTestCase_runTest_finalize(self, differences, isDryRun, analyzerFilesToMerge)

    def handleException(self) -> "void":
        return _connect.CTestCase_handleException(self)

    def clearTest(self) -> "void":
        return _connect.CTestCase_clearTest(self)

    def stopTest(self) -> "void":
        return _connect.CTestCase_stopTest(self)

    def setStopConditionForSysTest(self, testSpec: 'isys::CTestSpecificationSPtr const &') -> "void":
        return _connect.CTestCase_setStopConditionForSysTest(self, testSpec)

    def isSystemTestStopOnBP(self) -> "bool":
        return _connect.CTestCase_isSystemTestStopOnBP(self)

    def setStopConditionBP(self, stopCondition: 'isys::CTestStopConditionSPtr &', testPointOrTestCaseId: 'std::string const &') -> "void":
        return _connect.CTestCase_setStopConditionBP(self, stopCondition, testPointOrTestCaseId)

    def deleteStopConditionBP(self, stopCondition: 'isys::CTestStopConditionSPtr &', testPointOrTestCaseId: 'std::string const &') -> "void":
        return _connect.CTestCase_deleteStopConditionBP(self, stopCondition, testPointOrTestCaseId)

    def checkStopConditionStop(self, stopCondition: 'isys::CTestStopConditionSPtr &') -> "void":
        return _connect.CTestCase_checkStopConditionStop(self, stopCondition)

    def checkStopConditionExpr(self, stopCondition: 'isys::CTestStopConditionSPtr &') -> "void":
        return _connect.CTestCase_checkStopConditionExpr(self, stopCondition)

    def getTestController(self) -> "isys::ITestCaseControllerSPtr":
        return _connect.CTestCase_getTestController(self)

    def getDebugFacade(self) -> "isys::CDebugFacadeSPtr":
        return _connect.CTestCase_getDebugFacade(self)

    def getHostVars(self) -> "isys::CTestHostVarsSPtr":
        return _connect.CTestCase_getHostVars(self)

    def callStubs(self, isRunNativeCustomFunc: 'bool', scriptParams: 'StrVector', tpResult: 'isys::CTestPointResultSPtr') -> "isys::CTestStubSPtr":
        return _connect.CTestCase_callStubs(self, isRunNativeCustomFunc, scriptParams, tpResult)

    def execTestPointEvalAssign(self, testCaseCtrl: 'isys::ITestCaseControllerSPtr', scriptParams: 'StrVector', tpResult: 'isys::CTestPointResultSPtr &') -> "isys::CTestPointSPtr":
        return _connect.CTestCase_execTestPointEvalAssign(self, testCaseCtrl, scriptParams, tpResult)

    def waitForAnalyzerToDownloadData(self, timeout: 'int'=0) -> "void":
        return _connect.CTestCase_waitForAnalyzerToDownloadData(self, timeout)

    def logStatus(self, testCaseCtrl: 'isys::ITestCaseControllerSPtr', logConfig: 'isys::CTestLogSPtr &', section: 'int', logResult: 'isys::CLogResultSPtr &') -> "void":
        return _connect.CTestCase_logStatus(self, testCaseCtrl, logConfig, section, logResult)

    def replaceHostVariables(self, expression: 'std::string const &') -> "std::string":
        return _connect.CTestCase_replaceHostVariables(self, expression)

    def runUntilStopPoint(self, stopCondition: 'isys::CTestStopConditionSPtr const &', testPointOrTestCaseId: 'std::string const &') -> "void":
        return _connect.CTestCase_runUntilStopPoint(self, stopCondition, testPointOrTestCaseId)
    if _newclass:
        applyDryRun = staticmethod(_connect.CTestCase_applyDryRun)
    else:
        applyDryRun = _connect.CTestCase_applyDryRun

    def setEnableStub(self, testSpec: 'isys::CTestSpecificationSPtr &', stubbedFunction: 'std::string const &', isEnabled: 'bool') -> "void":
        return _connect.CTestCase_setEnableStub(self, testSpec, stubbedFunction, isEnabled)

    def setEnableTestPoint(self, testSpec: 'isys::CTestSpecificationSPtr &', tpId: 'std::string const &', isEnabled: 'bool') -> "void":
        return _connect.CTestCase_setEnableTestPoint(self, testSpec, tpId, isEnabled)
CTestCase_swigregister = _connect.CTestCase_swigregister
CTestCase_swigregister(CTestCase)

def CTestCase_getISystemRetValName() -> "std::string":
    return _connect.CTestCase_getISystemRetValName()
CTestCase_getISystemRetValName = _connect.CTestCase_getISystemRetValName

def CTestCase_applyDryRun(testSpec: 'isys::CTestSpecificationSPtr &', mergedTestSpec: 'isys::CTestSpecificationSPtr &', result: 'isys::CTestResultSPtr &') -> "bool":
    return _connect.CTestCase_applyDryRun(testSpec, mergedTestSpec, result)
CTestCase_applyDryRun = _connect.CTestCase_applyDryRun

class CTestAnalyzer(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestAnalyzer, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestAnalyzer, name)
    __repr__ = _swig_repr
    M_OFF = _connect.CTestAnalyzer_M_OFF
    M_START = _connect.CTestAnalyzer_M_START
    EUpdate = _connect.CTestAnalyzer_EUpdate
    EWrite = _connect.CTestAnalyzer_EWrite
    EAppend = _connect.CTestAnalyzer_EAppend
    E_SECTION_RUN_MODE = _connect.CTestAnalyzer_E_SECTION_RUN_MODE
    E_SECTION_DOC_FILE_NAME = _connect.CTestAnalyzer_E_SECTION_DOC_FILE_NAME
    E_SECTION_OPEN_MODE = _connect.CTestAnalyzer_E_SECTION_OPEN_MODE
    E_SECTION_IS_SLOW_RUN = _connect.CTestAnalyzer_E_SECTION_IS_SLOW_RUN
    E_SECTION_TRIGGER = _connect.CTestAnalyzer_E_SECTION_TRIGGER
    E_SECTION_IS_PREDEF_TRIGGER = _connect.CTestAnalyzer_E_SECTION_IS_PREDEF_TRIGGER
    E_SECTION_IS_SAVE_AFTER_TEST = _connect.CTestAnalyzer_E_SECTION_IS_SAVE_AFTER_TEST
    E_SECTION_IS_CLOSE_AFTER_TEST = _connect.CTestAnalyzer_E_SECTION_IS_CLOSE_AFTER_TEST
    E_SECTION_TRACE = _connect.CTestAnalyzer_E_SECTION_TRACE
    E_SECTION_COVERAGE = _connect.CTestAnalyzer_E_SECTION_COVERAGE
    E_SECTION_PROFILER = _connect.CTestAnalyzer_E_SECTION_PROFILER

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CTestAnalyzer(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestAnalyzer_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestAnalyzer_cast)
    else:
        cast = _connect.CTestAnalyzer_cast

    def getRunMode(self) -> "isys::CTestAnalyzer::ERunMode":
        return _connect.CTestAnalyzer_getRunMode(self)

    def isPredefinedTrigger(self) -> "isys::ETristate":
        return _connect.CTestAnalyzer_isPredefinedTrigger(self)

    def isSlowRun(self) -> "isys::ETristate":
        return _connect.CTestAnalyzer_isSlowRun(self)

    def getDocumentFileName(self) -> "std::string":
        return _connect.CTestAnalyzer_getDocumentFileName(self)

    def isMerged(self) -> "bool":
        return _connect.CTestAnalyzer_isMerged(self)

    def getOpenMode(self) -> "isys::CTestAnalyzer::EOpenMode":
        return _connect.CTestAnalyzer_getOpenMode(self)

    def getTriggerName(self) -> "std::string":
        return _connect.CTestAnalyzer_getTriggerName(self)

    def isSaveAfterTest(self) -> "isys::ETristate":
        return _connect.CTestAnalyzer_isSaveAfterTest(self)

    def isCloseAfterTest(self) -> "isys::ETristate":
        return _connect.CTestAnalyzer_isCloseAfterTest(self)

    def getTrace(self, isConst: 'bool') -> "isys::CTestAnalyzerTraceSPtr":
        return _connect.CTestAnalyzer_getTrace(self, isConst)

    def getCoverage(self, isConst: 'bool') -> "isys::CTestAnalyzerCoverageSPtr":
        return _connect.CTestAnalyzer_getCoverage(self, isConst)

    def getProfiler(self, isConst: 'bool') -> "isys::CTestAnalyzerProfilerSPtr":
        return _connect.CTestAnalyzer_getProfiler(self, isConst)

    def setPredefinedTrigger(self, isPredefinedTrigger: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzer_setPredefinedTrigger(self, isPredefinedTrigger)

    def setRunMode(self, mode: 'isys::CTestAnalyzer::ERunMode') -> "void":
        return _connect.CTestAnalyzer_setRunMode(self, mode)

    def setSlowRun(self, isSlowRun: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzer_setSlowRun(self, isSlowRun)

    def setDocumentFileName(self, docFileName: 'std::string const &') -> "void":
        return _connect.CTestAnalyzer_setDocumentFileName(self, docFileName)

    def setOpenMode(self, openMode: 'isys::CTestAnalyzer::EOpenMode') -> "void":
        return _connect.CTestAnalyzer_setOpenMode(self, openMode)

    def setTriggerName(self, triggerName: 'std::string const &') -> "void":
        return _connect.CTestAnalyzer_setTriggerName(self, triggerName)

    def setSaveAfterTest(self, isSave: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzer_setSaveAfterTest(self, isSave)

    def setCloseAfterTest(self, isClose: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzer_setCloseAfterTest(self, isClose)
    __swig_destroy__ = _connect.delete_CTestAnalyzer
    __del__ = lambda self: None
CTestAnalyzer_swigregister = _connect.CTestAnalyzer_swigregister
CTestAnalyzer_swigregister(CTestAnalyzer)

def CTestAnalyzer_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestAnalyzerSPtr":
    return _connect.CTestAnalyzer_cast(testBase)
CTestAnalyzer_cast = _connect.CTestAnalyzer_cast

class CTestAnalyzerTrace(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestAnalyzerTrace, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestAnalyzerTrace, name)
    __repr__ = _swig_repr
    EX_TrcAsText = _connect.CTestAnalyzerTrace_EX_TrcAsText
    EX_TrcAsCSV = _connect.CTestAnalyzerTrace_EX_TrcAsCSV
    EX_TrcAsBinary = _connect.CTestAnalyzerTrace_EX_TrcAsBinary
    EX_TrcAsXML = _connect.CTestAnalyzerTrace_EX_TrcAsXML
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerTrace_E_SECTION_IS_ACTIVE
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerTrace_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerTrace_E_SECTION_EXPORT_FILE

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CTestAnalyzerTrace(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestAnalyzerTrace_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestAnalyzerTrace_cast)
    else:
        cast = _connect.CTestAnalyzerTrace_cast

    def isMerged(self) -> "bool":
        return _connect.CTestAnalyzerTrace_isMerged(self)

    def isActive(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerTrace_isActive(self)

    def getExportFormat(self) -> "isys::CTestAnalyzerTrace::ETraceExportFormat":
        return _connect.CTestAnalyzerTrace_getExportFormat(self)

    def getExportFileName(self) -> "std::string":
        return _connect.CTestAnalyzerTrace_getExportFileName(self)

    def setActive(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerTrace_setActive(self, isActive)

    def setExportFormat(self, exportFormat: 'isys::CTestAnalyzerTrace::ETraceExportFormat') -> "void":
        return _connect.CTestAnalyzerTrace_setExportFormat(self, exportFormat)

    def setExportFileName(self, exportFileName: 'std::string const &') -> "void":
        return _connect.CTestAnalyzerTrace_setExportFileName(self, exportFileName)
    __swig_destroy__ = _connect.delete_CTestAnalyzerTrace
    __del__ = lambda self: None
CTestAnalyzerTrace_swigregister = _connect.CTestAnalyzerTrace_swigregister
CTestAnalyzerTrace_swigregister(CTestAnalyzerTrace)

def CTestAnalyzerTrace_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestAnalyzerTraceSPtr":
    return _connect.CTestAnalyzerTrace_cast(testBase)
CTestAnalyzerTrace_cast = _connect.CTestAnalyzerTrace_cast

class CTestAnalyzerCoverage(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestAnalyzerCoverage, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestAnalyzerCoverage, name)
    __repr__ = _swig_repr
    EX_CCAsHTML = _connect.CTestAnalyzerCoverage_EX_CCAsHTML
    EX_CCAsText = _connect.CTestAnalyzerCoverage_EX_CCAsText
    EX_CCAsCSV = _connect.CTestAnalyzerCoverage_EX_CCAsCSV
    EX_CCAsXML = _connect.CTestAnalyzerCoverage_EX_CCAsXML
    EX_CCAsReviewHTML = _connect.CTestAnalyzerCoverage_EX_CCAsReviewHTML
    EX_CCAsReviewText = _connect.CTestAnalyzerCoverage_EX_CCAsReviewText
    ENone = _connect.CTestAnalyzerCoverage_ENone
    ESiblingsOnly = _connect.CTestAnalyzerCoverage_ESiblingsOnly
    ESiblingsAndParent = _connect.CTestAnalyzerCoverage_ESiblingsAndParent
    EAll = _connect.CTestAnalyzerCoverage_EAll
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerCoverage_E_SECTION_IS_ACTIVE
    E_SECTION_IS_MEASURE_ALL_FUNCTIONS = _connect.CTestAnalyzerCoverage_E_SECTION_IS_MEASURE_ALL_FUNCTIONS
    E_SECTION_IS_IGNORE_UNREACHABLE_CODE = _connect.CTestAnalyzerCoverage_E_SECTION_IS_IGNORE_UNREACHABLE_CODE
    E_SECTION_MERGE_SCOPE = _connect.CTestAnalyzerCoverage_E_SECTION_MERGE_SCOPE
    E_SECTION_MERGE_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_MERGE_FILTER
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXFMT_VARIANT = _connect.CTestAnalyzerCoverage_E_SECTION_EXFMT_VARIANT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FILE
    E_SECTION_IS_ASSEMBLER_INFO = _connect.CTestAnalyzerCoverage_E_SECTION_IS_ASSEMBLER_INFO
    E_SECTION_IS_LAUNCH_VIEWER = _connect.CTestAnalyzerCoverage_E_SECTION_IS_LAUNCH_VIEWER
    E_SECTION_IS_EXPORT_MODULE_LINES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_MODULE_LINES
    E_SECTION_IS_EXPORT_SOURCES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_SOURCES
    E_SECTION_IS_EXPORT_FUNCTION_LINES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_FUNCTION_LINES
    E_SECTION_IS_EXPORT_ASM = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_ASM
    E_SECTION_IS_EXPORT_RANGES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_RANGES
    E_SECTION_EXPORT_FUNCTIONS_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FUNCTIONS_FILTER
    E_SECTION_EXPORT_MODULES_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_MODULES_FILTER
    E_SECTION_STATISTICS = _connect.CTestAnalyzerCoverage_E_SECTION_STATISTICS

    def __init__(self, *args):
        this = _connect.new_CTestAnalyzerCoverage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestAnalyzerCoverage_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestAnalyzerCoverage_cast)
    else:
        cast = _connect.CTestAnalyzerCoverage_cast

    def isMerged(self) -> "bool":
        return _connect.CTestAnalyzerCoverage_isMerged(self)

    def assignStatistics(self, src: 'isys::CTestAnalyzerCoverageSPtr const &') -> "void":
        return _connect.CTestAnalyzerCoverage_assignStatistics(self, src)

    def isActive(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isActive(self)

    def isMeasureAllFunctions(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isMeasureAllFunctions(self)

    def isIgnoreNonReachableCode(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isIgnoreNonReachableCode(self)

    def getMergeScope(self) -> "isys::CTestAnalyzerCoverage::EMergeScope":
        return _connect.CTestAnalyzerCoverage_getMergeScope(self)

    def getMergeFilter(self, isConst: 'bool') -> "isys::CTestFilterSPtr":
        return _connect.CTestAnalyzerCoverage_getMergeFilter(self, isConst)

    def getExportFormat(self) -> "isys::CTestAnalyzerCoverage::ECoverageExportFormat":
        return _connect.CTestAnalyzerCoverage_getExportFormat(self)

    def getExportFormatVariant(self) -> "std::string":
        return _connect.CTestAnalyzerCoverage_getExportFormatVariant(self)

    def getExportFileName(self) -> "std::string":
        return _connect.CTestAnalyzerCoverage_getExportFileName(self)

    def isProvideAssemblerInfo(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isProvideAssemblerInfo(self)

    def isLaunchViewer(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isLaunchViewer(self)

    def isExportModuleLines(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isExportModuleLines(self)

    def isExportSources(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isExportSources(self)

    def isExportFunctionLines(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isExportFunctionLines(self)

    def isExportAsm(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isExportAsm(self)

    def isExportRanges(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerCoverage_isExportRanges(self)

    def getExportFunctionsFilter(self) -> "std::string":
        return _connect.CTestAnalyzerCoverage_getExportFunctionsFilter(self)

    def getExportModulesFilter(self) -> "std::string":
        return _connect.CTestAnalyzerCoverage_getExportModulesFilter(self)

    def getStatisticsList(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestAnalyzerCoverage_getStatisticsList(self, isConst)

    def findStatistic(self, functionName: 'std::string const &') -> "int":
        return _connect.CTestAnalyzerCoverage_findStatistic(self, functionName)

    def getStatistics(self, idx: 'int') -> "isys::CTestCoverageStatisticsSPtr":
        return _connect.CTestAnalyzerCoverage_getStatistics(self, idx)

    def swapStatistics(self, idx1: 'int', idx2: 'int') -> "void":
        return _connect.CTestAnalyzerCoverage_swapStatistics(self, idx1, idx2)

    def setActive(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setActive(self, isActive)

    def setMeasureAllFunctions(self, isMeasureAllFunctions: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setMeasureAllFunctions(self, isMeasureAllFunctions)

    def setExportFormat(self, format: 'isys::CTestAnalyzerCoverage::ECoverageExportFormat') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportFormat(self, format)

    def setExportFormatVariant(self, variant: 'std::string const &') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportFormatVariant(self, variant)

    def setExportFileName(self, file: 'std::string const &') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportFileName(self, file)

    def setAssemblyInfo(self, isAssemblyInfo: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setAssemblyInfo(self, isAssemblyInfo)

    def setLaunchViewer(self, isLaunchViewer: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setLaunchViewer(self, isLaunchViewer)

    def setExportModuleLines(self, isExportModuleLines: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportModuleLines(self, isExportModuleLines)

    def setExportSources(self, isExportSources: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportSources(self, isExportSources)

    def setExportFunctionLines(self, isExportFunctionLines: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportFunctionLines(self, isExportFunctionLines)

    def setExportAsm(self, isExportAsm: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportAsm(self, isExportAsm)

    def setExportRanges(self, isExportRanges: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportRanges(self, isExportRanges)

    def setExportFunctionsFilter(self, filter: 'std::string const &') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportFunctionsFilter(self, filter)

    def setExportModulesFilter(self, filter: 'std::string const &') -> "void":
        return _connect.CTestAnalyzerCoverage_setExportModulesFilter(self, filter)
    __swig_destroy__ = _connect.delete_CTestAnalyzerCoverage
    __del__ = lambda self: None
CTestAnalyzerCoverage_swigregister = _connect.CTestAnalyzerCoverage_swigregister
CTestAnalyzerCoverage_swigregister(CTestAnalyzerCoverage)

def CTestAnalyzerCoverage_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestAnalyzerCoverageSPtr":
    return _connect.CTestAnalyzerCoverage_cast(testBase)
CTestAnalyzerCoverage_cast = _connect.CTestAnalyzerCoverage_cast

class CTestAnalyzerProfiler(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestAnalyzerProfiler, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestAnalyzerProfiler, name)
    __repr__ = _swig_repr
    DATA_AREA = _connect.CTestAnalyzerProfiler_DATA_AREA
    CODE_AREA = _connect.CTestAnalyzerProfiler_CODE_AREA
    EProfilerAsText = _connect.CTestAnalyzerProfiler_EProfilerAsText
    EProfilerAsXML = _connect.CTestAnalyzerProfiler_EProfilerAsXML
    EProfilerAsCSV = _connect.CTestAnalyzerProfiler_EProfilerAsCSV
    EProfilerAsText1 = _connect.CTestAnalyzerProfiler_EProfilerAsText1
    EProfilerAsXMLBinaryTimeline = _connect.CTestAnalyzerProfiler_EProfilerAsXMLBinaryTimeline
    EProfilerAsBTF = _connect.CTestAnalyzerProfiler_EProfilerAsBTF
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerProfiler_E_SECTION_IS_ACTIVE
    E_SECTION_IS_MEASURE_ALL_FUNCTIONS = _connect.CTestAnalyzerProfiler_E_SECTION_IS_MEASURE_ALL_FUNCTIONS
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerProfiler_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerProfiler_E_SECTION_EXPORT_FILE
    E_SECTION_IS_EXPORT_ACTIVE_AREAS_ONLY = _connect.CTestAnalyzerProfiler_E_SECTION_IS_EXPORT_ACTIVE_AREAS_ONLY
    E_SECTION_IS_PROFILE_AUX = _connect.CTestAnalyzerProfiler_E_SECTION_IS_PROFILE_AUX
    E_SECTION_IS_SAVE_HISTORY = _connect.CTestAnalyzerProfiler_E_SECTION_IS_SAVE_HISTORY
    E_SECTION_CODE_AREAS = _connect.CTestAnalyzerProfiler_E_SECTION_CODE_AREAS
    E_SECTION_DATA_AREAS = _connect.CTestAnalyzerProfiler_E_SECTION_DATA_AREAS

    def __init__(self, *args):
        this = _connect.new_CTestAnalyzerProfiler(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestAnalyzerProfiler_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestAnalyzerProfiler_cast)
    else:
        cast = _connect.CTestAnalyzerProfiler_cast

    def assignCodeAreas(self, src: 'isys::CTestAnalyzerProfilerSPtr &') -> "void":
        return _connect.CTestAnalyzerProfiler_assignCodeAreas(self, src)

    def assignDataAreas(self, src: 'isys::CTestAnalyzerProfilerSPtr &') -> "void":
        return _connect.CTestAnalyzerProfiler_assignDataAreas(self, src)

    def isActive(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerProfiler_isActive(self)

    def isMeasureAllFunctions(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerProfiler_isMeasureAllFunctions(self)

    def isMerged(self) -> "bool":
        return _connect.CTestAnalyzerProfiler_isMerged(self)

    def getExportFormat(self) -> "isys::CTestAnalyzerProfiler::EProfilerExportFormat":
        return _connect.CTestAnalyzerProfiler_getExportFormat(self)

    def getExportFileName(self) -> "std::string":
        return _connect.CTestAnalyzerProfiler_getExportFileName(self)

    def isExportActiveAreasOnly(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerProfiler_isExportActiveAreasOnly(self)

    def isProfileAUX(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerProfiler_isProfileAUX(self)

    def isSaveHistory(self) -> "isys::ETristate":
        return _connect.CTestAnalyzerProfiler_isSaveHistory(self)

    def getAreas(self, areaType: 'isys::CTestAnalyzerProfiler::EAreaType', isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestAnalyzerProfiler_getAreas(self, areaType, isConst)

    def getCodeAreas(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestAnalyzerProfiler_getCodeAreas(self, isConst)

    def getDataAreas(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestAnalyzerProfiler_getDataAreas(self, isConst)

    def findArea(self, *args) -> "int":
        return _connect.CTestAnalyzerProfiler_findArea(self, *args)

    def getArea(self, areaType: 'isys::CTestAnalyzerProfiler::EAreaType', idx: 'int') -> "isys::CTestProfilerStatisticsSPtr":
        return _connect.CTestAnalyzerProfiler_getArea(self, areaType, idx)

    def swapAreas(self, areaType: 'isys::CTestAnalyzerProfiler::EAreaType', idx1: 'int', idx2: 'int') -> "void":
        return _connect.CTestAnalyzerProfiler_swapAreas(self, areaType, idx1, idx2)

    def setActive(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerProfiler_setActive(self, isActive)

    def setMeasureAllFunctions(self, isMeasureAllFunctions: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerProfiler_setMeasureAllFunctions(self, isMeasureAllFunctions)

    def setExportFormat(self, exportFormat: 'isys::CTestAnalyzerProfiler::EProfilerExportFormat') -> "void":
        return _connect.CTestAnalyzerProfiler_setExportFormat(self, exportFormat)

    def setExportFileName(self, file: 'std::string const &') -> "void":
        return _connect.CTestAnalyzerProfiler_setExportFileName(self, file)

    def setExportActiveAreasOnly(self, isExportActiveAreasOnly: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerProfiler_setExportActiveAreasOnly(self, isExportActiveAreasOnly)

    def setProfileAUX(self, isProfileAUX: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerProfiler_setProfileAUX(self, isProfileAUX)

    def setSaveHistory(self, isSave: 'isys::ETristate') -> "void":
        return _connect.CTestAnalyzerProfiler_setSaveHistory(self, isSave)

    def setCodeAreas(self, arg2: 'isys::CTestBaseListSPtr &') -> "void":
        return _connect.CTestAnalyzerProfiler_setCodeAreas(self, arg2)

    def setDataAreas(self, arg2: 'isys::CTestBaseListSPtr &') -> "void":
        return _connect.CTestAnalyzerProfiler_setDataAreas(self, arg2)
    __swig_destroy__ = _connect.delete_CTestAnalyzerProfiler
    __del__ = lambda self: None
CTestAnalyzerProfiler_swigregister = _connect.CTestAnalyzerProfiler_swigregister
CTestAnalyzerProfiler_swigregister(CTestAnalyzerProfiler)

def CTestAnalyzerProfiler_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestAnalyzerProfilerSPtr":
    return _connect.CTestAnalyzerProfiler_cast(testBase)
CTestAnalyzerProfiler_cast = _connect.CTestAnalyzerProfiler_cast

class CTestCoverageStatistics(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestCoverageStatistics, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestCoverageStatistics, name)
    __repr__ = _swig_repr
    E_SECTION_FUNC_NAME = _connect.CTestCoverageStatistics_E_SECTION_FUNC_NAME
    E_SECTION_BYTES_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_BYTES_EXECUTED
    E_SECTION_SOURCE_LINES_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_SOURCE_LINES_EXECUTED
    E_SECTION_BRANCH_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_EXECUTED
    E_SECTION_BRANCH_TAKEN = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_TAKEN
    E_SECTION_BRANCH_NOT_TAKEN = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_NOT_TAKEN
    E_SECTION_BRANCH_BOTH = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_BOTH
    E_SECTION_EXECUTION_COUNT = _connect.CTestCoverageStatistics_E_SECTION_EXECUTION_COUNT
    E_SECTION_MC_DC = _connect.CTestCoverageStatistics_E_SECTION_MC_DC

    def __init__(self, *args):
        this = _connect.new_CTestCoverageStatistics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestCoverageStatistics
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestCoverageStatistics_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestCoverageStatistics_cast)
    else:
        cast = _connect.CTestCoverageStatistics_cast

    def getFunctionName(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getFunctionName(self)

    def getSourceLinesExecuted(self) -> "float":
        return _connect.CTestCoverageStatistics_getSourceLinesExecuted(self)

    def getBytesExecuted(self) -> "float":
        return _connect.CTestCoverageStatistics_getBytesExecuted(self)

    def getBranchExecuted(self) -> "float":
        return _connect.CTestCoverageStatistics_getBranchExecuted(self)

    def getBranchTaken(self) -> "float":
        return _connect.CTestCoverageStatistics_getBranchTaken(self)

    def getBranchNotTaken(self) -> "float":
        return _connect.CTestCoverageStatistics_getBranchNotTaken(self)

    def getBranchBoth(self) -> "float":
        return _connect.CTestCoverageStatistics_getBranchBoth(self)

    def getExecutionCount(self) -> "int64_t":
        return _connect.CTestCoverageStatistics_getExecutionCount(self)

    def getBytesExecutedText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBytesExecutedText(self)

    def getSourceLinesExecutedText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getSourceLinesExecutedText(self)

    def getBranchExecutedText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBranchExecutedText(self)

    def getBranchTakenText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBranchTakenText(self)

    def getBranchNotTakenText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBranchNotTakenText(self)

    def getBranchBothText(self) -> "std::string":
        return _connect.CTestCoverageStatistics_getBranchBothText(self)

    def setFunctionName(self, functionName: 'std::string const &') -> "void":
        return _connect.CTestCoverageStatistics_setFunctionName(self, functionName)

    def setCodeExecuted(self, codeExecuted: 'std::string const &') -> "void":
        return _connect.CTestCoverageStatistics_setCodeExecuted(self, codeExecuted)

    def setSourceLinesExecuted(self, codeExecuted: 'std::string const &') -> "void":
        return _connect.CTestCoverageStatistics_setSourceLinesExecuted(self, codeExecuted)

    def setBranchExecuted(self, branchExecuted: 'std::string const &') -> "void":
        return _connect.CTestCoverageStatistics_setBranchExecuted(self, branchExecuted)

    def setBranchTaken(self, branchTaken: 'std::string const &') -> "void":
        return _connect.CTestCoverageStatistics_setBranchTaken(self, branchTaken)

    def setBranchNotTaken(self, branchNotTaken: 'std::string const &') -> "void":
        return _connect.CTestCoverageStatistics_setBranchNotTaken(self, branchNotTaken)

    def setBranchBoth(self, branchBoth: 'std::string const &') -> "void":
        return _connect.CTestCoverageStatistics_setBranchBoth(self, branchBoth)
CTestCoverageStatistics_swigregister = _connect.CTestCoverageStatistics_swigregister
CTestCoverageStatistics_swigregister(CTestCoverageStatistics)

def CTestCoverageStatistics_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestCoverageStatisticsSPtr":
    return _connect.CTestCoverageStatistics_cast(testBase)
CTestCoverageStatistics_cast = _connect.CTestCoverageStatistics_cast

class CTestProfilerTime(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestProfilerTime, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestProfilerTime, name)
    __repr__ = _swig_repr
    E_SECTION_MIN_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_TIME
    E_SECTION_MIN_START_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_START_TIME
    E_SECTION_MIN_END_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_END_TIME
    E_SECTION_MAX_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_TIME
    E_SECTION_MAX_START_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_START_TIME
    E_SECTION_MAX_END_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_END_TIME
    E_SECTION_TOTAL_TIME = _connect.CTestProfilerTime_E_SECTION_TOTAL_TIME
    E_SECTION_AVERAGE_TIME = _connect.CTestProfilerTime_E_SECTION_AVERAGE_TIME

    def __init__(self, *args):
        this = _connect.new_CTestProfilerTime(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestProfilerTime
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestProfilerTime_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestProfilerTime_cast)
    else:
        cast = _connect.CTestProfilerTime_cast

    def getTime(self, profilerStatSectionId: 'isys::CTestProfilerTime::EProfilerTimeSectionId', idx: 'int') -> "std::string":
        return _connect.CTestProfilerTime_getTime(self, profilerStatSectionId, idx)

    def setTime(self, profilerStatSectionId: 'isys::CTestProfilerTime::EProfilerTimeSectionId', time: 'std::string const &', idx: 'int') -> "void":
        return _connect.CTestProfilerTime_setTime(self, profilerStatSectionId, time, idx)
    if _newclass:
        a2d = staticmethod(_connect.CTestProfilerTime_a2d)
    else:
        a2d = _connect.CTestProfilerTime_a2d
CTestProfilerTime_swigregister = _connect.CTestProfilerTime_swigregister
CTestProfilerTime_swigregister(CTestProfilerTime)

def CTestProfilerTime_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestProfilerTimeSPtr":
    return _connect.CTestProfilerTime_cast(testBase)
CTestProfilerTime_cast = _connect.CTestProfilerTime_cast

def CTestProfilerTime_a2d(strNum: 'std::string const &') -> "double":
    return _connect.CTestProfilerTime_a2d(strNum)
CTestProfilerTime_a2d = _connect.CTestProfilerTime_a2d

class CTestProfilerStatistics(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestProfilerStatistics, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestProfilerStatistics, name)
    __repr__ = _swig_repr
    E_SECTION_AREA_NAME = _connect.CTestProfilerStatistics_E_SECTION_AREA_NAME
    E_SECTION_AREA_VALUE = _connect.CTestProfilerStatistics_E_SECTION_AREA_VALUE
    E_SECTION_NET_TIME = _connect.CTestProfilerStatistics_E_SECTION_NET_TIME
    E_SECTION_GROSS_TIME = _connect.CTestProfilerStatistics_E_SECTION_GROSS_TIME
    E_SECTION_CALL_TIME = _connect.CTestProfilerStatistics_E_SECTION_CALL_TIME
    E_SECTION_PERIOD_TIME = _connect.CTestProfilerStatistics_E_SECTION_PERIOD_TIME
    E_SECTION_OUTSIDE_TIME = _connect.CTestProfilerStatistics_E_SECTION_OUTSIDE_TIME
    E_SECTION_HITS = _connect.CTestProfilerStatistics_E_SECTION_HITS
    E_SECTION_MIN_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_MIN_AREA_TIME
    E_SECTION_MAX_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_MAX_AREA_TIME
    E_SECTION_TOTAL_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_TOTAL_AREA_TIME

    def __init__(self, *args):
        this = _connect.new_CTestProfilerStatistics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestProfilerStatistics
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestProfilerStatistics_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestProfilerStatistics_cast)
    else:
        cast = _connect.CTestProfilerStatistics_cast

    def getAreaName(self) -> "std::string":
        return _connect.CTestProfilerStatistics_getAreaName(self)

    def getAreaValue(self) -> "std::string":
        return _connect.CTestProfilerStatistics_getAreaValue(self)

    def getTime(self, sectionId: 'isys::CTestProfilerStatistics::EProfilerStatisticsSectionId', isConst: 'bool') -> "isys::CTestProfilerTimeSPtr":
        return _connect.CTestProfilerStatistics_getTime(self, sectionId, isConst)

    def getHits(self, idx: 'int') -> "std::string":
        return _connect.CTestProfilerStatistics_getHits(self, idx)

    def isAreaValueSet(self) -> "bool":
        return _connect.CTestProfilerStatistics_isAreaValueSet(self)

    def isAreaValueNumber(self) -> "bool":
        return _connect.CTestProfilerStatistics_isAreaValueNumber(self)

    def setAreaName(self, areaName: 'std::string const &') -> "void":
        return _connect.CTestProfilerStatistics_setAreaName(self, areaName)

    def setAreaValue(self, value: 'std::string const &') -> "void":
        return _connect.CTestProfilerStatistics_setAreaValue(self, value)

    def clearAreaValue(self) -> "void":
        return _connect.CTestProfilerStatistics_clearAreaValue(self)

    def setHits(self, limits: 'std::string const &', idx: 'int') -> "void":
        return _connect.CTestProfilerStatistics_setHits(self, limits, idx)

    def getQualifiedAreaName(self, defaultDownloadFile: 'std::string const &') -> "std::string":
        return _connect.CTestProfilerStatistics_getQualifiedAreaName(self, defaultDownloadFile)

    def getQualifiedAreaNameForStateVar(self, defaultDownloadFile: 'std::string const &') -> "std::string":
        return _connect.CTestProfilerStatistics_getQualifiedAreaNameForStateVar(self, defaultDownloadFile)

    def createTestBase(self, section: 'int', lineNo: 'size_t') -> "isys::CTestBaseSPtr":
        return _connect.CTestProfilerStatistics_createTestBase(self, section, lineNo)
CTestProfilerStatistics_swigregister = _connect.CTestProfilerStatistics_swigregister
CTestProfilerStatistics_swigregister(CTestProfilerStatistics)

def CTestProfilerStatistics_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestProfilerStatisticsSPtr":
    return _connect.CTestProfilerStatistics_cast(testBase)
CTestProfilerStatistics_cast = _connect.CTestProfilerStatistics_cast

class CTestCoverageResult(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestCoverageResult, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestCoverageResult, name)
    __repr__ = _swig_repr
    E_SECTION_BYTES_ALL = _connect.CTestCoverageResult_E_SECTION_BYTES_ALL
    E_SECTION_LINES_ALL = _connect.CTestCoverageResult_E_SECTION_LINES_ALL
    E_SECTION_CONDITIONS_ALL = _connect.CTestCoverageResult_E_SECTION_CONDITIONS_ALL
    E_SECTION_COVERAGE_STATS_EXPECTED = _connect.CTestCoverageResult_E_SECTION_COVERAGE_STATS_EXPECTED
    E_SECTION_COVERAGE_STATS_MEASURED = _connect.CTestCoverageResult_E_SECTION_COVERAGE_STATS_MEASURED

    def __init__(self, *args):
        this = _connect.new_CTestCoverageResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestCoverageResult
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestCoverageResult_createInstance(self, parent)

    def isMerged(self) -> "bool":
        return _connect.CTestCoverageResult_isMerged(self)
    if _newclass:
        cast = staticmethod(_connect.CTestCoverageResult_cast)
    else:
        cast = _connect.CTestCoverageResult_cast

    def getExpectedCoverage(self, isConst: 'bool') -> "isys::CTestCoverageStatisticsSPtr":
        return _connect.CTestCoverageResult_getExpectedCoverage(self, isConst)

    def getMeasuredCoverage(self, isConst: 'bool') -> "isys::CTestCoverageStatisticsSPtr":
        return _connect.CTestCoverageResult_getMeasuredCoverage(self, isConst)

    def getMeasuredResults(self) -> "isys::CCoverageStatistic2SPtr const":
        return _connect.CTestCoverageResult_getMeasuredResults(self)

    def getMeasured(self, section: 'isys::CTestCoverageResult::ESectionCoverageResult') -> "int":
        return _connect.CTestCoverageResult_getMeasured(self, section)

    def isError(self) -> "bool":
        return _connect.CTestCoverageResult_isError(self)

    def isBytesExecutedError(self) -> "bool":
        return _connect.CTestCoverageResult_isBytesExecutedError(self)

    def isSourceLinesExecutedError(self) -> "bool":
        return _connect.CTestCoverageResult_isSourceLinesExecutedError(self)

    def isBranchesExecutedError(self) -> "bool":
        return _connect.CTestCoverageResult_isBranchesExecutedError(self)

    def isBranchesTakenError(self) -> "bool":
        return _connect.CTestCoverageResult_isBranchesTakenError(self)

    def isBranchesNotTakenError(self) -> "bool":
        return _connect.CTestCoverageResult_isBranchesNotTakenError(self)

    def isBranchesBothError(self) -> "bool":
        return _connect.CTestCoverageResult_isBranchesBothError(self)
CTestCoverageResult_swigregister = _connect.CTestCoverageResult_swigregister
CTestCoverageResult_swigregister(CTestCoverageResult)

def CTestCoverageResult_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestCoverageResultSPtr":
    return _connect.CTestCoverageResult_cast(testBase)
CTestCoverageResult_cast = _connect.CTestCoverageResult_cast

class CTestTreeNode(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestTreeNode, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestTreeNode, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        cast = staticmethod(_connect.CTestTreeNode_cast)
    else:
        cast = _connect.CTestTreeNode_cast

    def getChildren(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestTreeNode_getChildren(self, isConst)

    def getNoOfAllChildrenInHierarchy(self) -> "size_t":
        return _connect.CTestTreeNode_getNoOfAllChildrenInHierarchy(self)

    def getParentNode(self) -> "isys::CTestTreeNodeSPtr":
        return _connect.CTestTreeNode_getParentNode(self)

    def toUIString(self) -> "std::string":
        return _connect.CTestTreeNode_toUIString(self)

    def compare(self, testNode: 'isys::CTestTreeNodeSPtr') -> "bool":
        return _connect.CTestTreeNode_compare(self, testNode)

    def hashCodeAsPtr(self) -> "int64_t":
        return _connect.CTestTreeNode_hashCodeAsPtr(self)

    def addChildAndSetParent(self, idx: 'int', child: 'isys::CTestTreeNodeSPtr const &') -> "void":
        return _connect.CTestTreeNode_addChildAndSetParent(self, idx, child)

    def deleteChild(self, child: 'isys::CTestTreeNodeSPtr const &') -> "int":
        return _connect.CTestTreeNode_deleteChild(self, child)

    def hasChildren(self) -> "bool":
        return _connect.CTestTreeNode_hasChildren(self)

    def getId(self) -> "std::string":
        return _connect.CTestTreeNode_getId(self)

    def getUILabel(self) -> "std::string":
        return _connect.CTestTreeNode_getUILabel(self)

    def isGroup(self) -> "bool":
        return _connect.CTestTreeNode_isGroup(self)
    __swig_destroy__ = _connect.delete_CTestTreeNode
    __del__ = lambda self: None
CTestTreeNode_swigregister = _connect.CTestTreeNode_swigregister
CTestTreeNode_swigregister(CTestTreeNode)

def CTestTreeNode_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestTreeNodeSPtr":
    return _connect.CTestTreeNode_cast(testBase)
CTestTreeNode_cast = _connect.CTestTreeNode_cast

class CTestGroup(CTestTreeNode):
    __swig_setmethods__ = {}
    for _s in [CTestTreeNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestTreeNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestGroup, name)
    __repr__ = _swig_repr
    ECore = _connect.CTestGroup_ECore
    EPartition = _connect.CTestGroup_EPartition
    EModule = _connect.CTestGroup_EModule
    EFunction = _connect.CTestGroup_EFunction
    ECustom = _connect.CTestGroup_ECustom
    E_SECTION_GROUP_ID = _connect.CTestGroup_E_SECTION_GROUP_ID
    E_SECTION_IS_EXECUTE = _connect.CTestGroup_E_SECTION_IS_EXECUTE
    E_SECTION_DESCRIPTION = _connect.CTestGroup_E_SECTION_DESCRIPTION
    E_SECTION_FILTER = _connect.CTestGroup_E_SECTION_FILTER
    E_SECTION_MERGED_ANALYZER_FILE = _connect.CTestGroup_E_SECTION_MERGED_ANALYZER_FILE
    E_SECTION_CLOSE_ANALYZER_FILE = _connect.CTestGroup_E_SECTION_CLOSE_ANALYZER_FILE
    E_SECTION_COVERAGE_EXPORT = _connect.CTestGroup_E_SECTION_COVERAGE_EXPORT
    E_SECTION_COVERAGE_ALL_CODE_IN_GROUP = _connect.CTestGroup_E_SECTION_COVERAGE_ALL_CODE_IN_GROUP
    E_SECTION_COVERAGE_TEST_CASES_ONLY = _connect.CTestGroup_E_SECTION_COVERAGE_TEST_CASES_ONLY
    E_SECTION_GROUP_INIT_SCRIPT = _connect.CTestGroup_E_SECTION_GROUP_INIT_SCRIPT
    E_SECTION_GROUP_END_SCRIPT = _connect.CTestGroup_E_SECTION_GROUP_END_SCRIPT
    E_SECTION_CHILDREN = _connect.CTestGroup_E_SECTION_CHILDREN

    def __init__(self, *args):
        this = _connect.new_CTestGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestGroup
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestGroup_createInstance(self, parent)

    def isMerged(self) -> "bool":
        return _connect.CTestGroup_isMerged(self)
    if _newclass:
        cast = staticmethod(_connect.CTestGroup_cast)
    else:
        cast = _connect.CTestGroup_cast

    def getParentGroup(self) -> "isys::CTestGroupSPtr":
        return _connect.CTestGroup_getParentGroup(self)

    def getContainerTestNode(self) -> "isys::CTestTreeNodeSPtr":
        return _connect.CTestGroup_getContainerTestNode(self)

    def getUILabel(self) -> "std::string":
        return _connect.CTestGroup_getUILabel(self)

    def isGroup(self) -> "bool":
        return _connect.CTestGroup_isGroup(self)

    def getId(self) -> "std::string":
        return _connect.CTestGroup_getId(self)

    def getDescription(self) -> "std::string":
        return _connect.CTestGroup_getDescription(self)

    def getFilter(self, isConst: 'bool') -> "isys::CTestFilterSPtr":
        return _connect.CTestGroup_getFilter(self, isConst)

    def getMergedAnalyzerFileName(self) -> "std::string":
        return _connect.CTestGroup_getMergedAnalyzerFileName(self)

    def isCloseAfterTest(self) -> "bool":
        return _connect.CTestGroup_isCloseAfterTest(self)

    def getCoverageExportConfig(self, isConst: 'bool') -> "isys::CTestAnalyzerCoverageSPtr":
        return _connect.CTestGroup_getCoverageExportConfig(self, isConst)

    def getCoverageStatForAllCodeInGroup(self, isConst: 'bool') -> "isys::CTestCoverageStatisticsSPtr":
        return _connect.CTestGroup_getCoverageStatForAllCodeInGroup(self, isConst)

    def getCoverageStatForTestCasesOnly(self, isConst: 'bool') -> "isys::CTestCoverageStatisticsSPtr":
        return _connect.CTestGroup_getCoverageStatForTestCasesOnly(self, isConst)

    def getScriptFunction(self, section: 'isys::CTestGroup::ESectionCTestGroup', isConst: 'bool') -> "isys::CTestFunctionSPtr":
        return _connect.CTestGroup_getScriptFunction(self, section, isConst)

    def getNoOfTestCasesInGroup(self) -> "int":
        return _connect.CTestGroup_getNoOfTestCasesInGroup(self)

    def addChildAndSetParent(self, idx: 'int', child: 'isys::CTestTreeNodeSPtr const &') -> "void":
        return _connect.CTestGroup_addChildAndSetParent(self, idx, child)

    def getChildren(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestGroup_getChildren(self, isConst)

    def hasChildren(self) -> "bool":
        return _connect.CTestGroup_hasChildren(self)

    def deleteChild(self, child: 'isys::CTestTreeNodeSPtr const &') -> "int":
        return _connect.CTestGroup_deleteChild(self, child)

    def hasTestSpecs(self) -> "bool":
        return _connect.CTestGroup_hasTestSpecs(self)

    def clearTestSpecs(self) -> "void":
        return _connect.CTestGroup_clearTestSpecs(self)

    def isTestSpecOwner(self) -> "bool":
        return _connect.CTestGroup_isTestSpecOwner(self)

    def getOwnedTestSpec(self) -> "isys::CTestSpecificationSPtr":
        return _connect.CTestGroup_getOwnedTestSpec(self)

    def getTestOwnerGroupsSize(self) -> "size_t":
        return _connect.CTestGroup_getTestOwnerGroupsSize(self)

    def getTestOwnerGroup(self, idx: 'size_t') -> "isys::CTestGroupSPtr":
        return _connect.CTestGroup_getTestOwnerGroup(self, idx)

    def isBelongsToFilterGroup(self) -> "bool":
        return _connect.CTestGroup_isBelongsToFilterGroup(self)
CTestGroup_swigregister = _connect.CTestGroup_swigregister
CTestGroup_swigregister(CTestGroup)
TAG_GROUP_ID = cvar.TAG_GROUP_ID
TAG_GROUP_DESCRIPTION = cvar.TAG_GROUP_DESCRIPTION

def CTestGroup_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestGroupSPtr":
    return _connect.CTestGroup_cast(testBase)
CTestGroup_cast = _connect.CTestGroup_cast

class CTestResultBase(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestResultBase, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestResultBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CTestResultBase
    __del__ = lambda self: None

    def isError(self) -> "bool":
        return _connect.CTestResultBase_isError(self)

    def isException(self) -> "bool":
        return _connect.CTestResultBase_isException(self)

    def getExceptionString(self) -> "std::string":
        return _connect.CTestResultBase_getExceptionString(self)

    def getResultComment(self) -> "std::string":
        return _connect.CTestResultBase_getResultComment(self)

    def isScriptError(self, *args) -> "bool":
        return _connect.CTestResultBase_isScriptError(self, *args)

    def isStackUsageError(self) -> "bool":
        return _connect.CTestResultBase_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType: 'std::string const &') -> "std::string":
        return _connect.CTestResultBase_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType: 'std::string const &') -> "std::string":
        return _connect.CTestResultBase_getScriptOutput(self, scriptFunctionType)

    def appendScriptError(self, scriptFunctionType: 'std::string const &', errorDesc: 'std::string const &') -> "void":
        return _connect.CTestResultBase_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType: 'std::string const &', outStr: 'std::string const &') -> "void":
        return _connect.CTestResultBase_appendScriptOutput(self, scriptFunctionType, outStr)
CTestResultBase_swigregister = _connect.CTestResultBase_swigregister
CTestResultBase_swigregister(CTestResultBase)
CTestResultBase.SE_INIT_SEQ = _connect.cvar.CTestResultBase_SE_INIT_SEQ
CTestResultBase.SE_INIT_TARGET = _connect.cvar.CTestResultBase_SE_INIT_TARGET
CTestResultBase.SE_INIT_FUNC = _connect.cvar.CTestResultBase_SE_INIT_FUNC
CTestResultBase.SE_END_FUNC = _connect.cvar.CTestResultBase_SE_END_FUNC
CTestResultBase.SE_RESTORE_TARGET = _connect.cvar.CTestResultBase_SE_RESTORE_TARGET
CTestResultBase.SE_STUB = _connect.cvar.CTestResultBase_SE_STUB
CTestResultBase.SE_TEST_POINT = _connect.cvar.CTestResultBase_SE_TEST_POINT
CTestResultBase.SE_FILTER = _connect.cvar.CTestResultBase_SE_FILTER
CTestResultBase.SE_GROUP_INIT_FUNC = _connect.cvar.CTestResultBase_SE_GROUP_INIT_FUNC
CTestResultBase.SE_GROUP_END_FUNC = _connect.cvar.CTestResultBase_SE_GROUP_END_FUNC

class CProfilerTestResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CProfilerTestResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CProfilerTestResult, name)
    __repr__ = _swig_repr
    ERR_NONE = _connect.CProfilerTestResult_ERR_NONE
    ERR_MIN = _connect.CProfilerTestResult_ERR_MIN
    ERR_MAX = _connect.CProfilerTestResult_ERR_MAX
    ERR_BOTH = _connect.CProfilerTestResult_ERR_BOTH

    def __init__(self, *args):
        this = _connect.new_CProfilerTestResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isValueSet(self) -> "bool":
        return _connect.CProfilerTestResult_isValueSet(self)

    def isResultSet(self) -> "bool":
        return _connect.CProfilerTestResult_isResultSet(self)

    def getMeasuredResult(self) -> "isys::CProfilerStatistics2":
        return _connect.CProfilerTestResult_getMeasuredResult(self)

    def isError(self) -> "bool":
        return _connect.CProfilerTestResult_isError(self)

    def validateError(self, statsId: 'isys::CTestProfilerStatistics::EProfilerStatisticsSectionId', timeId: 'isys::CTestProfilerTime::EProfilerTimeSectionId') -> "isys::CProfilerTestResult::ProfilerErrCode":
        return _connect.CProfilerTestResult_validateError(self, statsId, timeId)

    def validateAllTimes(self, prevError: 'isys::CProfilerTestResult::ProfilerErrCode') -> "isys::CProfilerTestResult::ProfilerErrCode":
        return _connect.CProfilerTestResult_validateAllTimes(self, prevError)

    def validateTimeScopeForAllTimeTypes(self, statsId: 'isys::CTestProfilerStatistics::EProfilerStatisticsSectionId') -> "isys::CProfilerTestResult::ProfilerErrCode":
        return _connect.CProfilerTestResult_validateTimeScopeForAllTimeTypes(self, statsId)

    def validateTimeTypeForAllScopes(self, timeTypeId: 'isys::CTestProfilerTime::EProfilerTimeSectionId') -> "isys::CProfilerTestResult::ProfilerErrCode":
        return _connect.CProfilerTestResult_validateTimeTypeForAllScopes(self, timeTypeId)

    def validateHits(self) -> "isys::CProfilerTestResult::ProfilerErrCode":
        return _connect.CProfilerTestResult_validateHits(self)

    def getMeasuredTime(self, statsId: 'isys::CTestProfilerStatistics::EProfilerStatisticsSectionId', timeId: 'isys::CTestProfilerTime::EProfilerTimeSectionId') -> "std::string":
        return _connect.CProfilerTestResult_getMeasuredTime(self, statsId, timeId)

    def getMeasuredHits(self) -> "std::string":
        return _connect.CProfilerTestResult_getMeasuredHits(self)

    def getExpectedResult(self) -> "isys::CTestProfilerStatisticsSPtr":
        return _connect.CProfilerTestResult_getExpectedResult(self)

    def getValue(self) -> "std::string":
        return _connect.CProfilerTestResult_getValue(self)

    def serialize(self, emitter: 'isys::IEmitterSPtr const &') -> "void":
        return _connect.CProfilerTestResult_serialize(self, emitter)

    def serializeErrorsOnly(self, emitter: 'isys::IEmitterSPtr const &') -> "void":
        return _connect.CProfilerTestResult_serializeErrorsOnly(self, emitter)
    __swig_destroy__ = _connect.delete_CProfilerTestResult
    __del__ = lambda self: None
CProfilerTestResult_swigregister = _connect.CProfilerTestResult_swigregister
CProfilerTestResult_swigregister(CProfilerTestResult)

class CLogResult(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CLogResult, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CLogResult, name)
    __repr__ = _swig_repr
    E_SECTION_BEFORE_ASSIGN = _connect.CLogResult_E_SECTION_BEFORE_ASSIGN
    E_SECTION_AFTER_ASSIGN = _connect.CLogResult_E_SECTION_AFTER_ASSIGN

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CLogResult(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CLogResult_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CLogResult_cast)
    else:
        cast = _connect.CLogResult_cast

    def serialize(self, emitter: 'isys::IEmitterSPtr const &') -> "void":
        return _connect.CLogResult_serialize(self, emitter)

    def add(self, expr: 'std::string const &', result: 'std::string const &', logType: 'isys::CLogResult::ETestResultSections') -> "void":
        return _connect.CLogResult_add(self, expr, result, logType)

    def getLog(self, expressions: 'StrVector', results: 'StrVector', logType: 'isys::CLogResult::ETestResultSections') -> "void":
        return _connect.CLogResult_getLog(self, expressions, results, logType)
    __swig_destroy__ = _connect.delete_CLogResult
    __del__ = lambda self: None
CLogResult_swigregister = _connect.CLogResult_swigregister
CLogResult_swigregister(CLogResult)

def CLogResult_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CLogResultSPtr":
    return _connect.CLogResult_cast(testBase)
CLogResult_cast = _connect.CLogResult_cast

class CTestPointResult(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestPointResult, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestPointResult, name)
    __repr__ = _swig_repr
    E_SECTION_TEST_POINT_ID = _connect.CTestPointResult_E_SECTION_TEST_POINT_ID
    E_SECTION_LOCATION = _connect.CTestPointResult_E_SECTION_LOCATION
    E_SECTION_EXEC_STATUS = _connect.CTestPointResult_E_SECTION_EXEC_STATUS
    E_SECTION_HIT_NO = _connect.CTestPointResult_E_SECTION_HIT_NO
    E_SECTION_STEP_IDX = _connect.CTestPointResult_E_SECTION_STEP_IDX
    E_SECTION_LOG_RESULT = _connect.CTestPointResult_E_SECTION_LOG_RESULT
    E_SECTION_SCRIPT_INFO_VAR = _connect.CTestPointResult_E_SECTION_SCRIPT_INFO_VAR
    E_SECTION_SCRIPT_RET_VAL = _connect.CTestPointResult_E_SECTION_SCRIPT_RET_VAL
    E_SECTION_EXPR_ERRORS = _connect.CTestPointResult_E_SECTION_EXPR_ERRORS
    EXECUTED = _connect.CTestPointResult_EXECUTED
    CONDITION_FALSE = _connect.CTestPointResult_CONDITION_FALSE
    HIT_COUNT_FALSE = _connect.CTestPointResult_HIT_COUNT_FALSE

    def __init__(self, *args):
        this = _connect.new_CTestPointResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestPointResult_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestPointResult_cast)
    else:
        cast = _connect.CTestPointResult_cast

    def serialize(self, emitter: 'isys::IEmitterSPtr const &') -> "void":
        return _connect.CTestPointResult_serialize(self, emitter)

    def isError(self) -> "bool":
        return _connect.CTestPointResult_isError(self)

    def isExprError(self) -> "bool":
        return _connect.CTestPointResult_isExprError(self)

    def isScriptError(self) -> "bool":
        return _connect.CTestPointResult_isScriptError(self)

    def hasData(self) -> "bool":
        return _connect.CTestPointResult_hasData(self)

    def getExecStatus(self) -> "isys::CTestPointResult::EExecStatus":
        return _connect.CTestPointResult_getExecStatus(self)

    def getLogResult(self, isConst: 'bool') -> "isys::CLogResultSPtr":
        return _connect.CTestPointResult_getLogResult(self, isConst)

    def getId(self) -> "std::string":
        return _connect.CTestPointResult_getId(self)

    def getLocation(self) -> "std::string":
        return _connect.CTestPointResult_getLocation(self)

    def getHitNo(self) -> "int":
        return _connect.CTestPointResult_getHitNo(self)

    def getStepIdx(self) -> "int":
        return _connect.CTestPointResult_getStepIdx(self)

    def getScriptInfoVar(self) -> "std::string":
        return _connect.CTestPointResult_getScriptInfoVar(self)

    def getScriptRetVal(self) -> "std::string":
        return _connect.CTestPointResult_getScriptRetVal(self)

    def getExpressionErrors(self, expressions: 'StrVector', results: 'StrVector') -> "void":
        return _connect.CTestPointResult_getExpressionErrors(self, expressions, results)

    def setId(self, testPointId: 'std::string const &') -> "void":
        return _connect.CTestPointResult_setId(self, testPointId)

    def setLocation(self, location: 'std::string const &') -> "void":
        return _connect.CTestPointResult_setLocation(self, location)

    def setExecStatus(self, execStatus: 'isys::CTestPointResult::EExecStatus') -> "void":
        return _connect.CTestPointResult_setExecStatus(self, execStatus)

    def setHitNoAndStepIdx(self, hitNo: 'int', stepIdx: 'int') -> "void":
        return _connect.CTestPointResult_setHitNoAndStepIdx(self, hitNo, stepIdx)

    def setScriptInfoVar(self, scriptOutput: 'std::string const &') -> "void":
        return _connect.CTestPointResult_setScriptInfoVar(self, scriptOutput)

    def setScriptRetVal(self, scriptError: 'std::string const &') -> "void":
        return _connect.CTestPointResult_setScriptRetVal(self, scriptError)

    def addExpressionError(self, expr: 'std::string const &', result: 'std::string const &') -> "void":
        return _connect.CTestPointResult_addExpressionError(self, expr, result)
    __swig_destroy__ = _connect.delete_CTestPointResult
    __del__ = lambda self: None
CTestPointResult_swigregister = _connect.CTestPointResult_swigregister
CTestPointResult_swigregister(CTestPointResult)

def CTestPointResult_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestPointResultSPtr":
    return _connect.CTestPointResult_cast(testBase)
CTestPointResult_cast = _connect.CTestPointResult_cast

class CStackUsageResult(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CStackUsageResult, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CStackUsageResult, name)
    __repr__ = _swig_repr
    E_SECTION_USAGE_BEFORE_TEST = _connect.CStackUsageResult_E_SECTION_USAGE_BEFORE_TEST
    E_SECTION_TEST_IDEA_USAGE = _connect.CStackUsageResult_E_SECTION_TEST_IDEA_USAGE
    E_SECTION_APPLICATION_USAGE = _connect.CStackUsageResult_E_SECTION_APPLICATION_USAGE
    E_SECTION_MAX_EXPECTED_SIZE = _connect.CStackUsageResult_E_SECTION_MAX_EXPECTED_SIZE

    def __init__(self, *args):
        this = _connect.new_CStackUsageResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CStackUsageResult_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CStackUsageResult_cast)
    else:
        cast = _connect.CStackUsageResult_cast

    def isError(self) -> "bool":
        return _connect.CStackUsageResult_isError(self)

    def getMaxExpectedSize(self) -> "int":
        return _connect.CStackUsageResult_getMaxExpectedSize(self)

    def getUsageBeforeTest(self) -> "int":
        return _connect.CStackUsageResult_getUsageBeforeTest(self)

    def getTestIDEAUsage(self) -> "int":
        return _connect.CStackUsageResult_getTestIDEAUsage(self)

    def getApplicationUsage(self) -> "int":
        return _connect.CStackUsageResult_getApplicationUsage(self)

    def setValues(self, minExpSize: 'ADDRESS_64', maxExpSize: 'ADDRESS_64', stackUsedBeforeTest: 'ADDRESS_64', testIDEAUsage: 'ADDRESS_64', appUsage: 'ADDRESS_64') -> "void":
        return _connect.CStackUsageResult_setValues(self, minExpSize, maxExpSize, stackUsedBeforeTest, testIDEAUsage, appUsage)
    __swig_destroy__ = _connect.delete_CStackUsageResult
    __del__ = lambda self: None
CStackUsageResult_swigregister = _connect.CStackUsageResult_swigregister
CStackUsageResult_swigregister(CStackUsageResult)

def CStackUsageResult_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CStackUsageResultSPtr":
    return _connect.CStackUsageResult_cast(testBase)
CStackUsageResult_cast = _connect.CStackUsageResult_cast

class CTestExprResult(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestExprResult, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestExprResult, name)
    __repr__ = _swig_repr
    E_SECTION_EXPR_RESULT_EXPR = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_EXPR
    E_SECTION_EXPR_RESULT_SUBEXPRS = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_SUBEXPRS
    E_SECTION_EXPR_RESULT_IS_ERROR = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_IS_ERROR

    def __init__(self, *args):
        this = _connect.new_CTestExprResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestExprResult_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestExprResult_cast)
    else:
        cast = _connect.CTestExprResult_cast

    def getExpression(self) -> "std::string":
        return _connect.CTestExprResult_getExpression(self)

    def getSubexpressions(self, isConst: 'bool') -> "isys::CMapAdapter":
        return _connect.CTestExprResult_getSubexpressions(self, isConst)

    def isError(self) -> "bool":
        return _connect.CTestExprResult_isError(self)

    def toUIString(self) -> "std::string":
        return _connect.CTestExprResult_toUIString(self)

    def setExpression(self, expression: 'std::string const &') -> "void":
        return _connect.CTestExprResult_setExpression(self, expression)

    def addSubexpression(self, subExpression: 'std::string const &', value: 'std::string const &') -> "void":
        return _connect.CTestExprResult_addSubexpression(self, subExpression, value)

    def setError(self, isSuccess: 'bool') -> "void":
        return _connect.CTestExprResult_setError(self, isSuccess)
    __swig_destroy__ = _connect.delete_CTestExprResult
    __del__ = lambda self: None
CTestExprResult_swigregister = _connect.CTestExprResult_swigregister
CTestExprResult_swigregister(CTestExprResult)

def CTestExprResult_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestExprResultSPtr":
    return _connect.CTestExprResult_cast(testBase)
CTestExprResult_cast = _connect.CTestExprResult_cast

class CTestResult(CTestResultBase):
    __swig_setmethods__ = {}
    for _s in [CTestResultBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestResult, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestResultBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestResult, name)
    __repr__ = _swig_repr
    E_SECTION_RESULT_COMMENT = _connect.CTestResult_E_SECTION_RESULT_COMMENT
    E_SECTION_DEFAULT_DOWNLOAD_FILE = _connect.CTestResult_E_SECTION_DEFAULT_DOWNLOAD_FILE
    E_SECTION_STUB_RESULTS = _connect.CTestResult_E_SECTION_STUB_RESULTS
    E_SECTION_TEST_POINT_RESULTS = _connect.CTestResult_E_SECTION_TEST_POINT_RESULTS
    E_SECTION_STACK_USAGE_RESULTS = _connect.CTestResult_E_SECTION_STACK_USAGE_RESULTS
    E_SECTION_TARGET_EXCEPTION = _connect.CTestResult_E_SECTION_TARGET_EXCEPTION
    E_SECTION_PRE_CONDITION = _connect.CTestResult_E_SECTION_PRE_CONDITION
    E_SECTION_ASSERT = _connect.CTestResult_E_SECTION_ASSERT
    E_SECTION_LOG = _connect.CTestResult_E_SECTION_LOG
    E_SECTION_DRY_RUN_ASSIGNMENTS = _connect.CTestResult_E_SECTION_DRY_RUN_ASSIGNMENTS
    E_SECTION_DIAGRAMS = _connect.CTestResult_E_SECTION_DIAGRAMS
    E_SECTION_SCRIPT_ERRORS = _connect.CTestResult_E_SECTION_SCRIPT_ERRORS
    E_SECTION_SCRIPT_OUTPUT = _connect.CTestResult_E_SECTION_SCRIPT_OUTPUT

    def __init__(self, testSpecification: 'isys::CTestSpecificationSPtr const &', exceptionMessage: 'std::string const &'):
        this = _connect.new_CTestResult(testSpecification, exceptionMessage)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestResult_createInstance(self, parent)

    def getResultComment(self) -> "std::string":
        return _connect.CTestResult_getResultComment(self)

    def getDefaultDownloadFile(self) -> "std::string":
        return _connect.CTestResult_getDefaultDownloadFile(self)

    def getTestId(self) -> "std::string":
        return _connect.CTestResult_getTestId(self)

    def getFunction(self) -> "std::string":
        return _connect.CTestResult_getFunction(self)

    def getTestSpecification(self) -> "isys::CTestSpecificationSPtr":
        return _connect.CTestResult_getTestSpecification(self)

    def getProfilerExportFileName(self) -> "std::string":
        return _connect.CTestResult_getProfilerExportFileName(self)

    def isError(self) -> "bool":
        return _connect.CTestResult_isError(self)

    def isException(self) -> "bool":
        return _connect.CTestResult_isException(self)

    def getExceptionString(self) -> "std::string":
        return _connect.CTestResult_getExceptionString(self)

    def isTargetException(self) -> "bool":
        return _connect.CTestResult_isTargetException(self)

    def isExpressionError(self) -> "bool":
        return _connect.CTestResult_isExpressionError(self)

    def isPreConditionError(self) -> "bool":
        return _connect.CTestResult_isPreConditionError(self)

    def isTargetExceptionError(self) -> "bool":
        return _connect.CTestResult_isTargetExceptionError(self)

    def isCodeCoverageError(self) -> "bool":
        return _connect.CTestResult_isCodeCoverageError(self)

    def isProfilerCodeError(self) -> "bool":
        return _connect.CTestResult_isProfilerCodeError(self)

    def isProfilerDataError(self) -> "bool":
        return _connect.CTestResult_isProfilerDataError(self)

    def isScriptError(self, *args) -> "bool":
        return _connect.CTestResult_isScriptError(self, *args)

    def isTestPointError(self) -> "bool":
        return _connect.CTestResult_isTestPointError(self)

    def isStubError(self) -> "bool":
        return _connect.CTestResult_isStubError(self)

    def isStackUsageError(self) -> "bool":
        return _connect.CTestResult_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType: 'std::string const &') -> "std::string":
        return _connect.CTestResult_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType: 'std::string const &') -> "std::string":
        return _connect.CTestResult_getScriptOutput(self, scriptFunctionType)

    def getPreConditionResults(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestResult_getPreConditionResults(self, isConst)

    def getAssertResults(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestResult_getAssertResults(self, isConst)

    def getLogResult(self, isConst: 'bool') -> "isys::CLogResultSPtr":
        return _connect.CTestResult_getLogResult(self, isConst)

    def getCoverageResults(self, resultMap: 'StrCoverageTestResultsMap') -> "void":
        return _connect.CTestResult_getCoverageResults(self, resultMap)

    def getCoverageResultsWithError(self, resultMap: 'StrCoverageTestResultsMap') -> "void":
        return _connect.CTestResult_getCoverageResultsWithError(self, resultMap)

    def getProfilerCodeResult(self, areaName: 'std::string const') -> "isys::CProfilerTestResultSPtr":
        return _connect.CTestResult_getProfilerCodeResult(self, areaName)

    def getProfilerCodeResults(self, resultMap: 'StrProfilerTestResultsMap') -> "void":
        return _connect.CTestResult_getProfilerCodeResults(self, resultMap)

    def getProfilerDataResult(self, areaName: 'std::string const') -> "isys::CProfilerTestResultSPtr":
        return _connect.CTestResult_getProfilerDataResult(self, areaName)

    def getProfilerDataResults(self, resultMap: 'StrProfilerTestResultsMap') -> "void":
        return _connect.CTestResult_getProfilerDataResults(self, resultMap)

    def serialize(self, emitter: 'isys::IEmitterSPtr const &', reportConfig: 'isys::CTestReportConfigSPtr const &') -> "void":
        return _connect.CTestResult_serialize(self, emitter, reportConfig)

    def serializeErrorsOnly(self, emitter: 'isys::IEmitterSPtr const &', reportConfig: 'isys::CTestReportConfigSPtr const &') -> "void":
        return _connect.CTestResult_serializeErrorsOnly(self, emitter, reportConfig)

    def toString(self) -> "std::string":
        return _connect.CTestResult_toString(self)

    def toUIString(self) -> "std::string":
        return _connect.CTestResult_toUIString(self)

    def diffsToUIString(self, section: 'isys::CTestResult::ETestResultSection') -> "std::string":
        return _connect.CTestResult_diffsToUIString(self, section)

    def setTestSpecification(self, testSpec: 'isys::CTestSpecificationSPtr &') -> "void":
        return _connect.CTestResult_setTestSpecification(self, testSpec)

    def setTargetException(self, isTargetException: 'bool') -> "void":
        return _connect.CTestResult_setTargetException(self, isTargetException)

    def getAnalyzerFileName(self) -> "std::string":
        return _connect.CTestResult_getAnalyzerFileName(self)

    def getStubResults(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestResult_getStubResults(self, isConst)

    def getTestPointResults(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestResult_getTestPointResults(self, isConst)

    def setResultComment(self, resultComment: 'std::string const &') -> "void":
        return _connect.CTestResult_setResultComment(self, resultComment)

    def setDefaultDownloadFile(self, defaultDlFileName: 'std::string const &') -> "void":
        return _connect.CTestResult_setDefaultDownloadFile(self, defaultDlFileName)

    def addExprResult(self, section: 'isys::CTestResult::ETestResultSection', result: 'isys::CTestExprResultSPtr &') -> "void":
        return _connect.CTestResult_addExprResult(self, section, result)

    def addStubResult(self, result: 'isys::CTestPointResultSPtr &') -> "void":
        return _connect.CTestResult_addStubResult(self, result)

    def addTestPointResult(self, result: 'isys::CTestPointResultSPtr &') -> "void":
        return _connect.CTestResult_addTestPointResult(self, result)

    def getStackUsageResult(self, isConst: 'bool') -> "isys::CStackUsageResultSPtr":
        return _connect.CTestResult_getStackUsageResult(self, isConst)

    def setStackUsageResult(self, stackUsageResult: 'isys::CStackUsageResultSPtr') -> "void":
        return _connect.CTestResult_setStackUsageResult(self, stackUsageResult)

    def setTargetExceptionStr(self, targetException: 'std::string const &') -> "void":
        return _connect.CTestResult_setTargetExceptionStr(self, targetException)

    def appendScriptError(self, scriptFunctionType: 'std::string const &', errorDesc: 'std::string const &') -> "void":
        return _connect.CTestResult_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType: 'std::string const &', outStr: 'std::string const &') -> "void":
        return _connect.CTestResult_appendScriptOutput(self, scriptFunctionType, outStr)

    def addDryRunAssignment(self, varName: 'std::string const &', value: 'std::string const &') -> "void":
        return _connect.CTestResult_addDryRunAssignment(self, varName, value)

    def addDiagram(self, imageFileName: 'std::string const &') -> "void":
        return _connect.CTestResult_addDiagram(self, imageFileName)
    if _newclass:
        funcType2PyVarName = staticmethod(_connect.CTestResult_funcType2PyVarName)
    else:
        funcType2PyVarName = _connect.CTestResult_funcType2PyVarName
    __swig_destroy__ = _connect.delete_CTestResult
    __del__ = lambda self: None
CTestResult_swigregister = _connect.CTestResult_swigregister
CTestResult_swigregister(CTestResult)

def CTestResult_funcType2PyVarName(scriptFunctionType: 'std::string const &') -> "std::string":
    return _connect.CTestResult_funcType2PyVarName(scriptFunctionType)
CTestResult_funcType2PyVarName = _connect.CTestResult_funcType2PyVarName

class CTestGroupResult(CTestResultBase):
    __swig_setmethods__ = {}
    for _s in [CTestResultBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestGroupResult, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestResultBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestGroupResult, name)
    __repr__ = _swig_repr
    E_NO_OF_TEST_CASES_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_TEST_CASES_IN_GROUP
    E_NO_OF_FUNCTIONS_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_FUNCTIONS_IN_GROUP
    E_NO_OF_MODULES_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_MODULES_IN_GROUP
    E_NO_OF_PARTITIONS_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_PARTITIONS_IN_GROUP
    E_EXCEPTION_MSG = _connect.CTestGroupResult_E_EXCEPTION_MSG
    E_PASSED_TCS = _connect.CTestGroupResult_E_PASSED_TCS
    E_FAILED_TCS = _connect.CTestGroupResult_E_FAILED_TCS
    E_ERROR_TCS = _connect.CTestGroupResult_E_ERROR_TCS
    E_PASSED_FUNCTIONS = _connect.CTestGroupResult_E_PASSED_FUNCTIONS
    E_FAILED_FUNCTIONS = _connect.CTestGroupResult_E_FAILED_FUNCTIONS
    E_ERROR_FUNCTIONS = _connect.CTestGroupResult_E_ERROR_FUNCTIONS
    E_PASSED_MODULES = _connect.CTestGroupResult_E_PASSED_MODULES
    E_FAILED_MODULES = _connect.CTestGroupResult_E_FAILED_MODULES
    E_ERROR_MODULES = _connect.CTestGroupResult_E_ERROR_MODULES
    E_PASSED_PARTITIONS = _connect.CTestGroupResult_E_PASSED_PARTITIONS
    E_FAILED_PARTITIONS = _connect.CTestGroupResult_E_FAILED_PARTITIONS
    E_ERROR_PARTITIONS = _connect.CTestGroupResult_E_ERROR_PARTITIONS
    E_FAILED_PRECOND = _connect.CTestGroupResult_E_FAILED_PRECOND
    E_FAILED_ASSERT = _connect.CTestGroupResult_E_FAILED_ASSERT
    E_FAILED_COVERAGE = _connect.CTestGroupResult_E_FAILED_COVERAGE
    E_FAILED_PROFILER_CODE = _connect.CTestGroupResult_E_FAILED_PROFILER_CODE
    E_FAILED_PROFILER_DATA = _connect.CTestGroupResult_E_FAILED_PROFILER_DATA
    E_FAILED_STUB = _connect.CTestGroupResult_E_FAILED_STUB
    E_FAILED_TEST_POINT = _connect.CTestGroupResult_E_FAILED_TEST_POINT
    E_FAILED_STACK_USAGE = _connect.CTestGroupResult_E_FAILED_STACK_USAGE
    E_FAILED_TARGET_EXCEPTIONS = _connect.CTestGroupResult_E_FAILED_TARGET_EXCEPTIONS
    E_SECTION_RESULT_COMMENT = _connect.CTestGroupResult_E_SECTION_RESULT_COMMENT
    E_SECTION_DEFAULT_DOWNLOAD_FILE = _connect.CTestGroupResult_E_SECTION_DEFAULT_DOWNLOAD_FILE
    E_SECTION_STACK_USAGE_RESULTS = _connect.CTestGroupResult_E_SECTION_STACK_USAGE_RESULTS
    E_SECTION_DIAGRAMS = _connect.CTestGroupResult_E_SECTION_DIAGRAMS
    E_MIN_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_MIN_TCS_FOR_FUNCTION
    E_AVG_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_AVG_TCS_FOR_FUNCTION
    E_MAX_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_MAX_TCS_FOR_FUNCTION
    E_FUNCTIONS_W_TEST_CASES = _connect.CTestGroupResult_E_FUNCTIONS_W_TEST_CASES
    E_MODULES_W_TEST_CASES = _connect.CTestGroupResult_E_MODULES_W_TEST_CASES
    E_PARTITIONS_W_TEST_CASES = _connect.CTestGroupResult_E_PARTITIONS_W_TEST_CASES
    E_SCRIPT_ERRORS = _connect.CTestGroupResult_E_SCRIPT_ERRORS
    E_SCRIPT_OUTPUT = _connect.CTestGroupResult_E_SCRIPT_OUTPUT
    E_TCS_PER_MODULE = _connect.CTestGroupResult_E_TCS_PER_MODULE
    E_TCS_PER_PARTITION = _connect.CTestGroupResult_E_TCS_PER_PARTITION
    E_CVRG_DOCUMENT = _connect.CTestGroupResult_E_CVRG_DOCUMENT
    E_CVRG_EXPORT_FILE = _connect.CTestGroupResult_E_CVRG_EXPORT_FILE
    E_CVRG_STAT_FOR_ALL_ITEMS = _connect.CTestGroupResult_E_CVRG_STAT_FOR_ALL_ITEMS
    E_CVRG_STAT_FOR_TESTED_ITEMS = _connect.CTestGroupResult_E_CVRG_STAT_FOR_TESTED_ITEMS
    E_SRC_LINE_CVRG = _connect.CTestGroupResult_E_SRC_LINE_CVRG
    E_FUNC_STATS = _connect.CTestGroupResult_E_FUNC_STATS

    def __init__(self, *args):
        this = _connect.new_CTestGroupResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestGroupResult
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestGroupResult_createInstance(self, parent)

    def isMerged(self) -> "bool":
        return _connect.CTestGroupResult_isMerged(self)
    if _newclass:
        cast = staticmethod(_connect.CTestGroupResult_cast)
    else:
        cast = _connect.CTestGroupResult_cast

    def isException(self) -> "bool":
        return _connect.CTestGroupResult_isException(self)

    def getExceptionString(self) -> "std::string":
        return _connect.CTestGroupResult_getExceptionString(self)

    def isError(self) -> "bool":
        return _connect.CTestGroupResult_isError(self)

    def isErrorInChildTestCases(self) -> "bool":
        return _connect.CTestGroupResult_isErrorInChildTestCases(self)

    def isChildGroupError(self) -> "bool":
        return _connect.CTestGroupResult_isChildGroupError(self)

    def getIntValue(self, section: 'isys::CTestGroupResult::EGroupResultSection') -> "int":
        return _connect.CTestGroupResult_getIntValue(self, section)

    def getResultComment(self) -> "std::string":
        return _connect.CTestGroupResult_getResultComment(self)

    def getDefaultDownloadFile(self) -> "std::string":
        return _connect.CTestGroupResult_getDefaultDownloadFile(self)

    def getStackUsageResult(self, isConst: 'bool') -> "isys::CStackUsageResultSPtr":
        return _connect.CTestGroupResult_getStackUsageResult(self, isConst)

    def getCoverageResultForTestedCode(self, isConst: 'bool') -> "isys::CTestCoverageResultSPtr":
        return _connect.CTestGroupResult_getCoverageResultForTestedCode(self, isConst)

    def getCoverageResultForAllCode(self, isConst: 'bool') -> "isys::CTestCoverageResultSPtr":
        return _connect.CTestGroupResult_getCoverageResultForAllCode(self, isConst)

    def getFunctionStatList(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestGroupResult_getFunctionStatList(self, isConst)

    def isScriptError(self, *args) -> "bool":
        return _connect.CTestGroupResult_isScriptError(self, *args)

    def isStackUsageError(self) -> "bool":
        return _connect.CTestGroupResult_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType: 'std::string const &') -> "std::string":
        return _connect.CTestGroupResult_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType: 'std::string const &') -> "std::string":
        return _connect.CTestGroupResult_getScriptOutput(self, scriptFunctionType)

    def getFailedSections(self) -> "std::string":
        return _connect.CTestGroupResult_getFailedSections(self)

    def appendScriptError(self, scriptFunctionType: 'std::string const &', errorDesc: 'std::string const &') -> "void":
        return _connect.CTestGroupResult_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType: 'std::string const &', outStr: 'std::string const &') -> "void":
        return _connect.CTestGroupResult_appendScriptOutput(self, scriptFunctionType, outStr)

    def toUIString(self) -> "std::string":
        return _connect.CTestGroupResult_toUIString(self)
CTestGroupResult_swigregister = _connect.CTestGroupResult_swigregister
CTestGroupResult_swigregister(CTestGroupResult)

def CTestGroupResult_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestGroupResultSPtr":
    return _connect.CTestGroupResult_cast(testBase)
CTestGroupResult_cast = _connect.CTestGroupResult_cast

class CTestGrpFuncStat(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestGrpFuncStat, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestGrpFuncStat, name)
    __repr__ = _swig_repr
    E_QUAL_FUNC_NAME = _connect.CTestGrpFuncStat_E_QUAL_FUNC_NAME
    E_TESTS_PASSED = _connect.CTestGrpFuncStat_E_TESTS_PASSED
    E_TESTS_FAILED = _connect.CTestGrpFuncStat_E_TESTS_FAILED
    E_TESTS_ERROR = _connect.CTestGrpFuncStat_E_TESTS_ERROR
    E_CVRG_BYTES_ALL = _connect.CTestGrpFuncStat_E_CVRG_BYTES_ALL
    E_CVRG_BYTES_EXECUTED = _connect.CTestGrpFuncStat_E_CVRG_BYTES_EXECUTED
    E_CVRG_COND_ALL = _connect.CTestGrpFuncStat_E_CVRG_COND_ALL
    E_CVRG_COND_FALSE = _connect.CTestGrpFuncStat_E_CVRG_COND_FALSE
    E_CVRG_COND_TRUE = _connect.CTestGrpFuncStat_E_CVRG_COND_TRUE
    E_CVRG_COND_BOTH = _connect.CTestGrpFuncStat_E_CVRG_COND_BOTH
    E_CVRG_EXECUTION_COUNT = _connect.CTestGrpFuncStat_E_CVRG_EXECUTION_COUNT

    def __init__(self, *args):
        this = _connect.new_CTestGrpFuncStat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestGrpFuncStat_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestGrpFuncStat_cast)
    else:
        cast = _connect.CTestGrpFuncStat_cast

    def getNoOfTestCases(self) -> "int":
        return _connect.CTestGrpFuncStat_getNoOfTestCases(self)

    def getQualFuncName(self) -> "std::string":
        return _connect.CTestGrpFuncStat_getQualFuncName(self)

    def getCoverage(self, section: 'isys::CTestGrpFuncStat::ESectionFuncTestStats') -> "int":
        return _connect.CTestGrpFuncStat_getCoverage(self, section)
    __swig_destroy__ = _connect.delete_CTestGrpFuncStat
    __del__ = lambda self: None
CTestGrpFuncStat_swigregister = _connect.CTestGrpFuncStat_swigregister
CTestGrpFuncStat_swigregister(CTestGrpFuncStat)

def CTestGrpFuncStat_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestGrpFuncStatSPtr":
    return _connect.CTestGrpFuncStat_cast(testBase)
CTestGrpFuncStat_cast = _connect.CTestGrpFuncStat_cast

class IEmitter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEmitter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEmitter, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ETestReportConfig = _connect.IEmitter_ETestReportConfig
    ETestReportStatistics = _connect.IEmitter_ETestReportStatistics
    ETestReport = _connect.IEmitter_ETestReport
    LINE_NUM_NOT_SET = _connect.IEmitter_LINE_NUM_NOT_SET
    EYAML_ANY_STYLE = _connect.IEmitter_EYAML_ANY_STYLE
    EYAML_FLOW_STYLE = _connect.IEmitter_EYAML_FLOW_STYLE
    EYAML_BLOCK_STYLE = _connect.IEmitter_EYAML_BLOCK_STYLE

    def getIndent(self) -> "std::string":
        return _connect.IEmitter_getIndent(self)

    def setIndent(self, indent: 'std::string const &') -> "void":
        return _connect.IEmitter_setIndent(self, indent)

    def getLineNumber(self) -> "int":
        return _connect.IEmitter_getLineNumber(self)

    def getRow(self, row: 'StrVector', rowIndex: 'int') -> "void":
        return _connect.IEmitter_getRow(self, row, rowIndex)

    def setLineNumber(self, lineNumber: 'int') -> "void":
        return _connect.IEmitter_setLineNumber(self, lineNumber)

    def startStream(self, *args) -> "void":
        return _connect.IEmitter_startStream(self, *args)

    def endStream(self) -> "void":
        return _connect.IEmitter_endStream(self)

    def startDocument(self, implicit: 'bool') -> "void":
        return _connect.IEmitter_startDocument(self, implicit)

    def endDocument(self, implicit: 'bool') -> "void":
        return _connect.IEmitter_endDocument(self, implicit)

    def escapeSpecialChars(self, data: 'std::string const &') -> "std::string":
        return _connect.IEmitter_escapeSpecialChars(self, data)

    def flush(self) -> "void":
        return _connect.IEmitter_flush(self)

    def mapStart(self, *args) -> "void":
        return _connect.IEmitter_mapStart(self, *args)

    def writeMapEnd(self) -> "void":
        return _connect.IEmitter_writeMapEnd(self)

    def mapEnd(self) -> "void":
        return _connect.IEmitter_mapEnd(self)

    def sequenceStart(self, *args) -> "void":
        return _connect.IEmitter_sequenceStart(self, *args)

    def sequenceEnd(self) -> "void":
        return _connect.IEmitter_sequenceEnd(self)

    def writeSequenceEnd(self) -> "void":
        return _connect.IEmitter_writeSequenceEnd(self)

    def writeString(self, yamlData: 'std::string const &') -> "void":
        return _connect.IEmitter_writeString(self, yamlData)

    def writeText(self, text: 'std::string const &') -> "void":
        return _connect.IEmitter_writeText(self, text)
    __swig_destroy__ = _connect.delete_IEmitter
    __del__ = lambda self: None
IEmitter_swigregister = _connect.IEmitter_swigregister
IEmitter_swigregister(IEmitter)

class IStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def write(self, str: 'std::string const &') -> "void":
        return _connect.IStream_write(self, str)

    def close(self) -> "void":
        return _connect.IStream_close(self)
    __swig_destroy__ = _connect.delete_IStream
    __del__ = lambda self: None
IStream_swigregister = _connect.IStream_swigregister
IStream_swigregister(IStream)

class CStringStream(IStream):
    __swig_setmethods__ = {}
    for _s in [IStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CStringStream, name, value)
    __swig_getmethods__ = {}
    for _s in [IStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CStringStream, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CStringStream()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def write(self, str: 'std::string const &') -> "void":
        return _connect.CStringStream_write(self, str)

    def close(self) -> "void":
        return _connect.CStringStream_close(self)

    def getString(self) -> "std::string":
        return _connect.CStringStream_getString(self)
    __swig_destroy__ = _connect.delete_CStringStream
    __del__ = lambda self: None
CStringStream_swigregister = _connect.CStringStream_swigregister
CStringStream_swigregister(CStringStream)

class CFileStream(IStream):
    __swig_setmethods__ = {}
    for _s in [IStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CFileStream, name, value)
    __swig_getmethods__ = {}
    for _s in [IStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CFileStream, name)
    __repr__ = _swig_repr

    def __init__(self, fileName: 'std::string const &', isAppend: 'bool'=False):
        this = _connect.new_CFileStream(fileName, isAppend)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def write(self, str: 'std::string const &') -> "void":
        return _connect.CFileStream_write(self, str)

    def close(self) -> "void":
        return _connect.CFileStream_close(self)
    __swig_destroy__ = _connect.delete_CFileStream
    __del__ = lambda self: None
CFileStream_swigregister = _connect.CFileStream_swigregister
CFileStream_swigregister(CFileStream)

class EmitterFactory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmitterFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EmitterFactory, name)
    __repr__ = _swig_repr
    if _newclass:
        createYamlEmitter = staticmethod(_connect.EmitterFactory_createYamlEmitter)
    else:
        createYamlEmitter = _connect.EmitterFactory_createYamlEmitter
    if _newclass:
        createCSVEmitter = staticmethod(_connect.EmitterFactory_createCSVEmitter)
    else:
        createCSVEmitter = _connect.EmitterFactory_createCSVEmitter

    def __init__(self):
        this = _connect.new_EmitterFactory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_EmitterFactory
    __del__ = lambda self: None
EmitterFactory_swigregister = _connect.EmitterFactory_swigregister
EmitterFactory_swigregister(EmitterFactory)

def EmitterFactory_createYamlEmitter(stream: 'isys::IStreamSPtr &') -> "isys::IEmitterSPtr":
    return _connect.EmitterFactory_createYamlEmitter(stream)
EmitterFactory_createYamlEmitter = _connect.EmitterFactory_createYamlEmitter

def EmitterFactory_createCSVEmitter(fileStream: 'isys::IStreamSPtr &', separator: 'std::string const &', isHeaderLine: 'bool') -> "isys::IEmitterSPtr":
    return _connect.EmitterFactory_createCSVEmitter(fileStream, separator, isHeaderLine)
EmitterFactory_createCSVEmitter = _connect.EmitterFactory_createCSVEmitter

class CTestSpecification(CTestTreeNode):
    __swig_setmethods__ = {}
    for _s in [CTestTreeNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestSpecification, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestTreeNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestSpecification, name)
    __repr__ = _swig_repr
    E_SECTION_ID = _connect.CTestSpecification_E_SECTION_ID
    E_SECTION_TEST_SCOPE = _connect.CTestSpecification_E_SECTION_TEST_SCOPE
    E_SECTION_BASE_ID = _connect.CTestSpecification_E_SECTION_BASE_ID
    E_SECTION_RUN = _connect.CTestSpecification_E_SECTION_RUN
    E_SECTION_IMPORTS = _connect.CTestSpecification_E_SECTION_IMPORTS
    E_SECTION_DESC = _connect.CTestSpecification_E_SECTION_DESC
    E_SECTION_TAGS = _connect.CTestSpecification_E_SECTION_TAGS
    E_SECTION_OPTIONS = _connect.CTestSpecification_E_SECTION_OPTIONS
    E_SECTION_PERSIST_VARS = _connect.CTestSpecification_E_SECTION_PERSIST_VARS
    E_SECTION_LOCALS = _connect.CTestSpecification_E_SECTION_LOCALS
    E_SECTION_INIT = _connect.CTestSpecification_E_SECTION_INIT
    E_SECTION_BEGIN_STOP_CONDITION = _connect.CTestSpecification_E_SECTION_BEGIN_STOP_CONDITION
    E_SECTION_END_STOP_CONDITION = _connect.CTestSpecification_E_SECTION_END_STOP_CONDITION
    E_SECTION_FUNC = _connect.CTestSpecification_E_SECTION_FUNC
    E_SECTION_TIMEOUT = _connect.CTestSpecification_E_SECTION_TIMEOUT
    E_SECTION_CORE_ID = _connect.CTestSpecification_E_SECTION_CORE_ID
    E_SECTION_INIT_TARGET = _connect.CTestSpecification_E_SECTION_INIT_TARGET
    E_SECTION_INITFUNC = _connect.CTestSpecification_E_SECTION_INITFUNC
    E_SECTION_ENDFUNC = _connect.CTestSpecification_E_SECTION_ENDFUNC
    E_SECTION_RESTORE_TARGET = _connect.CTestSpecification_E_SECTION_RESTORE_TARGET
    E_SECTION_STUBS = _connect.CTestSpecification_E_SECTION_STUBS
    E_SECTION_USER_STUBS = _connect.CTestSpecification_E_SECTION_USER_STUBS
    E_SECTION_TEST_POINTS = _connect.CTestSpecification_E_SECTION_TEST_POINTS
    E_SECTION_PRE_CONDITION = _connect.CTestSpecification_E_SECTION_PRE_CONDITION
    E_SECTION_ASSERT = _connect.CTestSpecification_E_SECTION_ASSERT
    E_SECTION_STACK_USAGE = _connect.CTestSpecification_E_SECTION_STACK_USAGE
    E_SECTION_LOG = _connect.CTestSpecification_E_SECTION_LOG
    E_SECTION_ANALYZER = _connect.CTestSpecification_E_SECTION_ANALYZER
    E_SECTION_HIL = _connect.CTestSpecification_E_SECTION_HIL
    E_SECTION_DRY_RUN = _connect.CTestSpecification_E_SECTION_DRY_RUN
    E_SECTION_DIAGRAMS = _connect.CTestSpecification_E_SECTION_DIAGRAMS
    E_SECTION_TESTS = _connect.CTestSpecification_E_SECTION_TESTS
    E_SECTION_PARAMS_PRIVATE = _connect.CTestSpecification_E_SECTION_PARAMS_PRIVATE
    E_SECTION_TRACE = _connect.CTestSpecification_E_SECTION_TRACE
    E_SECTION_COVERAGE = _connect.CTestSpecification_E_SECTION_COVERAGE
    E_SECTION_PROFILER = _connect.CTestSpecification_E_SECTION_PROFILER
    E_SECTION_EXPECT = _connect.CTestSpecification_E_SECTION_EXPECT
    E_UNIT_TEST = _connect.CTestSpecification_E_UNIT_TEST
    E_SYSTEM_TEST = _connect.CTestSpecification_E_SYSTEM_TEST

    def __init__(self, *args):
        this = _connect.new_CTestSpecification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestSpecification
    __del__ = lambda self: None

    def getUILabel(self) -> "std::string":
        return _connect.CTestSpecification_getUILabel(self)

    def isGroup(self) -> "bool":
        return _connect.CTestSpecification_isGroup(self)

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestSpecification_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestSpecification_cast)
    else:
        cast = _connect.CTestSpecification_cast

    def assign(self, testSpec: 'isys::CTestObjectSPtr const &') -> "void":
        return _connect.CTestSpecification_assign(self, testSpec)

    def getContainerTestNode(self) -> "isys::CTestTreeNodeSPtr":
        return _connect.CTestSpecification_getContainerTestNode(self)

    def getParentTestSpecification(self) -> "isys::CTestSpecificationSPtr":
        return _connect.CTestSpecification_getParentTestSpecification(self)

    def getSourceLineNumber(self) -> "int":
        return _connect.CTestSpecification_getSourceLineNumber(self)

    def isMerged(self) -> "bool":
        return _connect.CTestSpecification_isMerged(self)

    def isTestSpecification(self) -> "bool":
        return _connect.CTestSpecification_isTestSpecification(self)

    def getCachedMergedTestSpec(self, *args) -> "isys::CTestBaseSPtr":
        return _connect.CTestSpecification_getCachedMergedTestSpec(self, *args)

    def setCachedMergedTestSpec(self, mergedTestSpec: 'isys::CTestSpecificationSPtr &') -> "void":
        return _connect.CTestSpecification_setCachedMergedTestSpec(self, mergedTestSpec)

    def getId(self) -> "std::string":
        return _connect.CTestSpecification_getId(self)

    def getTestId(self) -> "std::string":
        return _connect.CTestSpecification_getTestId(self)

    def getBaseId(self) -> "std::string":
        return _connect.CTestSpecification_getBaseId(self)

    def getRunFlag(self) -> "isys::ETristate":
        return _connect.CTestSpecification_getRunFlag(self)

    def getDescription(self) -> "std::string":
        return _connect.CTestSpecification_getDescription(self)

    def getTags(self, tags: 'StrVector') -> "void":
        return _connect.CTestSpecification_getTags(self, tags)

    def getTestScope(self) -> "isys::CTestSpecification::ETestScope":
        return _connect.CTestSpecification_getTestScope(self)

    def getFunctionUnderTest(self, isConst: 'bool') -> "isys::CTestFunctionSPtr":
        return _connect.CTestSpecification_getFunctionUnderTest(self, isConst)

    def getTestTimeout(self) -> "int":
        return _connect.CTestSpecification_getTestTimeout(self)

    def getCoreId(self) -> "std::string":
        return _connect.CTestSpecification_getCoreId(self)

    def getPositionParams(self, params: 'StrVector') -> "void":
        return _connect.CTestSpecification_getPositionParams(self, params)

    def hasPositionParams(self) -> "bool":
        return _connect.CTestSpecification_hasPositionParams(self)

    def getInitFunction(self, isConst: 'bool') -> "isys::CTestFunctionSPtr":
        return _connect.CTestSpecification_getInitFunction(self, isConst)

    def getEndFunction(self, isConst: 'bool') -> "isys::CTestFunctionSPtr":
        return _connect.CTestSpecification_getEndFunction(self, isConst)

    def getInitTargetFunction(self, isConst: 'bool') -> "isys::CTestFunctionSPtr":
        return _connect.CTestSpecification_getInitTargetFunction(self, isConst)

    def getRestoreTargetFunction(self, isConst: 'bool') -> "isys::CTestFunctionSPtr":
        return _connect.CTestSpecification_getRestoreTargetFunction(self, isConst)

    def getStubs(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestSpecification_getStubs(self, isConst)

    def getStub(self, functionName: 'std::string const &') -> "isys::CTestStubSPtr":
        return _connect.CTestSpecification_getStub(self, functionName)

    def getUserStubs(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestSpecification_getUserStubs(self, isConst)

    def getUserStub(self, functionName: 'std::string const &') -> "isys::CTestUserStubSPtr":
        return _connect.CTestSpecification_getUserStub(self, functionName)

    def getTestPoints(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestSpecification_getTestPoints(self, isConst)

    def getTestPoint(self, testPointId: 'std::string const &') -> "isys::CTestPointSPtr":
        return _connect.CTestSpecification_getTestPoint(self, testPointId)

    def getTestPointIdx(self, testPointId: 'std::string const &') -> "int":
        return _connect.CTestSpecification_getTestPointIdx(self, testPointId)

    def assignTestPoints(self, src: 'isys::CTestSpecificationSPtr const &') -> "void":
        return _connect.CTestSpecification_assignTestPoints(self, src)

    def removeStub(self, *args) -> "int":
        return _connect.CTestSpecification_removeStub(self, *args)

    def assignStubs(self, src: 'isys::CTestSpecificationSPtr const &') -> "void":
        return _connect.CTestSpecification_assignStubs(self, src)

    def removeUserStub(self, functionName: 'std::string const &') -> "int":
        return _connect.CTestSpecification_removeUserStub(self, functionName)

    def assignUserStubs(self, src: 'isys::CTestSpecificationSPtr const &') -> "void":
        return _connect.CTestSpecification_assignUserStubs(self, src)

    def assignOptions(self, src: 'CTestSpecification') -> "void":
        return _connect.CTestSpecification_assignOptions(self, src)

    def getLocalVariables(self, localVars: 'StrStrMap') -> "void":
        return _connect.CTestSpecification_getLocalVariables(self, localVars)

    def getLocalVariablesKeys(self, vars: 'StrVector') -> "void":
        return _connect.CTestSpecification_getLocalVariablesKeys(self, vars)

    def getInitKeys(self, *args) -> "void":
        return _connect.CTestSpecification_getInitKeys(self, *args)

    def getInitValues(self, values: 'StrVector') -> "void":
        return _connect.CTestSpecification_getInitValues(self, values)

    def getInitMap(self, initMap: 'StrStrMap') -> "void":
        return _connect.CTestSpecification_getInitMap(self, initMap)

    def getExpectedResults(self, expectedResults: 'StrVector') -> "void":
        return _connect.CTestSpecification_getExpectedResults(self, expectedResults)

    def getPrecondition(self, isConst: 'bool') -> "isys::CTestAssertSPtr":
        return _connect.CTestSpecification_getPrecondition(self, isConst)

    def getAssert(self, isConst: 'bool') -> "isys::CTestAssertSPtr":
        return _connect.CTestSpecification_getAssert(self, isConst)

    def getLog(self, isConst: 'bool') -> "isys::CTestLogSPtr":
        return _connect.CTestSpecification_getLog(self, isConst)

    def getAnalyzer(self, isConst: 'bool') -> "isys::CTestAnalyzerSPtr":
        return _connect.CTestSpecification_getAnalyzer(self, isConst)

    def getTrace(self, isConst: 'bool') -> "isys::CTestAnalyzerTraceSPtr":
        return _connect.CTestSpecification_getTrace(self, isConst)

    def getCoverage(self, isConst: 'bool') -> "isys::CTestAnalyzerCoverageSPtr":
        return _connect.CTestSpecification_getCoverage(self, isConst)

    def getProfiler(self, isConst: 'bool') -> "isys::CTestAnalyzerProfilerSPtr":
        return _connect.CTestSpecification_getProfiler(self, isConst)

    def getHIL(self, isConst: 'bool') -> "isys::CTestHILSPtr":
        return _connect.CTestSpecification_getHIL(self, isConst)

    def getDryRun(self, isConst: 'bool') -> "isys::CTestDryRunSPtr":
        return _connect.CTestSpecification_getDryRun(self, isConst)

    def getStackUsage(self, isConst: 'bool') -> "isys::CTestStackUsageSPtr":
        return _connect.CTestSpecification_getStackUsage(self, isConst)

    def getPersistentVars(self, isConst: 'bool') -> "isys::CTestPersistentVarsSPtr":
        return _connect.CTestSpecification_getPersistentVars(self, isConst)

    def getOptionKeys(self, *args) -> "void":
        return _connect.CTestSpecification_getOptionKeys(self, *args)

    def getOptionValues(self, values: 'StrVector') -> "void":
        return _connect.CTestSpecification_getOptionValues(self, values)

    def getImports(self, isConst: 'bool') -> "isys::CTestImportsSPtr":
        return _connect.CTestSpecification_getImports(self, isConst)

    def getBeginStopCondition(self, isConst: 'bool') -> "isys::CTestStopConditionSPtr":
        return _connect.CTestSpecification_getBeginStopCondition(self, isConst)

    def getEndStopCondition(self, isConst: 'bool') -> "isys::CTestStopConditionSPtr":
        return _connect.CTestSpecification_getEndStopCondition(self, isConst)

    def getDiagrams(self, isConst: 'bool') -> "isys::CTestDiagramsSPtr":
        return _connect.CTestSpecification_getDiagrams(self, isConst)

    def hasChildren(self) -> "bool":
        return _connect.CTestSpecification_hasChildren(self)

    def getChildren(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestSpecification_getChildren(self, isConst)

    def getNoOfDerivedSpecs(self) -> "int":
        return _connect.CTestSpecification_getNoOfDerivedSpecs(self)

    def getDerivedTestSpec(self, idx: 'int') -> "isys::CTestSpecificationSPtr":
        return _connect.CTestSpecification_getDerivedTestSpec(self, idx)

    def findDerivedTestSpec(self, *args) -> "isys::CTestSpecificationSPtr":
        return _connect.CTestSpecification_findDerivedTestSpec(self, *args)

    def addDerivedTestSpec(self, idx: 'int', testSpec: 'isys::CTestSpecificationSPtr') -> "void":
        return _connect.CTestSpecification_addDerivedTestSpec(self, idx, testSpec)

    def addChildAndSetParent(self, idx: 'int', testSpec: 'isys::CTestTreeNodeSPtr const &') -> "void":
        return _connect.CTestSpecification_addChildAndSetParent(self, idx, testSpec)

    def deleteAllDerivedTestSpecs(self) -> "void":
        return _connect.CTestSpecification_deleteAllDerivedTestSpecs(self)

    def deleteDerivedTestSpec(self, idx: 'int') -> "void":
        return _connect.CTestSpecification_deleteDerivedTestSpec(self, idx)

    def deleteChild(self, child: 'isys::CTestTreeNodeSPtr const &') -> "int":
        return _connect.CTestSpecification_deleteChild(self, child)

    def getWarnings(self) -> "std::string":
        return _connect.CTestSpecification_getWarnings(self)

    def serializeMember(self, emitter: 'isys::IEmitterSPtr', section: 'isys::CTestSpecification::SectionIds') -> "void":
        return _connect.CTestSpecification_serializeMember(self, emitter, section)

    def isEmptyExceptDerived(self) -> "bool":
        return _connect.CTestSpecification_isEmptyExceptDerived(self)

    def merge(self) -> "isys::CTestSpecificationSPtr":
        return _connect.CTestSpecification_merge(self)

    def getMergedTestScope(self) -> "isys::CTestSpecification::ETestScope":
        return _connect.CTestSpecification_getMergedTestScope(self)

    def isSectionEmpty(self, sectionId: 'isys::CTestSpecification::SectionIds') -> "bool":
        return _connect.CTestSpecification_isSectionEmpty(self, sectionId)

    def isSectionMerged(self, sectionId: 'isys::CTestSpecification::SectionIds') -> "bool":
        return _connect.CTestSpecification_isSectionMerged(self, sectionId)

    def isInheritSection(self, sectionId: 'isys::CTestSpecification::SectionIds') -> "bool":
        return _connect.CTestSpecification_isInheritSection(self, sectionId)

    def setMainMapStyle(self, mappingStyle: 'isys::IEmitter::EYamlStyle') -> "void":
        return _connect.CTestSpecification_setMainMapStyle(self, mappingStyle)

    def setTestId(self, testId: 'std::string const &') -> "void":
        return _connect.CTestSpecification_setTestId(self, testId)

    def setBaseId(self, testId: 'std::string const &') -> "void":
        return _connect.CTestSpecification_setBaseId(self, testId)

    def setRunFlag(self, isRun: 'isys::ETristate') -> "void":
        return _connect.CTestSpecification_setRunFlag(self, isRun)

    def setDescription(self, description: 'std::string const &') -> "void":
        return _connect.CTestSpecification_setDescription(self, description)

    def setTags(self, *args) -> "void":
        return _connect.CTestSpecification_setTags(self, *args)

    def setTestScope(self, testType: 'isys::CTestSpecification::ETestScope') -> "void":
        return _connect.CTestSpecification_setTestScope(self, testType)

    def setLocalVariables(self, yamlSpec: 'std::string const &') -> "void":
        return _connect.CTestSpecification_setLocalVariables(self, yamlSpec)

    def setInitValues(self, yamlSpec: 'std::string const &') -> "void":
        return _connect.CTestSpecification_setInitValues(self, yamlSpec)

    def setExpectedResults(self, expectedResults: 'StrVector') -> "void":
        return _connect.CTestSpecification_setExpectedResults(self, expectedResults)

    def setIdeOptions(self, yamlSpec: 'std::string const &') -> "void":
        return _connect.CTestSpecification_setIdeOptions(self, yamlSpec)

    def setTestTimeout(self, timeout: 'int') -> "void":
        return _connect.CTestSpecification_setTestTimeout(self, timeout)

    def setCoreId(self, coreId: 'std::string const &') -> "void":
        return _connect.CTestSpecification_setCoreId(self, coreId)

    def validate(self) -> "std::string":
        return _connect.CTestSpecification_validate(self)

    def getNoOfTests(self, isSkipAbstractTests: 'bool') -> "int":
        return _connect.CTestSpecification_getNoOfTests(self, isSkipAbstractTests)

    def clearEmptySections(self) -> "void":
        return _connect.CTestSpecification_clearEmptySections(self)

    def save(self, fileName: 'std::string const &', isAppend: 'bool'=False) -> "void":
        return _connect.CTestSpecification_save(self, fileName, isAppend)
    if _newclass:
        load = staticmethod(_connect.CTestSpecification_load)
    else:
        load = _connect.CTestSpecification_load
    if _newclass:
        parseTestSpec = staticmethod(_connect.CTestSpecification_parseTestSpec)
    else:
        parseTestSpec = _connect.CTestSpecification_parseTestSpec

    def clearMergedFilterInfo(self, isClearRecursively: 'bool') -> "void":
        return _connect.CTestSpecification_clearMergedFilterInfo(self, isClearRecursively)
CTestSpecification_swigregister = _connect.CTestSpecification_swigregister
CTestSpecification_swigregister(CTestSpecification)

def CTestSpecification_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestSpecificationSPtr":
    return _connect.CTestSpecification_cast(testBase)
CTestSpecification_cast = _connect.CTestSpecification_cast

def CTestSpecification_load(fileName: 'std::string const &', filePos: 'size_t'=0) -> "isys::CTestSpecificationSPtr":
    return _connect.CTestSpecification_load(fileName, filePos)
CTestSpecification_load = _connect.CTestSpecification_load

def CTestSpecification_parseTestSpec(yamlSpec: 'std::string const &') -> "isys::CTestSpecificationSPtr":
    return _connect.CTestSpecification_parseTestSpec(yamlSpec)
CTestSpecification_parseTestSpec = _connect.CTestSpecification_parseTestSpec

class CTestStub(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestStub, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestStub, name)
    __repr__ = _swig_repr
    E_SECTION_STUBBED_FUNC = _connect.CTestStub_E_SECTION_STUBBED_FUNC
    E_SECTION_IS_ACTIVE = _connect.CTestStub_E_SECTION_IS_ACTIVE
    E_SECTION_IS_CUSTOM_ACTIVATION = _connect.CTestStub_E_SECTION_IS_CUSTOM_ACTIVATION
    E_SECTION_PARAM_NAMES = _connect.CTestStub_E_SECTION_PARAM_NAMES
    E_SECTION_RET_VAL_NAME = _connect.CTestStub_E_SECTION_RET_VAL_NAME
    E_SECTION_SCRIPT_FUNCTION = _connect.CTestStub_E_SECTION_SCRIPT_FUNCTION
    E_SECTION_HIT_LIMITS = _connect.CTestStub_E_SECTION_HIT_LIMITS
    E_SECTION_LOG = _connect.CTestStub_E_SECTION_LOG
    E_SECTION_ASSIGN_STEPS = _connect.CTestStub_E_SECTION_ASSIGN_STEPS
    E_SECTION_FUNC = _connect.CTestStub_E_SECTION_FUNC
    E_SECTION_ASSIGN = _connect.CTestStub_E_SECTION_ASSIGN
    E_SECTION_SCRIPT = _connect.CTestStub_E_SECTION_SCRIPT

    def __init__(self, *args):
        this = _connect.new_CTestStub(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestStub
    __del__ = lambda self: None

    def createInstance(self, *args) -> "void":
        return _connect.CTestStub_createInstance(self, *args)
    if _newclass:
        cast = staticmethod(_connect.CTestStub_cast)
    else:
        cast = _connect.CTestStub_cast

    def isMerged(self) -> "bool":
        return _connect.CTestStub_isMerged(self)

    def getFunctionName(self) -> "std::string":
        return _connect.CTestStub_getFunctionName(self)

    def isActive(self) -> "bool":
        return _connect.CTestStub_isActive(self)

    def getActive(self) -> "isys::ETristate":
        return _connect.CTestStub_getActive(self)

    def isCustomActivation(self) -> "bool":
        return _connect.CTestStub_isCustomActivation(self)

    def getRetValName(self) -> "std::string":
        return _connect.CTestStub_getRetValName(self)

    def getParamNames(self, params: 'StrVector') -> "void":
        return _connect.CTestStub_getParamNames(self, params)

    def getScriptFunctionName(self) -> "std::string":
        return _connect.CTestStub_getScriptFunctionName(self)

    def getLogConfig(self, isConst: 'bool') -> "isys::CTestLogSPtr":
        return _connect.CTestStub_getLogConfig(self, isConst)

    def getHitLimits(self, isConst: 'bool') -> "isys::CTestMinMaxSPtr":
        return _connect.CTestStub_getHitLimits(self, isConst)

    def getAssignmentSteps(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestStub_getAssignmentSteps(self, isConst)

    def setFunctionName(self, functionName: 'std::string const &') -> "void":
        return _connect.CTestStub_setFunctionName(self, functionName)

    def setActive(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CTestStub_setActive(self, isActive)

    def setCustomActivation(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CTestStub_setCustomActivation(self, isActive)

    def setRetValName(self, retValName: 'std::string const &') -> "void":
        return _connect.CTestStub_setRetValName(self, retValName)

    def setScriptFunctionName(self, scriptFuncName: 'std::string const &') -> "void":
        return _connect.CTestStub_setScriptFunctionName(self, scriptFuncName)
CTestStub_swigregister = _connect.CTestStub_swigregister
CTestStub_swigregister(CTestStub)

def CTestStub_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestStubSPtr":
    return _connect.CTestStub_cast(testBase)
CTestStub_cast = _connect.CTestStub_cast

class CTestLocation(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestLocation, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestLocation, name)
    __repr__ = _swig_repr
    E_SECTION_RESOURCE_TYPE = _connect.CTestLocation_E_SECTION_RESOURCE_TYPE
    E_SECTION_RESOURCE_NAME = _connect.CTestLocation_E_SECTION_RESOURCE_NAME
    E_SECTION_SRC_FILE_LOCATION = _connect.CTestLocation_E_SECTION_SRC_FILE_LOCATION
    E_SECTION_LINE = _connect.CTestLocation_E_SECTION_LINE
    E_SECTION_IS_SEARCH = _connect.CTestLocation_E_SECTION_IS_SEARCH
    E_SECTION_LINES_RANGE = _connect.CTestLocation_E_SECTION_LINES_RANGE
    E_SECTION_SEARCH_CONTEXT = _connect.CTestLocation_E_SECTION_SEARCH_CONTEXT
    E_SECTION_MATCH_TYPE = _connect.CTestLocation_E_SECTION_MATCH_TYPE
    E_SECTION_PATTERN = _connect.CTestLocation_E_SECTION_PATTERN
    E_SECTION_LINE_OFFSET = _connect.CTestLocation_E_SECTION_LINE_OFFSET
    E_SECTION_NUM_STEPS = _connect.CTestLocation_E_SECTION_NUM_STEPS

    def __init__(self, *args):
        this = _connect.new_CTestLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestLocation
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestLocation_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestLocation_cast)
    else:
        cast = _connect.CTestLocation_cast

    def getRuntimeLocation(self) -> "std::string":
        return _connect.CTestLocation_getRuntimeLocation(self)

    def isMerged(self) -> "bool":
        return _connect.CTestLocation_isMerged(self)

    def getResourceType(self) -> "isys::CLineDescription::EResourceType":
        return _connect.CTestLocation_getResourceType(self)

    def getResourceName(self) -> "std::string":
        return _connect.CTestLocation_getResourceName(self)

    def getSrcFileLocation(self) -> "isys::CLineDescription::EFileLocation":
        return _connect.CTestLocation_getSrcFileLocation(self)

    def getLine(self) -> "int":
        return _connect.CTestLocation_getLine(self)

    def isSearch(self) -> "isys::ETristate":
        return _connect.CTestLocation_isSearch(self)

    def getLinesRange(self) -> "int":
        return _connect.CTestLocation_getLinesRange(self)

    def getSearchContext(self) -> "isys::CLineDescription::ESearchContext":
        return _connect.CTestLocation_getSearchContext(self)

    def getMatchingType(self) -> "isys::CLineDescription::EMatchingType":
        return _connect.CTestLocation_getMatchingType(self)

    def getSearchPattern(self) -> "std::string":
        return _connect.CTestLocation_getSearchPattern(self)

    def getLineOffset(self) -> "int":
        return _connect.CTestLocation_getLineOffset(self)

    def getNumSteps(self) -> "int":
        return _connect.CTestLocation_getNumSteps(self)

    def setRuntimeLocation(self, runtimeLocation: 'std::string const &') -> "void":
        return _connect.CTestLocation_setRuntimeLocation(self, runtimeLocation)

    def setResourceType(self, resourceType: 'isys::CLineDescription::EResourceType') -> "void":
        return _connect.CTestLocation_setResourceType(self, resourceType)

    def setResourceName(self, resourceName: 'std::string const &') -> "void":
        return _connect.CTestLocation_setResourceName(self, resourceName)

    def setSrcFileLocation(self, srcFileLoc: 'isys::CLineDescription::EFileLocation') -> "void":
        return _connect.CTestLocation_setSrcFileLocation(self, srcFileLoc)

    def setLine(self, lineNumber: 'int') -> "void":
        return _connect.CTestLocation_setLine(self, lineNumber)

    def setSearch(self, isSearch: 'isys::ETristate') -> "void":
        return _connect.CTestLocation_setSearch(self, isSearch)

    def setLinesRange(self, numLines: 'int') -> "void":
        return _connect.CTestLocation_setLinesRange(self, numLines)

    def setSearchContext(self, searchContext: 'isys::CLineDescription::ESearchContext') -> "void":
        return _connect.CTestLocation_setSearchContext(self, searchContext)

    def setMatchingType(self, matchingType: 'isys::CLineDescription::EMatchingType') -> "void":
        return _connect.CTestLocation_setMatchingType(self, matchingType)

    def setSearchPattern(self, searchPattern: 'std::string const &') -> "void":
        return _connect.CTestLocation_setSearchPattern(self, searchPattern)

    def setLineOffset(self, offset: 'int') -> "void":
        return _connect.CTestLocation_setLineOffset(self, offset)

    def setNumSteps(self, numSteps: 'int') -> "void":
        return _connect.CTestLocation_setNumSteps(self, numSteps)

    def validate(self) -> "std::string":
        return _connect.CTestLocation_validate(self)

    def getLineDescription(self) -> "isys::CLineDescriptionSPtr":
        return _connect.CTestLocation_getLineDescription(self)
CTestLocation_swigregister = _connect.CTestLocation_swigregister
CTestLocation_swigregister(CTestLocation)

def CTestLocation_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestLocationSPtr":
    return _connect.CTestLocation_cast(testBase)
CTestLocation_cast = _connect.CTestLocation_cast

class CTestPoint(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestPoint, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestPoint, name)
    __repr__ = _swig_repr
    E_SECTION_TEST_POINT_ID = _connect.CTestPoint_E_SECTION_TEST_POINT_ID
    E_SECTION_IS_ACTIVE = _connect.CTestPoint_E_SECTION_IS_ACTIVE
    E_SECTION_IS_CUSTOM_ACTIVATION = _connect.CTestPoint_E_SECTION_IS_CUSTOM_ACTIVATION
    E_SECTION_CONDITION_COUNT = _connect.CTestPoint_E_SECTION_CONDITION_COUNT
    E_SECTION_CONDITION_EXPR = _connect.CTestPoint_E_SECTION_CONDITION_EXPR
    E_SECTION_SCRIPT_FUNC = _connect.CTestPoint_E_SECTION_SCRIPT_FUNC
    E_SECTION_LOCATION = _connect.CTestPoint_E_SECTION_LOCATION
    E_SECTION_LOG = _connect.CTestPoint_E_SECTION_LOG
    E_SECTION_HIT_LIMITS = _connect.CTestPoint_E_SECTION_HIT_LIMITS
    E_SECTION_STEPS = _connect.CTestPoint_E_SECTION_STEPS

    def __init__(self, *args):
        this = _connect.new_CTestPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestPoint
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestPoint_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestPoint_cast)
    else:
        cast = _connect.CTestPoint_cast

    def isMerged(self) -> "bool":
        return _connect.CTestPoint_isMerged(self)

    def getId(self) -> "std::string const":
        return _connect.CTestPoint_getId(self)

    def isActive(self) -> "isys::ETristate":
        return _connect.CTestPoint_isActive(self)

    def isCustomActivation(self) -> "bool":
        return _connect.CTestPoint_isCustomActivation(self)

    def getConditionCount(self) -> "int":
        return _connect.CTestPoint_getConditionCount(self)

    def getConditionExpr(self) -> "std::string":
        return _connect.CTestPoint_getConditionExpr(self)

    def getScriptFunctionName(self) -> "std::string":
        return _connect.CTestPoint_getScriptFunctionName(self)

    def getLocation(self, isConst: 'bool') -> "isys::CTestLocationSPtr":
        return _connect.CTestPoint_getLocation(self, isConst)

    def getLogConfig(self, isConst: 'bool') -> "isys::CTestLogSPtr":
        return _connect.CTestPoint_getLogConfig(self, isConst)

    def getHitLimits(self, isConst: 'bool') -> "isys::CTestMinMaxSPtr":
        return _connect.CTestPoint_getHitLimits(self, isConst)

    def getSteps(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestPoint_getSteps(self, isConst)

    def setId(self, testPointId: 'std::string const &') -> "void":
        return _connect.CTestPoint_setId(self, testPointId)

    def setActive(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CTestPoint_setActive(self, isActive)

    def setCustomActivation(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CTestPoint_setCustomActivation(self, isActive)

    def setConditionCount(self, conditionCount: 'int') -> "void":
        return _connect.CTestPoint_setConditionCount(self, conditionCount)

    def setConditionExpr(self, expr: 'std::string const &') -> "void":
        return _connect.CTestPoint_setConditionExpr(self, expr)

    def setScriptFunc(self, scriptFunc: 'std::string const &') -> "void":
        return _connect.CTestPoint_setScriptFunc(self, scriptFunc)

    def validate(self) -> "std::string":
        return _connect.CTestPoint_validate(self)
CTestPoint_swigregister = _connect.CTestPoint_swigregister
CTestPoint_swigregister(CTestPoint)

def CTestPoint_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestPointSPtr":
    return _connect.CTestPoint_cast(testBase)
CTestPoint_cast = _connect.CTestPoint_cast

class CTestMinMax(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestMinMax, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestMinMax, name)
    __repr__ = _swig_repr
    E_SECTION_MIN = _connect.CTestMinMax_E_SECTION_MIN
    E_SECTION_MAX = _connect.CTestMinMax_E_SECTION_MAX

    def __init__(self, *args):
        this = _connect.new_CTestMinMax(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def createInstance(self, *args) -> "void":
        return _connect.CTestMinMax_createInstance(self, *args)
    if _newclass:
        cast = staticmethod(_connect.CTestMinMax_cast)
    else:
        cast = _connect.CTestMinMax_cast

    def isMerged(self) -> "bool":
        return _connect.CTestMinMax_isMerged(self)

    def getMin(self) -> "int":
        return _connect.CTestMinMax_getMin(self)

    def getMax(self) -> "int":
        return _connect.CTestMinMax_getMax(self)

    def setMin(self, value: 'int') -> "void":
        return _connect.CTestMinMax_setMin(self, value)

    def setMax(self, value: 'int') -> "void":
        return _connect.CTestMinMax_setMax(self, value)
    __swig_destroy__ = _connect.delete_CTestMinMax
    __del__ = lambda self: None
CTestMinMax_swigregister = _connect.CTestMinMax_swigregister
CTestMinMax_swigregister(CTestMinMax)

def CTestMinMax_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestMinMaxSPtr":
    return _connect.CTestMinMax_cast(testBase)
CTestMinMax_cast = _connect.CTestMinMax_cast

class CTestLog(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestLog, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestLog, name)
    __repr__ = _swig_repr
    E_SECTION_BEFORE = _connect.CTestLog_E_SECTION_BEFORE
    E_SECTION_AFTER = _connect.CTestLog_E_SECTION_AFTER

    def __init__(self, *args):
        this = _connect.new_CTestLog(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestLog
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestLog_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestLog_cast)
    else:
        cast = _connect.CTestLog_cast

    def isMerged(self) -> "bool":
        return _connect.CTestLog_isMerged(self)

    def getExpressions(self, section: 'isys::CTestLog::ESectionsLog', isConst: 'bool') -> "isys::CSequenceAdapter":
        return _connect.CTestLog_getExpressions(self, section, isConst)
CTestLog_swigregister = _connect.CTestLog_swigregister
CTestLog_swigregister(CTestLog)

def CTestLog_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestLogSPtr":
    return _connect.CTestLog_cast(testBase)
CTestLog_cast = _connect.CTestLog_cast

class CTestEvalAssignStep(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestEvalAssignStep, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestEvalAssignStep, name)
    __repr__ = _swig_repr
    E_SECTION_EXPECT = _connect.CTestEvalAssignStep_E_SECTION_EXPECT
    E_SECTION_ASSIGN = _connect.CTestEvalAssignStep_E_SECTION_ASSIGN
    E_SECTION_SCRIPT_PARAMS = _connect.CTestEvalAssignStep_E_SECTION_SCRIPT_PARAMS
    E_SECTION_NEXT_INDEX = _connect.CTestEvalAssignStep_E_SECTION_NEXT_INDEX

    def __init__(self, *args):
        this = _connect.new_CTestEvalAssignStep(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestEvalAssignStep
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestEvalAssignStep_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestEvalAssignStep_cast)
    else:
        cast = _connect.CTestEvalAssignStep_cast

    def getStepIdx(self) -> "std::string":
        return _connect.CTestEvalAssignStep_getStepIdx(self)

    def setStepIdx(self, stepIdx: 'int') -> "void":
        return _connect.CTestEvalAssignStep_setStepIdx(self, stepIdx)

    def getExpectedExpressions(self, isConst: 'bool') -> "isys::CSequenceAdapter":
        return _connect.CTestEvalAssignStep_getExpectedExpressions(self, isConst)

    def getAssignments(self, isConst: 'bool') -> "isys::CMapAdapter":
        return _connect.CTestEvalAssignStep_getAssignments(self, isConst)

    def getScriptParams(self, isConst: 'bool') -> "isys::CSequenceAdapter":
        return _connect.CTestEvalAssignStep_getScriptParams(self, isConst)
CTestEvalAssignStep_swigregister = _connect.CTestEvalAssignStep_swigregister
CTestEvalAssignStep_swigregister(CTestEvalAssignStep)

def CTestEvalAssignStep_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestEvalAssignStepSPtr":
    return _connect.CTestEvalAssignStep_cast(testBase)
CTestEvalAssignStep_cast = _connect.CTestEvalAssignStep_cast

class CTestUserStub(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestUserStub, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestUserStub, name)
    __repr__ = _swig_repr
    E_SECTION_STUBBED_FUNC_NAME = _connect.CTestUserStub_E_SECTION_STUBBED_FUNC_NAME
    E_SECTION_IS_ACTIVE = _connect.CTestUserStub_E_SECTION_IS_ACTIVE
    E_SECTION_REPLACEMENT_FUNC_NAME = _connect.CTestUserStub_E_SECTION_REPLACEMENT_FUNC_NAME

    def __init__(self, *args):
        this = _connect.new_CTestUserStub(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestUserStub
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestUserStub_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestUserStub_cast)
    else:
        cast = _connect.CTestUserStub_cast

    def isMerged(self) -> "bool":
        return _connect.CTestUserStub_isMerged(self)

    def getFunctionName(self) -> "std::string const":
        return _connect.CTestUserStub_getFunctionName(self)

    def isActive(self) -> "isys::ETristate":
        return _connect.CTestUserStub_isActive(self)

    def getReplacementFuncName(self) -> "std::string":
        return _connect.CTestUserStub_getReplacementFuncName(self)

    def setFunctionName(self, functionName: 'std::string const &') -> "void":
        return _connect.CTestUserStub_setFunctionName(self, functionName)

    def setActive(self, isActive: 'isys::ETristate') -> "void":
        return _connect.CTestUserStub_setActive(self, isActive)

    def setReplacementFuncName(self, replacementFuncName: 'std::string const &') -> "void":
        return _connect.CTestUserStub_setReplacementFuncName(self, replacementFuncName)
CTestUserStub_swigregister = _connect.CTestUserStub_swigregister
CTestUserStub_swigregister(CTestUserStub)

def CTestUserStub_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestUserStubSPtr":
    return _connect.CTestUserStub_cast(testBase)
CTestUserStub_cast = _connect.CTestUserStub_cast

class CTestHIL(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestHIL, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestHIL, name)
    __repr__ = _swig_repr
    E_SECTION_HIL_PARAMS = _connect.CTestHIL_E_SECTION_HIL_PARAMS

    def __init__(self, parent: 'isys::CTestBaseSPtr const &'):
        this = _connect.new_CTestHIL(parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestHIL
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestHIL_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestHIL_cast)
    else:
        cast = _connect.CTestHIL_cast

    def isMerged(self) -> "bool":
        return _connect.CTestHIL_isMerged(self)

    def getHILParamKeys(self, *args) -> "void":
        return _connect.CTestHIL_getHILParamKeys(self, *args)

    def getHILParamValues(self, values: 'StrVector') -> "void":
        return _connect.CTestHIL_getHILParamValues(self, values)

    def getHILParamMap(self, params: 'StrStrMap') -> "void":
        return _connect.CTestHIL_getHILParamMap(self, params)

    def setParam(self, key: 'std::string const &', value: 'std::string const &') -> "void":
        return _connect.CTestHIL_setParam(self, key, value)
CTestHIL_swigregister = _connect.CTestHIL_swigregister
CTestHIL_swigregister(CTestHIL)

def CTestHIL_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestHILSPtr":
    return _connect.CTestHIL_cast(testBase)
CTestHIL_cast = _connect.CTestHIL_cast

class CTestStackUsage(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestStackUsage, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestStackUsage, name)
    __repr__ = _swig_repr
    E_SECTION_MIN_SIZE = _connect.CTestStackUsage_E_SECTION_MIN_SIZE
    E_SECTION_MAX_SIZE = _connect.CTestStackUsage_E_SECTION_MAX_SIZE

    def __init__(self, *args):
        this = _connect.new_CTestStackUsage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestStackUsage
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestStackUsage_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestStackUsage_cast)
    else:
        cast = _connect.CTestStackUsage_cast

    def isMerged(self) -> "bool":
        return _connect.CTestStackUsage_isMerged(self)

    def getMinUsedSize(self) -> "std::string":
        return _connect.CTestStackUsage_getMinUsedSize(self)

    def getMaxUsedSize(self) -> "std::string":
        return _connect.CTestStackUsage_getMaxUsedSize(self)

    def setMinUsedSize(self, minSize: 'int') -> "void":
        return _connect.CTestStackUsage_setMinUsedSize(self, minSize)

    def setMaxUsedSize(self, maxSize: 'int') -> "void":
        return _connect.CTestStackUsage_setMaxUsedSize(self, maxSize)
CTestStackUsage_swigregister = _connect.CTestStackUsage_swigregister
CTestStackUsage_swigregister(CTestStackUsage)

def CTestStackUsage_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestStackUsageSPtr":
    return _connect.CTestStackUsage_cast(testBase)
CTestStackUsage_cast = _connect.CTestStackUsage_cast

class CTestPersistentVars(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestPersistentVars, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestPersistentVars, name)
    __repr__ = _swig_repr
    E_SECTION_DECL = _connect.CTestPersistentVars_E_SECTION_DECL
    E_SECTION_DELETE = _connect.CTestPersistentVars_E_SECTION_DELETE
    E_SECTION_IS_DELETE_ALL = _connect.CTestPersistentVars_E_SECTION_IS_DELETE_ALL

    def __init__(self, *args):
        this = _connect.new_CTestPersistentVars(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestPersistentVars
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestPersistentVars_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestPersistentVars_cast)
    else:
        cast = _connect.CTestPersistentVars_cast

    def isMerged(self) -> "bool":
        return _connect.CTestPersistentVars_isMerged(self)

    def isDeleteAll(self) -> "bool":
        return _connect.CTestPersistentVars_isDeleteAll(self)

    def setDeleteAll(self, isDeletaAll: 'isys::ETristate') -> "void":
        return _connect.CTestPersistentVars_setDeleteAll(self, isDeletaAll)
CTestPersistentVars_swigregister = _connect.CTestPersistentVars_swigregister
CTestPersistentVars_swigregister(CTestPersistentVars)

def CTestPersistentVars_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestPersistentVarsSPtr":
    return _connect.CTestPersistentVars_cast(testBase)
CTestPersistentVars_cast = _connect.CTestPersistentVars_cast

class CTestHostVars(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestHostVars, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CTestHostVars, name)
    __repr__ = _swig_repr
    LIST_SEPARATOR = _connect.CTestHostVars_LIST_SEPARATOR

    def __init__(self, *args):
        this = _connect.new_CTestHostVars(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setDirs(self, winIDEAWorkspace: 'std::string const &', iyamlDir: 'std::string const &', reportDir: 'std::string const &') -> "void":
        return _connect.CTestHostVars_setDirs(self, winIDEAWorkspace, iyamlDir, reportDir)

    def setDefaultCoreId(self, coreId: 'std::string const &') -> "void":
        return _connect.CTestHostVars_setDefaultCoreId(self, coreId)
    if _newclass:
        getDiagramFileName = staticmethod(_connect.CTestHostVars_getDiagramFileName)
    else:
        getDiagramFileName = _connect.CTestHostVars_getDiagramFileName

    def setValue(self, varName: 'std::string const &', varValue: 'std::string const &') -> "void":
        return _connect.CTestHostVars_setValue(self, varName, varValue)

    def getValue(self, varName: 'std::string const &') -> "std::string":
        return _connect.CTestHostVars_getValue(self, varName)

    def removeVar(self, varName: 'std::string const &') -> "void":
        return _connect.CTestHostVars_removeVar(self, varName)

    def replaceHostVars(self, expression: 'std::string const &') -> "std::string":
        return _connect.CTestHostVars_replaceHostVars(self, expression)
    if _newclass:
        getHostVarsForAnalyzerFileName = staticmethod(_connect.CTestHostVars_getHostVarsForAnalyzerFileName)
    else:
        getHostVarsForAnalyzerFileName = _connect.CTestHostVars_getHostVarsForAnalyzerFileName
    if _newclass:
        getHostVarsForGroupAnalyzerFileName = staticmethod(_connect.CTestHostVars_getHostVarsForGroupAnalyzerFileName)
    else:
        getHostVarsForGroupAnalyzerFileName = _connect.CTestHostVars_getHostVarsForGroupAnalyzerFileName
    if _newclass:
        getHostVarsForAutoTestId = staticmethod(_connect.CTestHostVars_getHostVarsForAutoTestId)
    else:
        getHostVarsForAutoTestId = _connect.CTestHostVars_getHostVarsForAutoTestId

    def initEnvVars(self) -> "void":
        return _connect.CTestHostVars_initEnvVars(self)

    def initCommonHostVars(self) -> "void":
        return _connect.CTestHostVars_initCommonHostVars(self)

    def initTestReportHostVars(self, wiWorkspaceDir: 'std::string const &', wiWorkspaceFile: 'std::string const &', defaultDlFile: 'std::string const &') -> "void":
        return _connect.CTestHostVars_initTestReportHostVars(self, wiWorkspaceDir, wiWorkspaceFile, defaultDlFile)

    def initSvnRevisionHostVar(self, workingCopyPath: 'std::string const &') -> "void":
        return _connect.CTestHostVars_initSvnRevisionHostVar(self, workingCopyPath)

    def initTestGroupVars(self, group: 'isys::CTestGroupSPtr &', envConfig: 'isys::CTestEnvironmentConfigSPtr') -> "void":
        return _connect.CTestHostVars_initTestGroupVars(self, group, envConfig)

    def initTestCaseVars(self, testSpec: 'isys::CTestSpecificationSPtr &', envConfig: 'isys::CTestEnvironmentConfigSPtr') -> "void":
        return _connect.CTestHostVars_initTestCaseVars(self, testSpec, envConfig)

    def initBatchVars(self) -> "void":
        return _connect.CTestHostVars_initBatchVars(self)
    if _newclass:
        createDiagramVars = staticmethod(_connect.CTestHostVars_createDiagramVars)
    else:
        createDiagramVars = _connect.CTestHostVars_createDiagramVars
    if _newclass:
        createTcAnalyzerFNameVars = staticmethod(_connect.CTestHostVars_createTcAnalyzerFNameVars)
    else:
        createTcAnalyzerFNameVars = _connect.CTestHostVars_createTcAnalyzerFNameVars
    if _newclass:
        createGrpAnalyzerFNameVars = staticmethod(_connect.CTestHostVars_createGrpAnalyzerFNameVars)
    else:
        createGrpAnalyzerFNameVars = _connect.CTestHostVars_createGrpAnalyzerFNameVars

    def toString(self) -> "std::string":
        return _connect.CTestHostVars_toString(self)
    __swig_destroy__ = _connect.delete_CTestHostVars
    __del__ = lambda self: None
CTestHostVars_swigregister = _connect.CTestHostVars_swigregister
CTestHostVars_swigregister(CTestHostVars)
CTestHostVars.RESERVED_ENV_PREFIX = _connect.cvar.CTestHostVars_RESERVED_ENV_PREFIX
CTestHostVars.RESERVED_GROUP_ID = _connect.cvar.CTestHostVars_RESERVED_GROUP_ID
CTestHostVars.RESERVED_PARTITION = _connect.cvar.CTestHostVars_RESERVED_PARTITION
CTestHostVars.RESERVED_MODULE = _connect.cvar.CTestHostVars_RESERVED_MODULE
CTestHostVars.RESERVED_TEST_ID = _connect.cvar.CTestHostVars_RESERVED_TEST_ID
CTestHostVars.RESERVED_TAGS = _connect.cvar.CTestHostVars_RESERVED_TAGS
CTestHostVars.RESERVED_FUNCTION = _connect.cvar.CTestHostVars_RESERVED_FUNCTION
CTestHostVars.RESERVED_PARAMS = _connect.cvar.CTestHostVars_RESERVED_PARAMS
CTestHostVars.RESERVED_CORE_ID = _connect.cvar.CTestHostVars_RESERVED_CORE_ID
CTestHostVars.RESERVED_USER = _connect.cvar.CTestHostVars_RESERVED_USER
CTestHostVars.RESERVED_DATE = _connect.cvar.CTestHostVars_RESERVED_DATE
CTestHostVars.RESERVED_TIME = _connect.cvar.CTestHostVars_RESERVED_TIME
CTestHostVars.RESERVED_ISO_TIME = _connect.cvar.CTestHostVars_RESERVED_ISO_TIME
CTestHostVars.RESERVED_UID = _connect.cvar.CTestHostVars_RESERVED_UID
CTestHostVars.RESERVED_BATCH_DATE = _connect.cvar.CTestHostVars_RESERVED_BATCH_DATE
CTestHostVars.RESERVED_BATCH_TIME = _connect.cvar.CTestHostVars_RESERVED_BATCH_TIME
CTestHostVars.RESERVED_BATCH_UID = _connect.cvar.CTestHostVars_RESERVED_BATCH_UID
CTestHostVars.RESERVED_DIAGRAM_TYPE = _connect.cvar.CTestHostVars_RESERVED_DIAGRAM_TYPE
CTestHostVars.RESERVED_WINIDEA_WORKSPACE_DIR = _connect.cvar.CTestHostVars_RESERVED_WINIDEA_WORKSPACE_DIR
CTestHostVars.RESERVED_WINIDEA_WORKSPACE_FILE = _connect.cvar.CTestHostVars_RESERVED_WINIDEA_WORKSPACE_FILE
CTestHostVars.RESERVED_DEFAULT_DL_DIR = _connect.cvar.CTestHostVars_RESERVED_DEFAULT_DL_DIR
CTestHostVars.RESERVED_DEFAULT_DL_FILE = _connect.cvar.CTestHostVars_RESERVED_DEFAULT_DL_FILE
CTestHostVars.RESERVED_IYAML_DIR = _connect.cvar.CTestHostVars_RESERVED_IYAML_DIR
CTestHostVars.RESERVED_REPORT_DIR = _connect.cvar.CTestHostVars_RESERVED_REPORT_DIR
CTestHostVars.RESERVED_NID = _connect.cvar.CTestHostVars_RESERVED_NID
CTestHostVars.RESERVED_DID = _connect.cvar.CTestHostVars_RESERVED_DID
CTestHostVars.RESERVED_UUID = _connect.cvar.CTestHostVars_RESERVED_UUID
CTestHostVars.RESERVED_SEQ = _connect.cvar.CTestHostVars_RESERVED_SEQ
CTestHostVars.RESERVED_FUNC_UNDER_TEST = _connect.cvar.CTestHostVars_RESERVED_FUNC_UNDER_TEST
CTestHostVars.RESERVED_SVN_REVISION = _connect.cvar.CTestHostVars_RESERVED_SVN_REVISION
CTestHostVars.RESERVED_CUSTOM_DIAGRAM_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_CUSTOM_DIAGRAM_POSTFIX
CTestHostVars.RESERVED_SEQUENCE_DIAGRAM_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_SEQUENCE_DIAGRAM_POSTFIX
CTestHostVars.RESERVED_FLOW_CHART_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_FLOW_CHART_POSTFIX
CTestHostVars.RESERVED_RUNTIME_CALL_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_RUNTIME_CALL_GRAPH_POSTFIX
CTestHostVars.RESERVED_STATIC_CALL_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_STATIC_CALL_GRAPH_POSTFIX
CTestHostVars.RESERVED_FLAME_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_FLAME_GRAPH_POSTFIX

def CTestHostVars_getDiagramFileName(testSpec: 'isys::CTestSpecificationSPtr &', diagConfig: 'isys::CTestDiagramConfigSPtr &') -> "std::string":
    return _connect.CTestHostVars_getDiagramFileName(testSpec, diagConfig)
CTestHostVars_getDiagramFileName = _connect.CTestHostVars_getDiagramFileName

def CTestHostVars_getHostVarsForAnalyzerFileName(hostVars: 'StrVector') -> "void":
    return _connect.CTestHostVars_getHostVarsForAnalyzerFileName(hostVars)
CTestHostVars_getHostVarsForAnalyzerFileName = _connect.CTestHostVars_getHostVarsForAnalyzerFileName

def CTestHostVars_getHostVarsForGroupAnalyzerFileName(hostVars: 'StrVector') -> "void":
    return _connect.CTestHostVars_getHostVarsForGroupAnalyzerFileName(hostVars)
CTestHostVars_getHostVarsForGroupAnalyzerFileName = _connect.CTestHostVars_getHostVarsForGroupAnalyzerFileName

def CTestHostVars_getHostVarsForAutoTestId(hostVars: 'StrVector', isIncludeCoreId: 'bool', isForProposals: 'bool') -> "void":
    return _connect.CTestHostVars_getHostVarsForAutoTestId(hostVars, isIncludeCoreId, isForProposals)
CTestHostVars_getHostVarsForAutoTestId = _connect.CTestHostVars_getHostVarsForAutoTestId

def CTestHostVars_createDiagramVars(testSpec: 'isys::CTestSpecificationSPtr &', diagConfig: 'isys::CTestDiagramConfigSPtr &') -> "isys::CTestHostVarsSPtr":
    return _connect.CTestHostVars_createDiagramVars(testSpec, diagConfig)
CTestHostVars_createDiagramVars = _connect.CTestHostVars_createDiagramVars

def CTestHostVars_createTcAnalyzerFNameVars(testSpec: 'isys::CTestSpecificationSPtr &') -> "isys::CTestHostVarsSPtr":
    return _connect.CTestHostVars_createTcAnalyzerFNameVars(testSpec)
CTestHostVars_createTcAnalyzerFNameVars = _connect.CTestHostVars_createTcAnalyzerFNameVars

def CTestHostVars_createGrpAnalyzerFNameVars(testGroup: 'isys::CTestGroupSPtr &') -> "isys::CTestHostVarsSPtr":
    return _connect.CTestHostVars_createGrpAnalyzerFNameVars(testGroup)
CTestHostVars_createGrpAnalyzerFNameVars = _connect.CTestHostVars_createGrpAnalyzerFNameVars

class CTestDryRun(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestDryRun, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestDryRun, name)
    __repr__ = _swig_repr
    E_SECTION_ASSIGN = _connect.CTestDryRun_E_SECTION_ASSIGN
    E_SECTION_UPDATE_COVERAGE = _connect.CTestDryRun_E_SECTION_UPDATE_COVERAGE
    E_SECTION_UPDATE_PROFILER = _connect.CTestDryRun_E_SECTION_UPDATE_PROFILER
    E_SECTION_PROFILER_MULTIPLIER = _connect.CTestDryRun_E_SECTION_PROFILER_MULTIPLIER
    E_SECTION_PROFILER_OFFSET = _connect.CTestDryRun_E_SECTION_PROFILER_OFFSET

    def __init__(self, *args):
        this = _connect.new_CTestDryRun(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestDryRun
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestDryRun_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestDryRun_cast)
    else:
        cast = _connect.CTestDryRun_cast

    def getAssignments(self, isConst: 'bool') -> "isys::CMapAdapter":
        return _connect.CTestDryRun_getAssignments(self, isConst)

    def isUpdateCoverage(self) -> "isys::ETristate":
        return _connect.CTestDryRun_isUpdateCoverage(self)

    def isUpdateProfiler(self) -> "isys::ETristate":
        return _connect.CTestDryRun_isUpdateProfiler(self)

    def getProfilerMultiplier(self) -> "std::string":
        return _connect.CTestDryRun_getProfilerMultiplier(self)

    def getProfilerOffset(self) -> "std::string":
        return _connect.CTestDryRun_getProfilerOffset(self)

    def setUpdateCoverage(self, isUpdate: 'isys::ETristate') -> "void":
        return _connect.CTestDryRun_setUpdateCoverage(self, isUpdate)

    def setUpdateProfiler(self, isUpdate: 'isys::ETristate') -> "void":
        return _connect.CTestDryRun_setUpdateProfiler(self, isUpdate)
CTestDryRun_swigregister = _connect.CTestDryRun_swigregister
CTestDryRun_swigregister(CTestDryRun)

def CTestDryRun_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestDryRunSPtr":
    return _connect.CTestDryRun_cast(testBase)
CTestDryRun_cast = _connect.CTestDryRun_cast

class CTestDiagramConfig(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestDiagramConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestDiagramConfig, name)
    __repr__ = _swig_repr
    E_SECTION_DIAG_CFG_IS_ACTIVE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_IS_ACTIVE
    E_SECTION_DIAG_CFG_DIAG_TYPE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_DIAG_TYPE
    E_SECTION_DIAG_CFG_SCRIPT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_SCRIPT
    E_SECTION_DIAG_CFG_PARAMS = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_PARAMS
    E_SECTION_DIAG_CFG_OUT_FILE_NAME = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_OUT_FILE_NAME
    E_SECTION_DIAG_CFG_IS_ADD_TO_REPORT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_IS_ADD_TO_REPORT
    E_SECTION_DIAG_CFG_VIEWER_TYPE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_VIEWER_TYPE
    E_SECTION_DIAG_CFG_DATA_FORMAT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_DATA_FORMAT
    E_SECTION_DIAG_CFG_EXTERNAL_VIEWER = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_EXTERNAL_VIEWER
    EFlowChart = _connect.CTestDiagramConfig_EFlowChart
    ESequenceDiagram = _connect.CTestDiagramConfig_ESequenceDiagram
    ERuntimeCallGraph = _connect.CTestDiagramConfig_ERuntimeCallGraph
    EStaticCallGraph = _connect.CTestDiagramConfig_EStaticCallGraph
    EFlameGraph = _connect.CTestDiagramConfig_EFlameGraph
    ECustom = _connect.CTestDiagramConfig_ECustom
    ECustomAsync = _connect.CTestDiagramConfig_ECustomAsync
    EMultipage = _connect.CTestDiagramConfig_EMultipage
    ESinglePage = _connect.CTestDiagramConfig_ESinglePage
    EExternal = _connect.CTestDiagramConfig_EExternal
    ENone = _connect.CTestDiagramConfig_ENone
    EByExtension = _connect.CTestDiagramConfig_EByExtension
    EBitmap = _connect.CTestDiagramConfig_EBitmap
    ESVG = _connect.CTestDiagramConfig_ESVG

    def __init__(self, *args):
        this = _connect.new_CTestDiagramConfig(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestDiagramConfig
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestDiagramConfig_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestDiagramConfig_cast)
    else:
        cast = _connect.CTestDiagramConfig_cast

    def isMerged(self) -> "bool":
        return _connect.CTestDiagramConfig_isMerged(self)

    def isActive(self) -> "isys::ETristate":
        return _connect.CTestDiagramConfig_isActive(self)

    def getDiagramType(self) -> "isys::CTestDiagramConfig::EDiagType":
        return _connect.CTestDiagramConfig_getDiagramType(self)

    def getViewerType(self) -> "isys::CTestDiagramConfig::EViewerType":
        return _connect.CTestDiagramConfig_getViewerType(self)

    def getViewFormat(self) -> "isys::CTestDiagramConfig::EViewFormat":
        return _connect.CTestDiagramConfig_getViewFormat(self)

    def getScriptName(self) -> "std::string":
        return _connect.CTestDiagramConfig_getScriptName(self)

    def getParameters(self, isConst: 'bool') -> "isys::CSequenceAdapter":
        return _connect.CTestDiagramConfig_getParameters(self, isConst)

    def getOutputFileName(self) -> "std::string":
        return _connect.CTestDiagramConfig_getOutputFileName(self)

    def isAddToReport(self) -> "isys::ETristate":
        return _connect.CTestDiagramConfig_isAddToReport(self)

    def getExternalViewerName(self) -> "std::string":
        return _connect.CTestDiagramConfig_getExternalViewerName(self)

    def getScriptCmdLineArgs(self, testSpec: 'isys::CTestSpecificationSPtr &', outFile: 'std::string const &', profilerExportFile: 'std::string const &', dotExeDir: 'std::string const &', cmdLineArgs: 'StrVector') -> "void":
        return _connect.CTestDiagramConfig_getScriptCmdLineArgs(self, testSpec, outFile, profilerExportFile, dotExeDir, cmdLineArgs)

    def parsingEnd(self) -> "void":
        return _connect.CTestDiagramConfig_parsingEnd(self)
CTestDiagramConfig_swigregister = _connect.CTestDiagramConfig_swigregister
CTestDiagramConfig_swigregister(CTestDiagramConfig)
CTestDiagramConfig.SEQ_AND_CALL_DIAG_PY = _connect.cvar.CTestDiagramConfig_SEQ_AND_CALL_DIAG_PY
CTestDiagramConfig.STATIC_CALL_GRAPH_PY = _connect.cvar.CTestDiagramConfig_STATIC_CALL_GRAPH_PY
CTestDiagramConfig.FLOW_CHART_PY = _connect.cvar.CTestDiagramConfig_FLOW_CHART_PY
CTestDiagramConfig.FLAME_GRAPH_PY = _connect.cvar.CTestDiagramConfig_FLAME_GRAPH_PY

def CTestDiagramConfig_cast(testBase: 'isys::CTestBaseSPtr const &') -> "isys::CTestDiagramConfigSPtr":
    return _connect.CTestDiagramConfig_cast(testBase)
CTestDiagramConfig_cast = _connect.CTestDiagramConfig_cast

class CTestDiagrams(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestDiagrams, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestDiagrams, name)
    __repr__ = _swig_repr
    E_SECTION_DIAG_IS_ACTIVE = _connect.CTestDiagrams_E_SECTION_DIAG_IS_ACTIVE
    E_SECTION_DIAG_CONFIGS = _connect.CTestDiagrams_E_SECTION_DIAG_CONFIGS

    def __init__(self, *args):
        this = _connect.new_CTestDiagrams(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestDiagrams
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestDiagrams_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestDiagrams_cast)
    else:
        cast = _connect.CTestDiagrams_cast

    def isMerged(self) -> "bool":
        return _connect.CTestDiagrams_isMerged(self)

    def isActive(self) -> "isys::ETristate":
        return _connect.CTestDiagrams_isActive(self)

    def getConfigurations(self, isConst: 'bool') -> "isys::CTestBaseListSPtr":
        return _connect.CTestDiagrams_getConfigurations(self, isConst)

    def createTestBase(self, section: 'int', lineNo: 'size_t') -> "isys::CTestBaseSPtr":
        return _connect.CTestDiagrams_createTestBase(self, section, lineNo)
CTestDiagrams_swigregister = _connect.CTestDiagrams_swigregister
CTestDiagrams_swigregister(CTestDiagrams)

def CTestDiagrams_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestDiagramsSPtr":
    return _connect.CTestDiagrams_cast(testBase)
CTestDiagrams_cast = _connect.CTestDiagrams_cast

class CTestStopCondition(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestStopCondition, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestStopCondition, name)
    __repr__ = _swig_repr
    E_BREAKPOINT = _connect.CTestStopCondition_E_BREAKPOINT
    E_STOP = _connect.CTestStopCondition_E_STOP
    E_RT_EXPRESSION = _connect.CTestStopCondition_E_RT_EXPRESSION
    E_NO_RUN = _connect.CTestStopCondition_E_NO_RUN
    E_SECTION_STOP_TYPE = _connect.CTestStopCondition_E_SECTION_STOP_TYPE
    E_SECTION_TIMEOUT = _connect.CTestStopCondition_E_SECTION_TIMEOUT
    E_SECTION_RT_EXPRESSION = _connect.CTestStopCondition_E_SECTION_RT_EXPRESSION
    E_SECTION_BP_CONDITION_COUNT = _connect.CTestStopCondition_E_SECTION_BP_CONDITION_COUNT
    E_SECTION_BP_CONDITION_EXPR = _connect.CTestStopCondition_E_SECTION_BP_CONDITION_EXPR
    E_SECTION_BP_LOCATION = _connect.CTestStopCondition_E_SECTION_BP_LOCATION

    def __init__(self, *args):
        this = _connect.new_CTestStopCondition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestStopCondition
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestStopCondition_createInstance(self, parent)
    if _newclass:
        cast = staticmethod(_connect.CTestStopCondition_cast)
    else:
        cast = _connect.CTestStopCondition_cast

    def isMerged(self) -> "bool":
        return _connect.CTestStopCondition_isMerged(self)

    def getStopType(self) -> "isys::CTestStopCondition::EStopType":
        return _connect.CTestStopCondition_getStopType(self)

    def getTimeout(self) -> "int":
        return _connect.CTestStopCondition_getTimeout(self)

    def getRtExpression(self) -> "std::string":
        return _connect.CTestStopCondition_getRtExpression(self)

    def getConditionCount(self) -> "int":
        return _connect.CTestStopCondition_getConditionCount(self)

    def getConditionExpr(self) -> "std::string":
        return _connect.CTestStopCondition_getConditionExpr(self)

    def getBreakpointLocation(self, isConst: 'bool') -> "isys::CTestLocationSPtr":
        return _connect.CTestStopCondition_getBreakpointLocation(self, isConst)

    def setStopType(self, stopType: 'isys::CTestStopCondition::EStopType') -> "void":
        return _connect.CTestStopCondition_setStopType(self, stopType)

    def setTimeout(self, timeout: 'int') -> "void":
        return _connect.CTestStopCondition_setTimeout(self, timeout)

    def setConditionCount(self, conditionCount: 'int') -> "void":
        return _connect.CTestStopCondition_setConditionCount(self, conditionCount)

    def setConditionExpr(self, expr: 'std::string const &') -> "void":
        return _connect.CTestStopCondition_setConditionExpr(self, expr)

    def setRtExpression(self, rtExpression: 'std::string const &') -> "void":
        return _connect.CTestStopCondition_setRtExpression(self, rtExpression)

    def createTestBase(self, section: 'int', lineNo: 'size_t') -> "isys::CTestBaseSPtr":
        return _connect.CTestStopCondition_createTestBase(self, section, lineNo)
CTestStopCondition_swigregister = _connect.CTestStopCondition_swigregister
CTestStopCondition_swigregister(CTestStopCondition)

def CTestStopCondition_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestStopConditionSPtr":
    return _connect.CTestStopCondition_cast(testBase)
CTestStopCondition_cast = _connect.CTestStopCondition_cast

class CTestImportSources(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestImportSources, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestImportSources, name)
    __repr__ = _swig_repr
    E_SECTION_IS_INHERIT = _connect.CTestImportSources_E_SECTION_IS_INHERIT
    E_SECTION_TEST_IDS = _connect.CTestImportSources_E_SECTION_TEST_IDS

    def __init__(self, *args):
        this = _connect.new_CTestImportSources(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestImportSources
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestImportSources_createInstance(self, parent)

    def createTestBase(self, section: 'int', lineNo: 'size_t') -> "isys::CTestBaseSPtr":
        return _connect.CTestImportSources_createTestBase(self, section, lineNo)

    def isMerged(self) -> "bool":
        return _connect.CTestImportSources_isMerged(self)
    if _newclass:
        cast = staticmethod(_connect.CTestImportSources_cast)
    else:
        cast = _connect.CTestImportSources_cast

    def isInheritance(self) -> "isys::ETristate":
        return _connect.CTestImportSources_isInheritance(self)

    def setInheritance(self, inheritance: 'isys::ETristate') -> "void":
        return _connect.CTestImportSources_setInheritance(self, inheritance)

    def getImportedTestIds(self, isConst: 'bool') -> "isys::CSequenceAdapter":
        return _connect.CTestImportSources_getImportedTestIds(self, isConst)
CTestImportSources_swigregister = _connect.CTestImportSources_swigregister
CTestImportSources_swigregister(CTestImportSources)

def CTestImportSources_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestImportSourcesSPtr":
    return _connect.CTestImportSources_cast(testBase)
CTestImportSources_cast = _connect.CTestImportSources_cast

class CTestImports(CTestBase):
    __swig_setmethods__ = {}
    for _s in [CTestBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CTestImports, name, value)
    __swig_getmethods__ = {}
    for _s in [CTestBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CTestImports, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_CTestImports(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CTestImports
    __del__ = lambda self: None

    def createInstance(self, parent: 'isys::CTestBaseSPtr const &') -> "isys::CTestBaseSPtr":
        return _connect.CTestImports_createInstance(self, parent)

    def createTestBase(self, section: 'int', lineNo: 'size_t') -> "isys::CTestBaseSPtr":
        return _connect.CTestImports_createTestBase(self, section, lineNo)

    def isMerged(self) -> "bool":
        return _connect.CTestImports_isMerged(self)
    if _newclass:
        cast = staticmethod(_connect.CTestImports_cast)
    else:
        cast = _connect.CTestImports_cast

    def getSectionSources(self, section: 'isys::CTestSpecification::SectionIds', isConst: 'bool') -> "isys::CTestImportSourcesSPtr":
        return _connect.CTestImports_getSectionSources(self, section, isConst)
CTestImports_swigregister = _connect.CTestImports_swigregister
CTestImports_swigregister(CTestImports)

def CTestImports_cast(testBase: 'isys::CTestBaseSPtr &') -> "isys::CTestImportsSPtr":
    return _connect.CTestImports_cast(testBase)
CTestImports_cast = _connect.CTestImports_cast

class CSourceCodeFile(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSourceCodeFile, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSourceCodeFile, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_CSourceCodeFile()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CSourceCodeFile
    __del__ = lambda self: None

    def load(self, fileName: 'std::string const &') -> "isys::CTestBenchSPtr":
        return _connect.CSourceCodeFile_load(self, fileName)

    def save(self, testBench: 'isys::CTestBenchSPtr') -> "void":
        return _connect.CSourceCodeFile_save(self, testBench)

    def saveAs(self, fileName: 'std::string const &', testBench: 'isys::CTestBenchSPtr', forceOverwrite: 'bool') -> "bool":
        return _connect.CSourceCodeFile_saveAs(self, fileName, testBench, forceOverwrite)

    def close(self) -> "void":
        return _connect.CSourceCodeFile_close(self)

    def getErrors(self) -> "std::string":
        return _connect.CSourceCodeFile_getErrors(self)

    def assignCommentLocation(self, testSpec: 'isys::CTestSpecificationSPtr &') -> "void":
        return _connect.CSourceCodeFile_assignCommentLocation(self, testSpec)
CSourceCodeFile_swigregister = _connect.CSourceCodeFile_swigregister
CSourceCodeFile_swigregister(CSourceCodeFile)

class CYAMLUtil(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CYAMLUtil, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CYAMLUtil, name)
    __repr__ = _swig_repr
    if _newclass:
        parseTestBase = staticmethod(_connect.CYAMLUtil_parseTestBase)
    else:
        parseTestBase = _connect.CYAMLUtil_parseTestBase
    if _newclass:
        parseTestBaseList = staticmethod(_connect.CYAMLUtil_parseTestBaseList)
    else:
        parseTestBaseList = _connect.CYAMLUtil_parseTestBaseList
    if _newclass:
        cto2ctb = staticmethod(_connect.CYAMLUtil_cto2ctb)
    else:
        cto2ctb = _connect.CYAMLUtil_cto2ctb
    if _newclass:
        cto2ctbl = staticmethod(_connect.CYAMLUtil_cto2ctbl)
    else:
        cto2ctbl = _connect.CYAMLUtil_cto2ctbl
    if _newclass:
        isInstanceOfCtb = staticmethod(_connect.CYAMLUtil_isInstanceOfCtb)
    else:
        isInstanceOfCtb = _connect.CYAMLUtil_isInstanceOfCtb
    if _newclass:
        isInstanceOfCtbList = staticmethod(_connect.CYAMLUtil_isInstanceOfCtbList)
    else:
        isInstanceOfCtbList = _connect.CYAMLUtil_isInstanceOfCtbList
    if _newclass:
        strVector2Str = staticmethod(_connect.CYAMLUtil_strVector2Str)
    else:
        strVector2Str = _connect.CYAMLUtil_strVector2Str
    if _newclass:
        strStrMap2OrderedStr = staticmethod(_connect.CYAMLUtil_strStrMap2OrderedStr)
    else:
        strStrMap2OrderedStr = _connect.CYAMLUtil_strStrMap2OrderedStr
    if _newclass:
        strVectorVector2Str = staticmethod(_connect.CYAMLUtil_strVectorVector2Str)
    else:
        strVectorVector2Str = _connect.CYAMLUtil_strVectorVector2Str
    if _newclass:
        strVector2Sequence = staticmethod(_connect.CYAMLUtil_strVector2Sequence)
    else:
        strVector2Sequence = _connect.CYAMLUtil_strVector2Sequence
    if _newclass:
        verifyLimitedScalar = staticmethod(_connect.CYAMLUtil_verifyLimitedScalar)
    else:
        verifyLimitedScalar = _connect.CYAMLUtil_verifyLimitedScalar
    if _newclass:
        getSymbolsAllowedTestId = staticmethod(_connect.CYAMLUtil_getSymbolsAllowedTestId)
    else:
        getSymbolsAllowedTestId = _connect.CYAMLUtil_getSymbolsAllowedTestId
    if _newclass:
        verifyTestId = staticmethod(_connect.CYAMLUtil_verifyTestId)
    else:
        verifyTestId = _connect.CYAMLUtil_verifyTestId
    if _newclass:
        verifyScalar = staticmethod(_connect.CYAMLUtil_verifyScalar)
    else:
        verifyScalar = _connect.CYAMLUtil_verifyScalar
    if _newclass:
        verifyList = staticmethod(_connect.CYAMLUtil_verifyList)
    else:
        verifyList = _connect.CYAMLUtil_verifyList
    if _newclass:
        verifyListOfLimitedScalars = staticmethod(_connect.CYAMLUtil_verifyListOfLimitedScalars)
    else:
        verifyListOfLimitedScalars = _connect.CYAMLUtil_verifyListOfLimitedScalars
    if _newclass:
        verifyMap = staticmethod(_connect.CYAMLUtil_verifyMap)
    else:
        verifyMap = _connect.CYAMLUtil_verifyMap
    if _newclass:
        isAllowedCharForTestId = staticmethod(_connect.CYAMLUtil_isAllowedCharForTestId)
    else:
        isAllowedCharForTestId = _connect.CYAMLUtil_isAllowedCharForTestId
    if _newclass:
        replaceInvalidChars = staticmethod(_connect.CYAMLUtil_replaceInvalidChars)
    else:
        replaceInvalidChars = _connect.CYAMLUtil_replaceInvalidChars
    if _newclass:
        join = staticmethod(_connect.CYAMLUtil_join)
    else:
        join = _connect.CYAMLUtil_join
    if _newclass:
        getCurrentISODate = staticmethod(_connect.CYAMLUtil_getCurrentISODate)
    else:
        getCurrentISODate = _connect.CYAMLUtil_getCurrentISODate
    if _newclass:
        getCurrentISOTime = staticmethod(_connect.CYAMLUtil_getCurrentISOTime)
    else:
        getCurrentISOTime = _connect.CYAMLUtil_getCurrentISOTime

    def __init__(self):
        this = _connect.new_CYAMLUtil()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CYAMLUtil
    __del__ = lambda self: None
CYAMLUtil_swigregister = _connect.CYAMLUtil_swigregister
CYAMLUtil_swigregister(CYAMLUtil)

def CYAMLUtil_parseTestBase(yamlSpec: 'std::string const &', testBase: 'isys::CTestBaseSPtr') -> "void":
    return _connect.CYAMLUtil_parseTestBase(yamlSpec, testBase)
CYAMLUtil_parseTestBase = _connect.CYAMLUtil_parseTestBase

def CYAMLUtil_parseTestBaseList(yamlSpec: 'std::string const &', parentTestBase: 'isys::CTestBaseSPtr &', section: 'int') -> "void":
    return _connect.CYAMLUtil_parseTestBaseList(yamlSpec, parentTestBase, section)
CYAMLUtil_parseTestBaseList = _connect.CYAMLUtil_parseTestBaseList

def CYAMLUtil_cto2ctb(src: 'isys::CTestObjectSPtr const &') -> "isys::CTestBaseSPtr":
    return _connect.CYAMLUtil_cto2ctb(src)
CYAMLUtil_cto2ctb = _connect.CYAMLUtil_cto2ctb

def CYAMLUtil_cto2ctbl(src: 'isys::CTestObjectSPtr const &') -> "isys::CTestBaseListSPtr":
    return _connect.CYAMLUtil_cto2ctbl(src)
CYAMLUtil_cto2ctbl = _connect.CYAMLUtil_cto2ctbl

def CYAMLUtil_isInstanceOfCtb(src: 'isys::CTestObjectSPtr const &') -> "bool":
    return _connect.CYAMLUtil_isInstanceOfCtb(src)
CYAMLUtil_isInstanceOfCtb = _connect.CYAMLUtil_isInstanceOfCtb

def CYAMLUtil_isInstanceOfCtbList(src: 'isys::CTestObjectSPtr const &') -> "bool":
    return _connect.CYAMLUtil_isInstanceOfCtbList(src)
CYAMLUtil_isInstanceOfCtbList = _connect.CYAMLUtil_isInstanceOfCtbList

def CYAMLUtil_strVector2Str(vec: 'StrVector') -> "std::string":
    return _connect.CYAMLUtil_strVector2Str(vec)
CYAMLUtil_strVector2Str = _connect.CYAMLUtil_strVector2Str

def CYAMLUtil_strStrMap2OrderedStr(mapping: 'StrStrMap', keys: 'StrVector', isFlowStyle: 'bool') -> "std::string":
    return _connect.CYAMLUtil_strStrMap2OrderedStr(mapping, keys, isFlowStyle)
CYAMLUtil_strStrMap2OrderedStr = _connect.CYAMLUtil_strStrMap2OrderedStr

def CYAMLUtil_strVectorVector2Str(keys: 'StrVector', values: 'StrVector', isFlowStyle: 'bool') -> "std::string":
    return _connect.CYAMLUtil_strVectorVector2Str(keys, values, isFlowStyle)
CYAMLUtil_strVectorVector2Str = _connect.CYAMLUtil_strVectorVector2Str

def CYAMLUtil_strVector2Sequence(dest: 'isys::CTestBaseSPtr &', section: 'int', items: 'StrVector') -> "void":
    return _connect.CYAMLUtil_strVector2Sequence(dest, section, items)
CYAMLUtil_strVector2Sequence = _connect.CYAMLUtil_strVector2Sequence

def CYAMLUtil_verifyLimitedScalar(yamlSpec: 'std::string const &', msg: 'std::string const &') -> "void":
    return _connect.CYAMLUtil_verifyLimitedScalar(yamlSpec, msg)
CYAMLUtil_verifyLimitedScalar = _connect.CYAMLUtil_verifyLimitedScalar

def CYAMLUtil_getSymbolsAllowedTestId() -> "std::string":
    return _connect.CYAMLUtil_getSymbolsAllowedTestId()
CYAMLUtil_getSymbolsAllowedTestId = _connect.CYAMLUtil_getSymbolsAllowedTestId

def CYAMLUtil_verifyTestId(testID: 'std::string const &', msg: 'std::string const &') -> "std::string":
    return _connect.CYAMLUtil_verifyTestId(testID, msg)
CYAMLUtil_verifyTestId = _connect.CYAMLUtil_verifyTestId

def CYAMLUtil_verifyScalar(yamlSpec: 'std::string const &') -> "void":
    return _connect.CYAMLUtil_verifyScalar(yamlSpec)
CYAMLUtil_verifyScalar = _connect.CYAMLUtil_verifyScalar

def CYAMLUtil_verifyList(yamlSpec: 'std::string const &') -> "void":
    return _connect.CYAMLUtil_verifyList(yamlSpec)
CYAMLUtil_verifyList = _connect.CYAMLUtil_verifyList

def CYAMLUtil_verifyListOfLimitedScalars(yamlSpec: 'std::string const &', msg: 'std::string const &') -> "void":
    return _connect.CYAMLUtil_verifyListOfLimitedScalars(yamlSpec, msg)
CYAMLUtil_verifyListOfLimitedScalars = _connect.CYAMLUtil_verifyListOfLimitedScalars

def CYAMLUtil_verifyMap(yamlSpec: 'std::string const &') -> "void":
    return _connect.CYAMLUtil_verifyMap(yamlSpec)
CYAMLUtil_verifyMap = _connect.CYAMLUtil_verifyMap

def CYAMLUtil_isAllowedCharForTestId(c: 'char') -> "bool":
    return _connect.CYAMLUtil_isAllowedCharForTestId(c)
CYAMLUtil_isAllowedCharForTestId = _connect.CYAMLUtil_isAllowedCharForTestId

def CYAMLUtil_replaceInvalidChars(param: 'std::string const') -> "std::string":
    return _connect.CYAMLUtil_replaceInvalidChars(param)
CYAMLUtil_replaceInvalidChars = _connect.CYAMLUtil_replaceInvalidChars

def CYAMLUtil_join(params: 'StrVector', separator: 'char') -> "std::string":
    return _connect.CYAMLUtil_join(params, separator)
CYAMLUtil_join = _connect.CYAMLUtil_join

def CYAMLUtil_getCurrentISODate() -> "std::string":
    return _connect.CYAMLUtil_getCurrentISODate()
CYAMLUtil_getCurrentISODate = _connect.CYAMLUtil_getCurrentISODate

def CYAMLUtil_getCurrentISOTime() -> "std::string":
    return _connect.CYAMLUtil_getCurrentISOTime()
CYAMLUtil_getCurrentISOTime = _connect.CYAMLUtil_getCurrentISOTime

class CISLScript(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CISLScript, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CISLScript, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CISLScript(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def service(self, functionId: 'int', param1: 'std::string const &', param2: 'std::string const &', param3: 'std::string const &', param4: 'std::string const &', val1: 'int', val2: 'int', val3: 'int', val4: 'int', val5: 'int', val6: 'int') -> "int":
        return _connect.CISLScript_service(self, functionId, param1, param2, param3, param4, val1, val2, val3, val4, val5, val6)

    def getLastOutputText(self) -> "std::string":
        return _connect.CISLScript_getLastOutputText(self)
    __swig_destroy__ = _connect.delete_CISLScript
    __del__ = lambda self: None
CISLScript_swigregister = _connect.CISLScript_swigregister
CISLScript_swigregister(CISLScript)

class SPtrFactory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SPtrFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SPtrFactory, name)
    __repr__ = _swig_repr

    def getConnectionMgr(self, connectionMgrSPtr: 'std::shared_ptr< isys::ConnectionMgr > &') -> "isys::ConnectionMgr *":
        return _connect.SPtrFactory_getConnectionMgr(self, connectionMgrSPtr)

    def newConnectionMgr(self) -> "std::shared_ptr< isys::ConnectionMgr >":
        return _connect.SPtrFactory_newConnectionMgr(self)
    if _newclass:
        cProfilerData2 = staticmethod(_connect.SPtrFactory_cProfilerData2)
    else:
        cProfilerData2 = _connect.SPtrFactory_cProfilerData2
    if _newclass:
        cCoverageData2 = staticmethod(_connect.SPtrFactory_cCoverageData2)
    else:
        cCoverageData2 = _connect.SPtrFactory_cCoverageData2

    def __init__(self):
        this = _connect.new_SPtrFactory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SPtrFactory
    __del__ = lambda self: None
SPtrFactory_swigregister = _connect.SPtrFactory_swigregister
SPtrFactory_swigregister(SPtrFactory)

def SPtrFactory_cProfilerData2(sptr: 'std::shared_ptr< isys::CProfilerData2 > &') -> "isys::CProfilerData2 *":
    return _connect.SPtrFactory_cProfilerData2(sptr)
SPtrFactory_cProfilerData2 = _connect.SPtrFactory_cProfilerData2

def SPtrFactory_cCoverageData2(sptr: 'std::shared_ptr< isys::CCoverageData2 > &') -> "isys::CCoverageData2 *":
    return _connect.SPtrFactory_cCoverageData2(sptr)
SPtrFactory_cCoverageData2 = _connect.SPtrFactory_cCoverageData2

class CRemoteFileController(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CRemoteFileController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CRemoteFileController, name)
    __repr__ = _swig_repr

    def __init__(self, connectionMgr: 'std::shared_ptr< isys::ConnectionMgr >'):
        this = _connect.new_CRemoteFileController(connectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CRemoteFileController
    __del__ = lambda self: None

    def exists(self, fileName: 'std::string const &') -> "bool":
        return _connect.CRemoteFileController_exists(self, fileName)

    def remove(self, fileName: 'std::string const &') -> "bool":
        return _connect.CRemoteFileController_remove(self, fileName)

    def readFromRemote(self, remoteSrcFile: 'std::string const &', localDestFile: 'std::string const &') -> "void":
        return _connect.CRemoteFileController_readFromRemote(self, remoteSrcFile, localDestFile)

    def writeToRemote(self, localSrcFile: 'std::string const &', remoteDestFile: 'std::string const &') -> "void":
        return _connect.CRemoteFileController_writeToRemote(self, localSrcFile, remoteDestFile)
CRemoteFileController_swigregister = _connect.CRemoteFileController_swigregister
CRemoteFileController_swigregister(CRemoteFileController)

class CCodeStoreItem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCodeStoreItem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCodeStoreItem, name)
    __repr__ = _swig_repr

    def __init__(self, rspConnectionMgr: 'isys::SPConnectionMgr const &'):
        this = _connect.new_CCodeStoreItem(rspConnectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCodeStoreItem
    __del__ = lambda self: None

    def getAddress(self) -> "DWORD":
        return _connect.CCodeStoreItem_getAddress(self)

    def getLastAddress(self) -> "DWORD":
        return _connect.CCodeStoreItem_getLastAddress(self)

    def getSize(self) -> "DWORD":
        return _connect.CCodeStoreItem_getSize(self)

    def getAt(self, offset: 'DWORD') -> "BYTE":
        return _connect.CCodeStoreItem_getAt(self, offset)

    def getData(self, rvData: 'VectorBYTE') -> "void":
        return _connect.CCodeStoreItem_getData(self, rvData)
CCodeStoreItem_swigregister = _connect.CCodeStoreItem_swigregister
CCodeStoreItem_swigregister(CCodeStoreItem)

class CCodeStore(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCodeStore, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCodeStore, name)
    __repr__ = _swig_repr

    def __init__(self, rspConnectionMgr: 'isys::SPConnectionMgr const &'):
        this = _connect.new_CCodeStore(rspConnectionMgr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCodeStore
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _connect.CCodeStore_clear(self)

    def copy(self, rSrc: 'CCodeStore') -> "void":
        return _connect.CCodeStore_copy(self, rSrc)

    def load(self, dwFlags: 'DWORD', rstrFileName: 'std::string const &', aOffset: 'DWORD') -> "void":
        return _connect.CCodeStore_load(self, dwFlags, rstrFileName, aOffset)

    def save(self, dwFlags: 'DWORD', rstrFileName: 'std::string const &', aOffset: 'DWORD') -> "void":
        return _connect.CCodeStore_save(self, dwFlags, rstrFileName, aOffset)

    def insert(self, aAddress: 'DWORD', vBuffer: 'VectorBYTE') -> "void":
        return _connect.CCodeStore_insert(self, aAddress, vBuffer)

    def exclude(self, aAddressExcl: 'DWORD', aEndExcl: 'DWORD') -> "void":
        return _connect.CCodeStore_exclude(self, aAddressExcl, aEndExcl)

    def empty(self) -> "bool":
        return _connect.CCodeStore_empty(self)

    def numItems(self) -> "int":
        return _connect.CCodeStore_numItems(self)

    def getItem(self, nIndex: 'int') -> "isys::SPCodeStoreItem":
        return _connect.CCodeStore_getItem(self, nIndex)

    def findItem(self, aAddress: 'DWORD') -> "int":
        return _connect.CCodeStore_findItem(self, aAddress)

    def getBuffer(self, aAddress: 'DWORD', vBuffer: 'VectorBYTE') -> "DWORD":
        return _connect.CCodeStore_getBuffer(self, aAddress, vBuffer)

    def getTotal(self) -> "DWORD":
        return _connect.CCodeStore_getTotal(self)

    def getRangeLo(self) -> "DWORD":
        return _connect.CCodeStore_getRangeLo(self)

    def getRangeHi(self) -> "DWORD":
        return _connect.CCodeStore_getRangeHi(self)

    def report(self, fileReport: 'std::string const &', append: 'bool', format: 'std::string const &', maxInLine: 'DWORD') -> "bool":
        return _connect.CCodeStore_report(self, fileReport, append, format, maxInLine)

    def reportDif(self, fileReport: 'std::string const &', append: 'bool', format: 'std::string const &', maxInLine: 'DWORD', rCC1: 'CCodeStore', rCC2: 'CCodeStore') -> "bool":
        return _connect.CCodeStore_reportDif(self, fileReport, append, format, maxInLine, rCC1, rCC2)
CCodeStore_swigregister = _connect.CCodeStore_swigregister
CCodeStore_swigregister(CCodeStore)

ACCESS_OK = _connect.ACCESS_OK
ACCESS_FAIL = _connect.ACCESS_FAIL
arOK = _connect.arOK
arAccess = _connect.arAccess
arScope = _connect.arScope
arCPUMode = _connect.arCPUMode
arInvalid = _connect.arInvalid
arNum = _connect.arNum
class CAddress(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CAddress, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CAddress, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_aAddress"] = _connect.CAddress_m_aAddress_set
    __swig_getmethods__["m_aAddress"] = _connect.CAddress_m_aAddress_get
    if _newclass:
        m_aAddress = _swig_property(_connect.CAddress_m_aAddress_get, _connect.CAddress_m_aAddress_set)
    __swig_setmethods__["m_iArea"] = _connect.CAddress_m_iArea_set
    __swig_getmethods__["m_iArea"] = _connect.CAddress_m_iArea_get
    if _newclass:
        m_iArea = _swig_property(_connect.CAddress_m_iArea_get, _connect.CAddress_m_iArea_set)
    __swig_setmethods__["m_byProcess"] = _connect.CAddress_m_byProcess_set
    __swig_getmethods__["m_byProcess"] = _connect.CAddress_m_byProcess_get
    if _newclass:
        m_byProcess = _swig_property(_connect.CAddress_m_byProcess_get, _connect.CAddress_m_byProcess_set)
    __swig_setmethods__["m_byReserved"] = _connect.CAddress_m_byReserved_set
    __swig_getmethods__["m_byReserved"] = _connect.CAddress_m_byReserved_get
    if _newclass:
        m_byReserved = _swig_property(_connect.CAddress_m_byReserved_get, _connect.CAddress_m_byReserved_set)

    def __init__(self):
        this = _connect.new_CAddress()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CAddress
    __del__ = lambda self: None
CAddress_swigregister = _connect.CAddress_swigregister
CAddress_swigregister(CAddress)

class SValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SValue, name)
    __repr__ = _swig_repr
    MAX_INT_BITS = _connect.SValue_MAX_INT_BITS
    MAX_FLT_BITS = _connect.SValue_MAX_FLT_BITS

    def __init__(self):
        this = _connect.new_SValue()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SValue
    __del__ = lambda self: None
SValue_swigregister = _connect.SValue_swigregister
SValue_swigregister(SValue)

class SType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SType, name)
    __repr__ = _swig_repr
    tUndefined = _connect.SType_tUndefined
    tUnsigned = _connect.SType_tUnsigned
    tSigned = _connect.SType_tSigned
    tFloat = _connect.SType_tFloat
    tAddress = _connect.SType_tAddress
    tCompound = _connect.SType_tCompound
    __swig_setmethods__["m_byType"] = _connect.SType_m_byType_set
    __swig_getmethods__["m_byType"] = _connect.SType_m_byType_get
    if _newclass:
        m_byType = _swig_property(_connect.SType_m_byType_get, _connect.SType_m_byType_set)
    __swig_setmethods__["m_byBitSize"] = _connect.SType_m_byBitSize_set
    __swig_getmethods__["m_byBitSize"] = _connect.SType_m_byBitSize_get
    if _newclass:
        m_byBitSize = _swig_property(_connect.SType_m_byBitSize_get, _connect.SType_m_byBitSize_set)

    def __init__(self):
        this = _connect.new_SType()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SType
    __del__ = lambda self: None
SType_swigregister = _connect.SType_swigregister
SType_swigregister(SType)

class SType2(SType):
    __swig_setmethods__ = {}
    for _s in [SType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SType2, name, value)
    __swig_getmethods__ = {}
    for _s in [SType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SType2, name)
    __repr__ = _swig_repr
    t2Regular = _connect.SType2_t2Regular
    t2BitField = _connect.SType2_t2BitField
    t2Enum = _connect.SType2_t2Enum
    t2Struct = _connect.SType2_t2Struct
    t2Union = _connect.SType2_t2Union
    t2Class = _connect.SType2_t2Class
    t2Pointer = _connect.SType2_t2Pointer
    t2Reference = _connect.SType2_t2Reference
    t2Array = _connect.SType2_t2Array
    t2Function = _connect.SType2_t2Function
    __swig_setmethods__["m_byType2"] = _connect.SType2_m_byType2_set
    __swig_getmethods__["m_byType2"] = _connect.SType2_m_byType2_get
    if _newclass:
        m_byType2 = _swig_property(_connect.SType2_m_byType2_get, _connect.SType2_m_byType2_set)
    __swig_setmethods__["m_byReserved"] = _connect.SType2_m_byReserved_set
    __swig_getmethods__["m_byReserved"] = _connect.SType2_m_byReserved_get
    if _newclass:
        m_byReserved = _swig_property(_connect.SType2_m_byReserved_get, _connect.SType2_m_byReserved_set)
    __swig_setmethods__["m_dw1"] = _connect.SType2_m_dw1_set
    __swig_getmethods__["m_dw1"] = _connect.SType2_m_dw1_get
    if _newclass:
        m_dw1 = _swig_property(_connect.SType2_m_dw1_get, _connect.SType2_m_dw1_set)
    __swig_setmethods__["m_dw2"] = _connect.SType2_m_dw2_set
    __swig_getmethods__["m_dw2"] = _connect.SType2_m_dw2_get
    if _newclass:
        m_dw2 = _swig_property(_connect.SType2_m_dw2_get, _connect.SType2_m_dw2_set)

    def __init__(self):
        this = _connect.new_SType2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SType2
    __del__ = lambda self: None
SType2_swigregister = _connect.SType2_swigregister
SType2_swigregister(SType2)

endianLittle = _connect.endianLittle
endianBig = _connect.endianBig
class CCPUInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCPUInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCPUInfo, name)
    __repr__ = _swig_repr
    cpu_8051 = _connect.CCPUInfo_cpu_8051
    cpu_PowerPC = _connect.CCPUInfo_cpu_PowerPC
    cpu_ARM = _connect.CCPUInfo_cpu_ARM
    cpu_V850 = _connect.CCPUInfo_cpu_V850
    cpu_TPU = _connect.CCPUInfo_cpu_TPU
    cpu_TriCore = _connect.CCPUInfo_cpu_TriCore
    cpu_PCP = _connect.CCPUInfo_cpu_PCP
    cpu_GTM = _connect.CCPUInfo_cpu_GTM
    cpu_RX = _connect.CCPUInfo_cpu_RX
    cpu_SPT = _connect.CCPUInfo_cpu_SPT
    cpu_Num = _connect.CCPUInfo_cpu_Num
    cpu_Generic = _connect.CCPUInfo_cpu_Generic
    __swig_setmethods__["m_wCPU"] = _connect.CCPUInfo_m_wCPU_set
    __swig_getmethods__["m_wCPU"] = _connect.CCPUInfo_m_wCPU_get
    if _newclass:
        m_wCPU = _swig_property(_connect.CCPUInfo_m_wCPU_get, _connect.CCPUInfo_m_wCPU_set)
    v8051_8051 = _connect.CCPUInfo_v8051_8051
    v8051_8051MX = _connect.CCPUInfo_v8051_8051MX
    v8051_Num = _connect.CCPUInfo_v8051_Num
    vPowerPC_4xx = _connect.CCPUInfo_vPowerPC_4xx
    vPowerPC_5xx = _connect.CCPUInfo_vPowerPC_5xx
    vPowerPC_6xx = _connect.CCPUInfo_vPowerPC_6xx
    vPowerPC_7xx = _connect.CCPUInfo_vPowerPC_7xx
    vPowerPC_8xx = _connect.CCPUInfo_vPowerPC_8xx
    vPowerPC_G5 = _connect.CCPUInfo_vPowerPC_G5
    vPowerPC_G3 = _connect.CCPUInfo_vPowerPC_G3
    vPowerPC_Num = _connect.CCPUInfo_vPowerPC_Num
    vARM_v3 = _connect.CCPUInfo_vARM_v3
    vARM_v4T = _connect.CCPUInfo_vARM_v4T
    vARM_v5TE = _connect.CCPUInfo_vARM_v5TE
    vARM_v5TEJ = _connect.CCPUInfo_vARM_v5TEJ
    vARM_v6 = _connect.CCPUInfo_vARM_v6
    vARM_v7A = _connect.CCPUInfo_vARM_v7A
    vARM_v7R = _connect.CCPUInfo_vARM_v7R
    vARM_v7M = _connect.CCPUInfo_vARM_v7M
    vARM_v6M = _connect.CCPUInfo_vARM_v6M
    vARM_v8A = _connect.CCPUInfo_vARM_v8A
    vARM_v8R = _connect.CCPUInfo_vARM_v8R
    vARM_v8M = _connect.CCPUInfo_vARM_v8M
    vARM_Num = _connect.CCPUInfo_vARM_Num
    svARM_CortexMask = _connect.CCPUInfo_svARM_CortexMask
    svARM_CortexM = _connect.CCPUInfo_svARM_CortexM
    svARM_CortexM0 = _connect.CCPUInfo_svARM_CortexM0
    svARM_CortexM1 = _connect.CCPUInfo_svARM_CortexM1
    svARM_CortexM3 = _connect.CCPUInfo_svARM_CortexM3
    svARM_CortexM4 = _connect.CCPUInfo_svARM_CortexM4
    svARM_CortexM7 = _connect.CCPUInfo_svARM_CortexM7
    svARM_CortexR = _connect.CCPUInfo_svARM_CortexR
    svARM_CortexR4 = _connect.CCPUInfo_svARM_CortexR4
    svARM_CortexR5 = _connect.CCPUInfo_svARM_CortexR5
    svARM_CortexR7 = _connect.CCPUInfo_svARM_CortexR7
    svARM_CortexR52 = _connect.CCPUInfo_svARM_CortexR52
    svARM_CortexA = _connect.CCPUInfo_svARM_CortexA
    svARM_CortexA5 = _connect.CCPUInfo_svARM_CortexA5
    svARM_CortexA7 = _connect.CCPUInfo_svARM_CortexA7
    svARM_CortexA8 = _connect.CCPUInfo_svARM_CortexA8
    svARM_CortexA9 = _connect.CCPUInfo_svARM_CortexA9
    svARM_CortexA15 = _connect.CCPUInfo_svARM_CortexA15
    svARM_CortexA17 = _connect.CCPUInfo_svARM_CortexA17
    svARM_CortexA32 = _connect.CCPUInfo_svARM_CortexA32
    svARM_CortexA35 = _connect.CCPUInfo_svARM_CortexA35
    svARM_CortexA53 = _connect.CCPUInfo_svARM_CortexA53
    svARM_CortexA57 = _connect.CCPUInfo_svARM_CortexA57
    svARM_CortexA72 = _connect.CCPUInfo_svARM_CortexA72
    sARMv8_EL0 = _connect.CCPUInfo_sARMv8_EL0
    sARMv8_EL1 = _connect.CCPUInfo_sARMv8_EL1
    sARMv8_EL2 = _connect.CCPUInfo_sARMv8_EL2
    sARMv8_EL3 = _connect.CCPUInfo_sARMv8_EL3
    sARMv8_ELMask = _connect.CCPUInfo_sARMv8_ELMask
    sARMv8_Secure = _connect.CCPUInfo_sARMv8_Secure
    sARMv7_PL0 = _connect.CCPUInfo_sARMv7_PL0
    sARMv7_PL1 = _connect.CCPUInfo_sARMv7_PL1
    sARMv7_PL2 = _connect.CCPUInfo_sARMv7_PL2
    sARMv7_ELMask = _connect.CCPUInfo_sARMv7_ELMask
    sARMv7_Secure = _connect.CCPUInfo_sARMv7_Secure
    vV850_V850 = _connect.CCPUInfo_vV850_V850
    vV850_V850E3v5 = _connect.CCPUInfo_vV850_V850E3v5
    vV850_Num = _connect.CCPUInfo_vV850_Num
    veTPU = _connect.CCPUInfo_veTPU
    vTPU_Num = _connect.CCPUInfo_vTPU_Num
    veGTM = _connect.CCPUInfo_veGTM
    vGTM_Num = _connect.CCPUInfo_vGTM_Num
    vTriCore13 = _connect.CCPUInfo_vTriCore13
    vTriCore16 = _connect.CCPUInfo_vTriCore16
    vTriCore161 = _connect.CCPUInfo_vTriCore161
    vTriCore162P = _connect.CCPUInfo_vTriCore162P
    vTriCore_Num = _connect.CCPUInfo_vTriCore_Num
    vPCP = _connect.CCPUInfo_vPCP
    vPCP_Num = _connect.CCPUInfo_vPCP_Num
    vRX = _connect.CCPUInfo_vRX
    vRX_Num = _connect.CCPUInfo_vRX_Num
    vSPT_v1 = _connect.CCPUInfo_vSPT_v1
    vSPT_v2 = _connect.CCPUInfo_vSPT_v2
    vSPT_v2_5 = _connect.CCPUInfo_vSPT_v2_5
    vSPT_Num = _connect.CCPUInfo_vSPT_Num
    __swig_setmethods__["m_wVariant"] = _connect.CCPUInfo_m_wVariant_set
    __swig_getmethods__["m_wVariant"] = _connect.CCPUInfo_m_wVariant_get
    if _newclass:
        m_wVariant = _swig_property(_connect.CCPUInfo_m_wVariant_get, _connect.CCPUInfo_m_wVariant_set)
    __swig_setmethods__["m_wSubVariant"] = _connect.CCPUInfo_m_wSubVariant_set
    __swig_getmethods__["m_wSubVariant"] = _connect.CCPUInfo_m_wSubVariant_get
    if _newclass:
        m_wSubVariant = _swig_property(_connect.CCPUInfo_m_wSubVariant_get, _connect.CCPUInfo_m_wSubVariant_set)

    def __init__(self):
        this = _connect.new_CCPUInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CCPUInfo
    __del__ = lambda self: None
CCPUInfo_swigregister = _connect.CCPUInfo_swigregister
CCPUInfo_swigregister(CCPUInfo)

class CMMUInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMMUInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CMMUInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_wType"] = _connect.CMMUInfo_m_wType_set
    __swig_getmethods__["m_wType"] = _connect.CMMUInfo_m_wType_get
    if _newclass:
        m_wType = _swig_property(_connect.CMMUInfo_m_wType_get, _connect.CMMUInfo_m_wType_set)
    __swig_setmethods__["m_dwInfo"] = _connect.CMMUInfo_m_dwInfo_set
    __swig_getmethods__["m_dwInfo"] = _connect.CMMUInfo_m_dwInfo_get
    if _newclass:
        m_dwInfo = _swig_property(_connect.CMMUInfo_m_dwInfo_get, _connect.CMMUInfo_m_dwInfo_set)
    tPPC_None = _connect.CMMUInfo_tPPC_None
    tPPC_E_440 = _connect.CMMUInfo_tPPC_E_440
    tPPC_E_e200 = _connect.CMMUInfo_tPPC_E_e200
    tPPC_E_40x = _connect.CMMUInfo_tPPC_E_40x

    def __init__(self):
        this = _connect.new_CMMUInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CMMUInfo
    __del__ = lambda self: None
CMMUInfo_swigregister = _connect.CMMUInfo_swigregister
CMMUInfo_swigregister(CMMUInfo)

mempMode0 = _connect.mempMode0
mempMode1 = _connect.mempMode1
mempEndianBig = _connect.mempEndianBig
mempEndianLittle = _connect.mempEndianLittle
mempReserved5 = _connect.mempReserved5
mempReserved6 = _connect.mempReserved6
mempReserved7 = _connect.mempReserved7
mempModeEx0 = _connect.mempModeEx0
mempModeEx1 = _connect.mempModeEx1
mempModeEx2 = _connect.mempModeEx2
mempModeEx3 = _connect.mempModeEx3
mempBlockRead = _connect.mempBlockRead
mempBlockWrite = _connect.mempBlockWrite
mempBlock1MAUAccess = _connect.mempBlock1MAUAccess
mempBlock2MAUAccess = _connect.mempBlock2MAUAccess
mempBlock4MAUAccess = _connect.mempBlock4MAUAccess
mempBlock8MAUAccess = _connect.mempBlock8MAUAccess
mempNum = _connect.mempNum
mempISANum = _connect.mempISANum
mempISAMask = _connect.mempISAMask
mempISA0 = _connect.mempISA0
mempISA1 = _connect.mempISA1
mempISA2 = _connect.mempISA2
mempISA3 = _connect.mempISA3
cpumodeAll = _connect.cpumodeAll
maCODE31 = _connect.maCODE31
maDATA31 = _connect.maDATA31
maIDATA31 = _connect.maIDATA31
maBDATA31 = _connect.maBDATA31
maXDATA31 = _connect.maXDATA31
maPDATA31 = _connect.maPDATA31
maSFR31 = _connect.maSFR31
maLogicalHC12 = _connect.maLogicalHC12
maBankHC12 = _connect.maBankHC12
maLinearHC12 = _connect.maLinearHC12
maPhysical166 = _connect.maPhysical166
maLogical166 = _connect.maLogical166
maBDATA166 = _connect.maBDATA166
mempModeEx166EXTR = _connect.mempModeEx166EXTR
mempModeEx166EXTP = _connect.mempModeEx166EXTP
mempModeEx166EXTS = _connect.mempModeEx166EXTS
mempModePowerPCVLE = _connect.mempModePowerPCVLE
mempISA_PPC_PPC = _connect.mempISA_PPC_PPC
mempISA_PPC_VLE = _connect.mempISA_PPC_VLE
maVirtualPowerPC = _connect.maVirtualPowerPC
maPPhysicalPowerPC = _connect.maPPhysicalPowerPC
maUPhysicalPowerPC = _connect.maUPhysicalPowerPC
maSPRPowerPC = _connect.maSPRPowerPC
maDCRPowerPC = _connect.maDCRPowerPC
maTLBPowerPC = _connect.maTLBPowerPC
maPMRPowerPC = _connect.maPMRPowerPC
mempModeARMThumb = _connect.mempModeARMThumb
mempISA_ARM_A32 = _connect.mempISA_ARM_A32
mempISA_ARM_T = _connect.mempISA_ARM_T
cpumodeUser = _connect.cpumodeUser
cpumodeFIQ = _connect.cpumodeFIQ
cpumodeIRQ = _connect.cpumodeIRQ
cpumodeSupervisor = _connect.cpumodeSupervisor
cpumodeAbortMode = _connect.cpumodeAbortMode
cpumodeSystem = _connect.cpumodeSystem
cpumodeUndefined = _connect.cpumodeUndefined
maVirtualARM = _connect.maVirtualARM
maIPA_ARM = _connect.maIPA_ARM
maCPARM = _connect.maCPARM
maVFPARM = _connect.maVFPARM
maSP_ARM = _connect.maSP_ARM
maNP_ARM = _connect.maNP_ARM
maEL1S_ARM = _connect.maEL1S_ARM
maEL1N_ARM = _connect.maEL1N_ARM
maEL2N_ARM = _connect.maEL2N_ARM
maEL3S_ARM = _connect.maEL3S_ARM
maPL1S_ARM = _connect.maPL1S_ARM
maPL1N_ARM = _connect.maPL1N_ARM
maPL2N_ARM = _connect.maPL2N_ARM
maProgramCoolRISC = _connect.maProgramCoolRISC
maDataCoolRISC = _connect.maDataCoolRISC
maASIICData = _connect.maASIICData
maPhysicalV850 = _connect.maPhysicalV850
maHostV850 = _connect.maHostV850
maSysRegV850 = _connect.maSysRegV850
maPhysicalARC = _connect.maPhysicalARC
maAUXARC = _connect.maAUXARC
maPhysical78k = _connect.maPhysical78k
maER78k = _connect.maER78k
maPhysicalMSP430 = _connect.maPhysicalMSP430
maPhysicalXGATE = _connect.maPhysicalXGATE
maSCMTPU = _connect.maSCMTPU
maSPRAMTPU = _connect.maSPRAMTPU
maVirtualGTM = _connect.maVirtualGTM
maVirtualTriCore = _connect.maVirtualTriCore
maPhysicalTriCore = _connect.maPhysicalTriCore
maCerberusTricore = _connect.maCerberusTricore
maCMEMPCP = _connect.maCMEMPCP
maPRAMPCP = _connect.maPRAMPCP
maLinearS12Z = _connect.maLinearS12Z
maVirtualRX = _connect.maVirtualRX
maVirtualSPT = _connect.maVirtualSPT
maOP_RAM = _connect.maOP_RAM
maTW_RAM = _connect.maTW_RAM
ICONNECT_E_CONNECT_FAILED = _connect.ICONNECT_E_CONNECT_FAILED
ICONNECT_E_VERSION_CONFLICT = _connect.ICONNECT_E_VERSION_CONFLICT
ICONNECT_E_ALREADY_CONNECTED = _connect.ICONNECT_E_ALREADY_CONNECTED
ICONNECT_E_NOT_CONNECTED = _connect.ICONNECT_E_NOT_CONNECTED
ICONNECT_E_FILE_NOT_FOUND = _connect.ICONNECT_E_FILE_NOT_FOUND
ICONNECT_E_CAN_NOT_ACCESS = _connect.ICONNECT_E_CAN_NOT_ACCESS
ICONNECT_E_BAD_ID = _connect.ICONNECT_E_BAD_ID
ICONNECT_E_NOT_SIMPLE_TYPE = _connect.ICONNECT_E_NOT_SIMPLE_TYPE
ICONNECT_E_ERROR = _connect.ICONNECT_E_ERROR
ICONNECT_E_NO_BREAKPOINT = _connect.ICONNECT_E_NO_BREAKPOINT
ICONNECT_E_NOT_AVAILABLE = _connect.ICONNECT_E_NOT_AVAILABLE
ICONNECT_E_SIZE = _connect.ICONNECT_E_SIZE
ICONNECT_E_ALREADY_EXISTS = _connect.ICONNECT_E_ALREADY_EXISTS
ICONNECT_E_TIMEOUT = _connect.ICONNECT_E_TIMEOUT
ICONNECT_E_LICENSE = _connect.ICONNECT_E_LICENSE
ICONNECT_E_BUSY = _connect.ICONNECT_E_BUSY
ICONNECT_E_MSG_FAIL = _connect.ICONNECT_E_MSG_FAIL
ICONNECT_E_ROUTING = _connect.ICONNECT_E_ROUTING
ICONNECT_E_UMI_FAIL = _connect.ICONNECT_E_UMI_FAIL
ICONNECT_S_SIZE = _connect.ICONNECT_S_SIZE
ICONNECT_S_MSG_FAIL = _connect.ICONNECT_S_MSG_FAIL
ICONNECT_S_MSG_WARN = _connect.ICONNECT_S_MSG_WARN
ICONNECT_S_STATUS_1 = _connect.ICONNECT_S_STATUS_1
ICONNECT_S_STATUS_2 = _connect.ICONNECT_S_STATUS_2
ICONNECT_S_STATUS_3 = _connect.ICONNECT_S_STATUS_3
ICONNECT_S_STATUS_4 = _connect.ICONNECT_S_STATUS_4
ICONNECT_S_STATUS_FLAGSMASK = _connect.ICONNECT_S_STATUS_FLAGSMASK
class IConnect(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnect, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnect, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    dfCloseServerIfLastClient = _connect.IConnect_dfCloseServerIfLastClient
    dfCloseServerUnconditional = _connect.IConnect_dfCloseServerUnconditional
    dfCloseServerMask = _connect.IConnect_dfCloseServerMask
    dfCloseAutoSaveDefault = _connect.IConnect_dfCloseAutoSaveDefault
    dfCloseAutoSaveAll = _connect.IConnect_dfCloseAutoSaveAll
    dfCloseAutoSaveNone = _connect.IConnect_dfCloseAutoSaveNone
    dfCloseAutoSaveMask = _connect.IConnect_dfCloseAutoSaveMask

    def Detach(self, dwDetachFlags: 'DWORD'=0) -> "unsigned long":
        return _connect.IConnect_Detach(self, dwDetachFlags)
    lfStartNever = _connect.IConnect_lfStartNever
    lfStartIfRequired = _connect.IConnect_lfStartIfRequired
    lfStartAlways = _connect.IConnect_lfStartAlways
    lfStartExisting = _connect.IConnect_lfStartExisting
    lfStartEnumerate = _connect.IConnect_lfStartEnumerate
    lfStartMask = _connect.IConnect_lfStartMask
    lfWaitDefault = _connect.IConnect_lfWaitDefault
    lfWait30ms = _connect.IConnect_lfWait30ms
    lfWait100ms = _connect.IConnect_lfWait100ms
    lfWait300ms = _connect.IConnect_lfWait300ms
    lfWait1s = _connect.IConnect_lfWait1s
    lfWait3s = _connect.IConnect_lfWait3s
    lfWait10s = _connect.IConnect_lfWait10s
    lfWait30s = _connect.IConnect_lfWait30s
    lfWaitMask = _connect.IConnect_lfWaitMask
    lfUseIPCDiscovery = _connect.IConnect_lfUseIPCDiscovery
    lfShowDefault = _connect.IConnect_lfShowDefault
    lfShowMinimized = _connect.IConnect_lfShowMinimized
    lfShowMaximized = _connect.IConnect_lfShowMaximized
    lfShowHidden = _connect.IConnect_lfShowHidden
    lfShowMask = _connect.IConnect_lfShowMask
    lfSLaunch = _connect.IConnect_lfSLaunch
    lfSLaunch1_1_1 = _connect.IConnect_lfSLaunch1_1_1
    lfSLaunchMask = _connect.IConnect_lfSLaunchMask
    __swig_destroy__ = _connect.delete_IConnect
    __del__ = lambda self: None
IConnect_swigregister = _connect.IConnect_swigregister
IConnect_swigregister(IConnect)

class IConnectIDE(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectIDE, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectIDE, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxDocument = _connect.IConnectIDE_ndxDocument
    ndxWorkspace = _connect.IConnectIDE_ndxWorkspace
    ndxApplication = _connect.IConnectIDE_ndxApplication
    ndxNum = _connect.IConnectIDE_ndxNum
    ffIsOpen = _connect.IConnectIDE_ffIsOpen
    ffClose = _connect.IConnectIDE_ffClose
    ffCloseAll = _connect.IConnectIDE_ffCloseAll
    ffCloseDiscard = _connect.IConnectIDE_ffCloseDiscard
    ffSave = _connect.IConnectIDE_ffSave
    ffSaveAs = _connect.IConnectIDE_ffSaveAs
    ffSaveAsPrompt = _connect.IConnectIDE_ffSaveAsPrompt
    ffSaveAll = _connect.IConnectIDE_ffSaveAll
    ffSaveAsOverwrite = _connect.IConnectIDE_ffSaveAsOverwrite
    ffSaveCopyAsOverwrite = _connect.IConnectIDE_ffSaveCopyAsOverwrite
    ffNew = _connect.IConnectIDE_ffNew
    ffNewPrompt = _connect.IConnectIDE_ffNewPrompt
    ffOpen = _connect.IConnectIDE_ffOpen
    ffOpenPrompt = _connect.IConnectIDE_ffOpenPrompt
    ffOpenOrNew = _connect.IConnectIDE_ffOpenOrNew
    ffActionMask = _connect.IConnectIDE_ffActionMask
    ffCreateObjectOnly = _connect.IConnectIDE_ffCreateObjectOnly
    dmMarkSet = _connect.IConnectIDE_dmMarkSet
    dmMarkClear = _connect.IConnectIDE_dmMarkClear
    dmMarkPos = _connect.IConnectIDE_dmMarkPos
    dmMarkMask = _connect.IConnectIDE_dmMarkMask
    dfFocus = _connect.IConnectIDE_dfFocus
    dfSpecialWindow = _connect.IConnectIDE_dfSpecialWindow
    dtText = _connect.IConnectIDE_dtText
    dtAnalyzer = _connect.IConnectIDE_dtAnalyzer
    dtCodeCoverage = _connect.IConnectIDE_dtCodeCoverage
    dtDataCoverage = _connect.IConnectIDE_dtDataCoverage
    dtMask = _connect.IConnectIDE_dtMask
    dwTerminal = _connect.IConnectIDE_dwTerminal
    dwDisassembly = _connect.IConnectIDE_dwDisassembly
    dwBreakpoints = _connect.IConnectIDE_dwBreakpoints
    dwMask = _connect.IConnectIDE_dwMask
    daStart = _connect.IConnectIDE_daStart
    daStop = _connect.IConnectIDE_daStop
    daStatus = _connect.IConnectIDE_daStatus
    daResume = _connect.IConnectIDE_daResume
    daSelect = _connect.IConnectIDE_daSelect
    daExport = _connect.IConnectIDE_daExport
    daExportV = _connect.IConnectIDE_daExportV
    daSetExportFormat = _connect.IConnectIDE_daSetExportFormat
    daDeactivate = _connect.IConnectIDE_daDeactivate
    daReset = _connect.IConnectIDE_daReset
    daStart1 = _connect.IConnectIDE_daStart1
    daAbort = _connect.IConnectIDE_daAbort
    daDirty = _connect.IConnectIDE_daDirty
    daMask = _connect.IConnectIDE_daMask
    deFormatMask = _connect.IConnectIDE_deFormatMask
    deScopeAll = _connect.IConnectIDE_deScopeAll
    deScopeSelection = _connect.IConnectIDE_deScopeSelection
    deScopeMask = _connect.IConnectIDE_deScopeMask
    drContent = _connect.IConnectIDE_drContent
    drItem = _connect.IConnectIDE_drItem
    drItemMask = _connect.IConnectIDE_drItemMask
    drConfigAll = _connect.IConnectIDE_drConfigAll
    drConfigSelected = _connect.IConnectIDE_drConfigSelected
    drConfigPresetInit = _connect.IConnectIDE_drConfigPresetInit
    drConfigPresetApply = _connect.IConnectIDE_drConfigPresetApply
    drConfigMask = _connect.IConnectIDE_drConfigMask
    dsReturnFlags = _connect.IConnectIDE_dsReturnFlags
    dsDomainMask = _connect.IConnectIDE_dsDomainMask
    dsDomainDefault = _connect.IConnectIDE_dsDomainDefault
    dsDomainSession = _connect.IConnectIDE_dsDomainSession
    dsDomainDocument = _connect.IConnectIDE_dsDomainDocument
    sfasRecorderMask = _connect.IConnectIDE_sfasRecorderMask
    sfasRecorderIdle = _connect.IConnectIDE_sfasRecorderIdle
    sfasRecorderWaiting = _connect.IConnectIDE_sfasRecorderWaiting
    sfasRecorderSampling = _connect.IConnectIDE_sfasRecorderSampling
    sfasLoading = _connect.IConnectIDE_sfasLoading
    sfasAnalyzing = _connect.IConnectIDE_sfasAnalyzing
    sfasError = _connect.IConnectIDE_sfasError
    sfasOverrun = _connect.IConnectIDE_sfasOverrun
    sfadSerializing = _connect.IConnectIDE_sfadSerializing
    sfadNoData = _connect.IConnectIDE_sfadNoData
    sfadIsDirty = _connect.IConnectIDE_sfadIsDirty
    sfadCanStart = _connect.IConnectIDE_sfadCanStart
    sfaErrorsInBuffer = _connect.IConnectIDE_sfaErrorsInBuffer
    sfaBufferOverrun = _connect.IConnectIDE_sfaBufferOverrun
    sfaLoading = _connect.IConnectIDE_sfaLoading
    sfaRecordingError = _connect.IConnectIDE_sfaRecordingError
    sfaWaiting = _connect.IConnectIDE_sfaWaiting
    sfaEmpty = _connect.IConnectIDE_sfaEmpty
    sfaOpening = _connect.IConnectIDE_sfaOpening
    asStopActionMask = _connect.IConnectIDE_asStopActionMask
    asStopSamplingOrAnalyzingAndWait = _connect.IConnectIDE_asStopSamplingOrAnalyzingAndWait
    asSampling = _connect.IConnectIDE_asSampling
    asUploading = _connect.IConnectIDE_asUploading
    asAnalyzing = _connect.IConnectIDE_asAnalyzing
    asSerializing = _connect.IConnectIDE_asSerializing

    def Document(self, dwDocumentFlags: 'DWORD', pszFileName: 'LPCSTR', pszParameter: 'LPCSTR'=None, dwParameter: 'DWORD'=0) -> "unsigned long":
        return _connect.IConnectIDE_Document(self, dwDocumentFlags, pszFileName, pszParameter, dwParameter)

    def Workspace(self, dwFileFlags: 'DWORD', pszWorkspaceName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectIDE_Workspace(self, dwFileFlags, pszWorkspaceName)
    afWindowActivate = _connect.IConnectIDE_afWindowActivate
    afWindowMinimize = _connect.IConnectIDE_afWindowMinimize
    afWindowRestore = _connect.IConnectIDE_afWindowRestore
    afWindowMaximize = _connect.IConnectIDE_afWindowMaximize
    afWindowMove = _connect.IConnectIDE_afWindowMove
    afWindowMask = _connect.IConnectIDE_afWindowMask
    afHookMsgBoxSet = _connect.IConnectIDE_afHookMsgBoxSet
    afHookMsgBoxClr = _connect.IConnectIDE_afHookMsgBoxClr
    afHookMsgBoxGet = _connect.IConnectIDE_afHookMsgBoxGet
    afHookMsgBoxAll = _connect.IConnectIDE_afHookMsgBoxAll
    afHookMsgBoxAllClr = _connect.IConnectIDE_afHookMsgBoxAllClr
    afHookMsgBoxMask = _connect.IConnectIDE_afHookMsgBoxMask
    afiOPEN_Disconnect = _connect.IConnectIDE_afiOPEN_Disconnect
    afiOPEN_Mask = _connect.IConnectIDE_afiOPEN_Mask
    __swig_destroy__ = _connect.delete_IConnectIDE
    __del__ = lambda self: None
IConnectIDE_swigregister = _connect.IConnectIDE_swigregister
IConnectIDE_swigregister(IConnectIDE)

class IConnectDebug(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectDebug, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectDebug, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectDebug_ndxGetInfo
    ndxGetAddress = _connect.IConnectDebug_ndxGetAddress
    ndxGetSymbol = _connect.IConnectDebug_ndxGetSymbol
    ndxGetSourceAddress = _connect.IConnectDebug_ndxGetSourceAddress
    ndxGetAddressSource = _connect.IConnectDebug_ndxGetAddressSource
    ndxReadMemory = _connect.IConnectDebug_ndxReadMemory
    ndxWriteMemory = _connect.IConnectDebug_ndxWriteMemory
    ndxReadRegister = _connect.IConnectDebug_ndxReadRegister
    ndxWriteRegister = _connect.IConnectDebug_ndxWriteRegister
    ndxReadValue = _connect.IConnectDebug_ndxReadValue
    ndxWriteValue = _connect.IConnectDebug_ndxWriteValue
    ndxEvaluate = _connect.IConnectDebug_ndxEvaluate
    ndxModify = _connect.IConnectDebug_ndxModify
    ndxGetStatus = _connect.IConnectDebug_ndxGetStatus
    ndxSetBreakpoint = _connect.IConnectDebug_ndxSetBreakpoint
    ndxRunControl = _connect.IConnectDebug_ndxRunControl
    ndxNum = _connect.IConnectDebug_ndxNum
    fMonitor = _connect.IConnectDebug_fMonitor
    fRealTime = _connect.IConnectDebug_fRealTime
    fMemMask = _connect.IConnectDebug_fMemMask
    fCore = _connect.IConnectDebug_fCore
    fSFR = _connect.IConnectDebug_fSFR
    fRegMask = _connect.IConnectDebug_fRegMask
    fCacheNever = _connect.IConnectDebug_fCacheNever
    fCacheDefault = _connect.IConnectDebug_fCacheDefault
    fCacheStop = _connect.IConnectDebug_fCacheStop
    fCacheCode = _connect.IConnectDebug_fCacheCode
    fCacheMask = _connect.IConnectDebug_fCacheMask
    fNoRefresh = _connect.IConnectDebug_fNoRefresh
    fAccessFlagsMask = _connect.IConnectDebug_fAccessFlagsMask
    gafExpression = _connect.IConnectDebug_gafExpression
    gafVariables = _connect.IConnectDebug_gafVariables
    gafLabels = _connect.IConnectDebug_gafLabels
    gafFunctions = _connect.IConnectDebug_gafFunctions
    gafEnumMask = _connect.IConnectDebug_gafEnumMask
    gafEnumIndexMask = _connect.IConnectDebug_gafEnumIndexMask
    gafEnumIndexOfs = _connect.IConnectDebug_gafEnumIndexOfs
    gafType2 = _connect.IConnectDebug_gafType2
    gafUseFile = _connect.IConnectDebug_gafUseFile
    gafFileMask = _connect.IConnectDebug_gafFileMask
    gafFileOfs = _connect.IConnectDebug_gafFileOfs
    efDefaultMemAreaDisplay = _connect.IConnectDebug_efDefaultMemAreaDisplay
    efNoMemAreaDisplay = _connect.IConnectDebug_efNoMemAreaDisplay
    efVagueFloatEqual = _connect.IConnectDebug_efVagueFloatEqual
    efIgnorePointerAssignType = _connect.IConnectDebug_efIgnorePointerAssignType
    efType2 = _connect.IConnectDebug_efType2
    efAllowTernaryOperator = _connect.IConnectDebug_efAllowTernaryOperator

    def GetAddress(self, dwGetAddressFlags: 'DWORD', pszExpression: 'LPCSTR', pbyMemArea: 'BYTE *', paAddress: 'uint32_t *', paSizeMAUs: 'uint32_t *', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug_GetAddress(self, dwGetAddressFlags, pszExpression, pbyMemArea, paAddress, paSizeMAUs, pType)
    sVariables = _connect.IConnectDebug_sVariables
    sLabels = _connect.IConnectDebug_sLabels
    sFunctions = _connect.IConnectDebug_sFunctions
    sLines = _connect.IConnectDebug_sLines
    sConstants = _connect.IConnectDebug_sConstants
    sSourceCode = _connect.IConnectDebug_sSourceCode
    sScopeExact = _connect.IConnectDebug_sScopeExact
    sScopeNarrow = _connect.IConnectDebug_sScopeNarrow
    sScopeWide = _connect.IConnectDebug_sScopeWide
    sScopeMask = _connect.IConnectDebug_sScopeMask

    def GetSymbol(self, dwSymbolFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'uint32_t', pszName: 'LPSTR', dwNameLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectDebug_GetSymbol(self, dwSymbolFlags, byMemArea, aAddress, pszName, dwNameLen)
    sExact = _connect.IConnectDebug_sExact
    sAbsolutePath = _connect.IConnectDebug_sAbsolutePath
    sReportSize = _connect.IConnectDebug_sReportSize

    def GetSourceAddress(self, dwSourceFlags: 'DWORD', pszFileName: 'LPCSTR', dwLine: 'DWORD', paAddress: 'uint32_t *', pdwNumAddresses: 'DWORD *') -> "unsigned long":
        return _connect.IConnectDebug_GetSourceAddress(self, dwSourceFlags, pszFileName, dwLine, paAddress, pdwNumAddresses)

    def GetAddressSource(self, dwSourceFlags: 'DWORD', aAddress: 'uint32_t', pszFileName: 'LPSTR', dwFileNameLen: 'DWORD', pdwLine: 'DWORD *') -> "unsigned long":
        return _connect.IConnectDebug_GetAddressSource(self, dwSourceFlags, aAddress, pszFileName, dwFileNameLen, pdwLine)

    def ReadMemory(self, dwAccessFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'uint32_t', aNumMAUs: 'uint32_t', pbyBuf: 'BYTE *', byBytesPerMAU: 'BYTE', pbyAccessInfo: 'BYTE *') -> "unsigned long":
        return _connect.IConnectDebug_ReadMemory(self, dwAccessFlags, byMemArea, aAddress, aNumMAUs, pbyBuf, byBytesPerMAU, pbyAccessInfo)

    def WriteMemory(self, dwAccessFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'uint32_t', aNumMAUs: 'uint32_t', pbyBuf: 'BYTE const *', byBytesPerMAU: 'BYTE', pbyAccessInfo: 'BYTE *') -> "unsigned long":
        return _connect.IConnectDebug_WriteMemory(self, dwAccessFlags, byMemArea, aAddress, aNumMAUs, pbyBuf, byBytesPerMAU, pbyAccessInfo)

    def ReadRegister(self, dwAccessFlags: 'DWORD', pszRegisterName: 'LPCSTR', pValue: 'SValue', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug_ReadRegister(self, dwAccessFlags, pszRegisterName, pValue, pType)

    def WriteRegister(self, dwAccessFlags: 'DWORD', pszRegisterName: 'LPCSTR', pValue: 'SValue', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug_WriteRegister(self, dwAccessFlags, pszRegisterName, pValue, pType)

    def ReadValue(self, dwAccessFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'uint32_t', pValue: 'SValue', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug_ReadValue(self, dwAccessFlags, byMemArea, aAddress, pValue, pType)

    def WriteValue(self, dwAccessFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'uint32_t', pValue: 'SValue', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug_WriteValue(self, dwAccessFlags, byMemArea, aAddress, pValue, pType)

    def Evaluate(self, dwAccessFlags: 'DWORD', pszExpression: 'LPCSTR', pszResult: 'LPSTR', dwResultLen: 'DWORD', pValue: 'SValue', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug_Evaluate(self, dwAccessFlags, pszExpression, pszResult, dwResultLen, pValue, pType)
    mfModifyToResult = _connect.IConnectDebug_mfModifyToResult
    mfModifyNoReadBack = _connect.IConnectDebug_mfModifyNoReadBack

    def Modify(self, dwModifyFlags: 'DWORD', pszExpression: 'LPCSTR', pszResult: 'LPSTR', dwResultLen: 'DWORD', pValue: 'SValue', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug_Modify(self, dwModifyFlags, pszExpression, pszResult, dwResultLen, pValue, pType)
    tCPU = _connect.IConnectDebug_tCPU
    tMask = _connect.IConnectDebug_tMask
    rCurrent = _connect.IConnectDebug_rCurrent
    rRefresh = _connect.IConnectDebug_rRefresh
    rMask = _connect.IConnectDebug_rMask
    sWantStopReason = _connect.IConnectDebug_sWantStopReason
    bAddress = _connect.IConnectDebug_bAddress
    bSymbol = _connect.IConnectDebug_bSymbol
    bSource = _connect.IConnectDebug_bSource
    bAddrMask = _connect.IConnectDebug_bAddrMask
    bHW = _connect.IConnectDebug_bHW
    bSet = _connect.IConnectDebug_bSet
    bClear = _connect.IConnectDebug_bClear
    bEnable = _connect.IConnectDebug_bEnable
    bDisable = _connect.IConnectDebug_bDisable
    bAll = _connect.IConnectDebug_bAll
    bReapply = _connect.IConnectDebug_bReapply
    bSetMask = _connect.IConnectDebug_bSetMask
    bHW_accAny = _connect.IConnectDebug_bHW_accAny
    bHW_accRD = _connect.IConnectDebug_bHW_accRD
    bHW_accWR = _connect.IConnectDebug_bHW_accWR
    bHW_accRW = _connect.IConnectDebug_bHW_accRW
    bHW_accFetch = _connect.IConnectDebug_bHW_accFetch
    bHW_accMask = _connect.IConnectDebug_bHW_accMask
    bHW_EntireObject = _connect.IConnectDebug_bHW_EntireObject
    bHW_SizeDefault = _connect.IConnectDebug_bHW_SizeDefault
    bHW_Size1 = _connect.IConnectDebug_bHW_Size1
    bHW_Size2 = _connect.IConnectDebug_bHW_Size2
    bHW_Size4 = _connect.IConnectDebug_bHW_Size4
    bHW_Size8 = _connect.IConnectDebug_bHW_Size8
    bHW_SizeMask = _connect.IConnectDebug_bHW_SizeMask
    bHW_DataMask = _connect.IConnectDebug_bHW_DataMask
    bHW_DataLSB0 = _connect.IConnectDebug_bHW_DataLSB0
    bHW_DataLSB1 = _connect.IConnectDebug_bHW_DataLSB1
    bHW_DataLSB2 = _connect.IConnectDebug_bHW_DataLSB2
    bHW_DataLSB3 = _connect.IConnectDebug_bHW_DataLSB3
    bHW_DataLSB4 = _connect.IConnectDebug_bHW_DataLSB4
    bHW_DataLSB5 = _connect.IConnectDebug_bHW_DataLSB5
    bHW_DataLSB6 = _connect.IConnectDebug_bHW_DataLSB6
    bHW_DataLSB7 = _connect.IConnectDebug_bHW_DataLSB7

    def SetBreakpoint(self, dwBreakpointFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'uint32_t', pszAddress: 'LPCSTR', dwLine: 'DWORD') -> "unsigned long":
        return _connect.IConnectDebug_SetBreakpoint(self, dwBreakpointFlags, byMemArea, aAddress, pszAddress, dwLine)
    rNothing = _connect.IConnectDebug_rNothing
    rReset = _connect.IConnectDebug_rReset
    rResetAndRun = _connect.IConnectDebug_rResetAndRun
    rDownload = _connect.IConnectDebug_rDownload
    rStop = _connect.IConnectDebug_rStop
    rRun = _connect.IConnectDebug_rRun
    rStep = _connect.IConnectDebug_rStep
    rStepOver = _connect.IConnectDebug_rStepOver
    rStepInst = _connect.IConnectDebug_rStepInst
    rStepOverInst = _connect.IConnectDebug_rStepOverInst
    rStepHigh = _connect.IConnectDebug_rStepHigh
    rStepOverHigh = _connect.IConnectDebug_rStepOverHigh
    rRunUntil = _connect.IConnectDebug_rRunUntil
    rRunUntilReturn = _connect.IConnectDebug_rRunUntilReturn
    rGoto = _connect.IConnectDebug_rGoto
    rSnapshot = _connect.IConnectDebug_rSnapshot
    rVerify = _connect.IConnectDebug_rVerify
    rDownloadNoCode = _connect.IConnectDebug_rDownloadNoCode
    rAttach = _connect.IConnectDebug_rAttach
    rDetach = _connect.IConnectDebug_rDetach
    rSlowRunOff = _connect.IConnectDebug_rSlowRunOff
    rSlowRunOn = _connect.IConnectDebug_rSlowRunOn
    rRunMask = _connect.IConnectDebug_rRunMask
    rWaitForStop = _connect.IConnectDebug_rWaitForStop
    rWaitTimeout10s = _connect.IConnectDebug_rWaitTimeout10s
    rWaitTimeout1s = _connect.IConnectDebug_rWaitTimeout1s
    rWaitTimeout100s = _connect.IConnectDebug_rWaitTimeout100s
    rWaitTimeoutInf = _connect.IConnectDebug_rWaitTimeoutInf
    rWaitTimeoutMask = _connect.IConnectDebug_rWaitTimeoutMask
    rPollingOff = _connect.IConnectDebug_rPollingOff
    rPollingOn = _connect.IConnectDebug_rPollingOn
    rPollingMask = _connect.IConnectDebug_rPollingMask
    rTristateOff = _connect.IConnectDebug_rTristateOff
    rTristateOn = _connect.IConnectDebug_rTristateOn
    rTristateMask = _connect.IConnectDebug_rTristateMask
    rTargetHWConnectOff = _connect.IConnectDebug_rTargetHWConnectOff
    rTargetHWConnectOn = _connect.IConnectDebug_rTargetHWConnectOn
    rTargetHWConnectMask = _connect.IConnectDebug_rTargetHWConnectMask

    def RunControl(self, dwRunControlFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'uint32_t') -> "unsigned long":
        return _connect.IConnectDebug_RunControl(self, dwRunControlFlags, byMemArea, aAddress)
    __swig_destroy__ = _connect.delete_IConnectDebug
    __del__ = lambda self: None
IConnectDebug_swigregister = _connect.IConnectDebug_swigregister
IConnectDebug_swigregister(IConnectDebug)

class IConnectProfiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectProfiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectProfiler, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectProfiler_ndxGetInfo
    ndxStartConfig = _connect.IConnectProfiler_ndxStartConfig
    ndxAddArea = _connect.IConnectProfiler_ndxAddArea
    ndxActivate = _connect.IConnectProfiler_ndxActivate
    ndxGetStatus = _connect.IConnectProfiler_ndxGetStatus
    ndxGetStatistics = _connect.IConnectProfiler_ndxGetStatistics
    ndxGetHistory = _connect.IConnectProfiler_ndxGetHistory
    ndxNum = _connect.IConnectProfiler_ndxNum
    cfTimeStampCycles = _connect.IConnectProfiler_cfTimeStampCycles
    cfTimeStampTime = _connect.IConnectProfiler_cfTimeStampTime
    cfTimeStampM0 = _connect.IConnectProfiler_cfTimeStampM0
    cfTimeStampM1 = _connect.IConnectProfiler_cfTimeStampM1
    cfTimeStampM2 = _connect.IConnectProfiler_cfTimeStampM2
    cfTimeStampM3 = _connect.IConnectProfiler_cfTimeStampM3
    cfTimeStampM4 = _connect.IConnectProfiler_cfTimeStampM4
    cfTimeStampM5 = _connect.IConnectProfiler_cfTimeStampM5
    cfTimeStampM6 = _connect.IConnectProfiler_cfTimeStampM6
    cfTimeStampM7 = _connect.IConnectProfiler_cfTimeStampM7
    cfTimeStampM8 = _connect.IConnectProfiler_cfTimeStampM8
    cfTimeStampM9 = _connect.IConnectProfiler_cfTimeStampM9
    cfTimeStampMask = _connect.IConnectProfiler_cfTimeStampMask

    def StartConfig(self, dwStartConfigFlags: 'DWORD', pStartingPoint: 'SProfilerStartingPoint') -> "unsigned long":
        return _connect.IConnectProfiler_StartConfig(self, dwStartConfigFlags, pStartingPoint)
    afValueTypeMask = _connect.IConnectProfiler_afValueTypeMask
    afTypeFunction = _connect.IConnectProfiler_afTypeFunction
    afTypeRoutine = _connect.IConnectProfiler_afTypeRoutine
    afTypeVariable = _connect.IConnectProfiler_afTypeVariable
    afTypeRegion = _connect.IConnectProfiler_afTypeRegion
    afTypeSingleData = _connect.IConnectProfiler_afTypeSingleData
    afTypeSingleData1 = _connect.IConnectProfiler_afTypeSingleData1
    afAreaMask = _connect.IConnectProfiler_afAreaMask
    afFunctionIncludeLines = _connect.IConnectProfiler_afFunctionIncludeLines
    afDataTaskID = _connect.IConnectProfiler_afDataTaskID
    afDataSingleData = _connect.IConnectProfiler_afDataSingleData

    def AddArea(self, dwAreaFlags: 'DWORD', pszName: 'LPCSTR', byMemArea: 'BYTE'=0, aAddress: 'uint32_t'=0, aSize: 'uint32_t'=0, dwNumExits: 'DWORD'=0, paExits: 'uint32_t *'=None) -> "unsigned long":
        return _connect.IConnectProfiler_AddArea(self, dwAreaFlags, pszName, byMemArea, aAddress, aSize, dwNumExits, paExits)
    aStart = _connect.IConnectProfiler_aStart
    aStop = _connect.IConnectProfiler_aStop
    aStartStopMask = _connect.IConnectProfiler_aStartStopMask

    def Activate(self, dwActivateFlags: 'DWORD') -> "unsigned long":
        return _connect.IConnectProfiler_Activate(self, dwActivateFlags)
    gsfNumRecorded = _connect.IConnectProfiler_gsfNumRecorded
    gsfNumAnalyzed = _connect.IConnectProfiler_gsfNumAnalyzed
    gsfNumMask = _connect.IConnectProfiler_gsfNumMask
    rfByHandle = _connect.IConnectProfiler_rfByHandle
    rfAllAreas = _connect.IConnectProfiler_rfAllAreas
    rfFilterTask = _connect.IConnectProfiler_rfFilterTask
    rfFilterValue = _connect.IConnectProfiler_rfFilterValue
    rfType0 = _connect.IConnectProfiler_rfType0
    rfType_Mask = _connect.IConnectProfiler_rfType_Mask

    def GetHistory(self, dwResultFlags: 'DWORD', dwHandle: 'DWORD', dwTask: 'DWORD', dwValue: 'DWORD', dwHistoryBase: 'DWORD', pdwNumHistories: 'DWORD *', pHistories: 'SProfilerHistory') -> "unsigned long":
        return _connect.IConnectProfiler_GetHistory(self, dwResultFlags, dwHandle, dwTask, dwValue, dwHistoryBase, pdwNumHistories, pHistories)
    __swig_destroy__ = _connect.delete_IConnectProfiler
    __del__ = lambda self: None
IConnectProfiler_swigregister = _connect.IConnectProfiler_swigregister
IConnectProfiler_swigregister(IConnectProfiler)

class IConnectProfiler2(IConnectProfiler):
    __swig_setmethods__ = {}
    for _s in [IConnectProfiler]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectProfiler2, name, value)
    __swig_getmethods__ = {}
    for _s in [IConnectProfiler]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectProfiler2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetResultInfo = _connect.IConnectProfiler2_ndxGetResultInfo
    ndxGetResultArea = _connect.IConnectProfiler2_ndxGetResultArea
    ndxNum = _connect.IConnectProfiler2_ndxNum
    grafByHandle = _connect.IConnectProfiler2_grafByHandle
    grafByName = _connect.IConnectProfiler2_grafByName
    grafByAddress = _connect.IConnectProfiler2_grafByAddress
    grafByMask = _connect.IConnectProfiler2_grafByMask
    grafTypeExec = _connect.IConnectProfiler2_grafTypeExec
    grafTypeData = _connect.IConnectProfiler2_grafTypeData
    grafTypeMask = _connect.IConnectProfiler2_grafTypeMask
    __swig_destroy__ = _connect.delete_IConnectProfiler2
    __del__ = lambda self: None
IConnectProfiler2_swigregister = _connect.IConnectProfiler2_swigregister
IConnectProfiler2_swigregister(IConnectProfiler2)
IID_IConnectProfiler2 = cvar.IID_IConnectProfiler2

class IConnectProject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectProject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectProject, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectProject_ndxGetInfo
    ndxOperation = _connect.IConnectProject_ndxOperation
    ndxGetStatus = _connect.IConnectProject_ndxGetStatus
    ndxOption = _connect.IConnectProject_ndxOption
    ndxNum = _connect.IConnectProject_ndxNum
    ofCustom = _connect.IConnectProject_ofCustom
    ofCompile = _connect.IConnectProject_ofCompile
    ofLink = _connect.IConnectProject_ofLink
    ofMake = _connect.IConnectProject_ofMake
    ofBuild = _connect.IConnectProject_ofBuild
    ofDependencies = _connect.IConnectProject_ofDependencies
    ofIsUpToDate = _connect.IConnectProject_ofIsUpToDate
    ofSetTarget = _connect.IConnectProject_ofSetTarget
    ofExport = _connect.IConnectProject_ofExport
    ofImport = _connect.IConnectProject_ofImport
    ofStop = _connect.IConnectProject_ofStop
    ofOperationMask = _connect.IConnectProject_ofOperationMask
    ofSuppressPostLinkActions = _connect.IConnectProject_ofSuppressPostLinkActions

    def Operation(self, dwOperationFlags: 'DWORD', pszOperation: 'LPCSTR', pszParameters: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectProject_Operation(self, dwOperationFlags, pszOperation, pszParameters)
    ofaGet = _connect.IConnectProject_ofaGet
    ofaEnum = _connect.IConnectProject_ofaEnum
    ofaSet = _connect.IConnectProject_ofaSet
    ofaAdd = _connect.IConnectProject_ofaAdd
    ofaRmv = _connect.IConnectProject_ofaRmv
    ofaMov = _connect.IConnectProject_ofaMov
    ofaMask = _connect.IConnectProject_ofaMask
    ofaRelativePaths = _connect.IConnectProject_ofaRelativePaths
    ofaEnumIndexMask = _connect.IConnectProject_ofaEnumIndexMask

    def Option(self, dwOptionFlags: 'DWORD', pszScope: 'LPCSTR', pszOption: 'LPCSTR', pszValue: 'LPSTR', dwValueLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectProject_Option(self, dwOptionFlags, pszScope, pszOption, pszValue, dwValueLen)
    __swig_destroy__ = _connect.delete_IConnectProject
    __del__ = lambda self: None
IConnectProject_swigregister = _connect.IConnectProject_swigregister
IConnectProject_swigregister(IConnectProject)
IID_IConnectProject = cvar.IID_IConnectProject

class IConnectDebug2(IConnectDebug):
    __swig_setmethods__ = {}
    for _s in [IConnectDebug]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectDebug2, name, value)
    __swig_getmethods__ = {}
    for _s in [IConnectDebug]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectDebug2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo2 = _connect.IConnectDebug2_ndxGetInfo2
    ndxBatchAccess = _connect.IConnectDebug2_ndxBatchAccess
    ndxWriteRunWaitRead = _connect.IConnectDebug2_ndxWriteRunWaitRead
    ndxDownload = _connect.IConnectDebug2_ndxDownload
    ndxCore = _connect.IConnectDebug2_ndxCore
    ndxSetBreakpointCond = _connect.IConnectDebug2_ndxSetBreakpointCond
    ndxCodeCacheOp = _connect.IConnectDebug2_ndxCodeCacheOp
    ndxStackUsage = _connect.IConnectDebug2_ndxStackUsage
    ndxGetAddress64 = _connect.IConnectDebug2_ndxGetAddress64
    ndxGetSymbol64 = _connect.IConnectDebug2_ndxGetSymbol64
    ndxGetSourceAddress64 = _connect.IConnectDebug2_ndxGetSourceAddress64
    ndxGetAddressSource64 = _connect.IConnectDebug2_ndxGetAddressSource64
    ndxReadMemory64 = _connect.IConnectDebug2_ndxReadMemory64
    ndxWriteMemory64 = _connect.IConnectDebug2_ndxWriteMemory64
    ndxReadValue64 = _connect.IConnectDebug2_ndxReadValue64
    ndxWriteValue64 = _connect.IConnectDebug2_ndxWriteValue64
    ndxGetStatus64 = _connect.IConnectDebug2_ndxGetStatus64
    ndxRunControl64 = _connect.IConnectDebug2_ndxRunControl64
    ndxSetBreakpointCond64 = _connect.IConnectDebug2_ndxSetBreakpointCond64
    ndxNum = _connect.IConnectDebug2_ndxNum

    def BatchAccess(self, dwBatchAccessFlags: 'DWORD', pBatchAccessHeader: 'SBatchAccessHeader', pBatchAccessItems: 'SBatchAccessItem', pBatchAccessItemResults: 'SBatchAccessItemResult') -> "unsigned long":
        return _connect.IConnectDebug2_BatchAccess(self, dwBatchAccessFlags, pBatchAccessHeader, pBatchAccessItems, pBatchAccessItemResults)
    dIndexMask = _connect.IConnectDebug2_dIndexMask
    dActionMask = _connect.IConnectDebug2_dActionMask
    daDownload = _connect.IConnectDebug2_daDownload
    daDLFromList = _connect.IConnectDebug2_daDLFromList
    daAddToList = _connect.IConnectDebug2_daAddToList
    daGet = _connect.IConnectDebug2_daGet
    daRemove = _connect.IConnectDebug2_daRemove
    daRemoveAll = _connect.IConnectDebug2_daRemoveAll
    dListMask = _connect.IConnectDebug2_dListMask
    dListMain = _connect.IConnectDebug2_dListMain
    dListTarget = _connect.IConnectDebug2_dListTarget
    dForceConvert = _connect.IConnectDebug2_dForceConvert
    dRealTime = _connect.IConnectDebug2_dRealTime
    dAbsolutePath = _connect.IConnectDebug2_dAbsolutePath
    cLaunch = _connect.IConnectDebug2_cLaunch
    cPrimaryIs0 = _connect.IConnectDebug2_cPrimaryIs0

    def Core(self, dwCoreFlags: 'DWORD', byCore: 'BYTE', pszCoreID: 'LPSTR', dwCoreIDLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectDebug2_Core(self, dwCoreFlags, byCore, pszCoreID, dwCoreIDLen)

    def SetBreakpointCond(self, dwBreakpointFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'uint32_t', pszAddress: 'LPCSTR', dwLine: 'DWORD', dwCondCount: 'DWORD', pszCondExpression: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectDebug2_SetBreakpointCond(self, dwBreakpointFlags, byMemArea, aAddress, pszAddress, dwLine, dwCondCount, pszCondExpression)

    def GetAddress64(self, dwGetAddressFlags: 'DWORD', pszExpression: 'LPCSTR', pbyMemArea: 'BYTE *', paAddress: 'ADDRESS_64 *', paSizeMAUs: 'ADDRESS_64 *', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug2_GetAddress64(self, dwGetAddressFlags, pszExpression, pbyMemArea, paAddress, paSizeMAUs, pType)

    def GetSymbol64(self, dwSymbolFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'ADDRESS_64', pszName: 'LPSTR', dwNameLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectDebug2_GetSymbol64(self, dwSymbolFlags, byMemArea, aAddress, pszName, dwNameLen)

    def GetSourceAddress64(self, dwSourceFlags: 'DWORD', pszFileName: 'LPCSTR', dwLine: 'DWORD', paAddress: 'ADDRESS_64 *', pdwNumAddresses: 'DWORD *') -> "unsigned long":
        return _connect.IConnectDebug2_GetSourceAddress64(self, dwSourceFlags, pszFileName, dwLine, paAddress, pdwNumAddresses)

    def GetAddressSource64(self, dwSourceFlags: 'DWORD', aAddress: 'ADDRESS_64', pszFileName: 'LPSTR', dwFileNameLen: 'DWORD', pdwLine: 'DWORD *') -> "unsigned long":
        return _connect.IConnectDebug2_GetAddressSource64(self, dwSourceFlags, aAddress, pszFileName, dwFileNameLen, pdwLine)

    def ReadMemory64(self, dwAccessFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'ADDRESS_64', aNumMAUs: 'ADDRESS_64', pbyBuf: 'BYTE *', byBytesPerMAU: 'BYTE', pbyAccessInfo: 'BYTE *') -> "unsigned long":
        return _connect.IConnectDebug2_ReadMemory64(self, dwAccessFlags, byMemArea, aAddress, aNumMAUs, pbyBuf, byBytesPerMAU, pbyAccessInfo)

    def WriteMemory64(self, dwAccessFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'ADDRESS_64', aNumMAUs: 'ADDRESS_64', pbyBuf: 'BYTE const *', byBytesPerMAU: 'BYTE', pbyAccessInfo: 'BYTE *') -> "unsigned long":
        return _connect.IConnectDebug2_WriteMemory64(self, dwAccessFlags, byMemArea, aAddress, aNumMAUs, pbyBuf, byBytesPerMAU, pbyAccessInfo)

    def ReadValue64(self, dwAccessFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'ADDRESS_64', pValue: 'SValue', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug2_ReadValue64(self, dwAccessFlags, byMemArea, aAddress, pValue, pType)

    def WriteValue64(self, dwAccessFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'ADDRESS_64', pValue: 'SValue', pType: 'SType') -> "unsigned long":
        return _connect.IConnectDebug2_WriteValue64(self, dwAccessFlags, byMemArea, aAddress, pValue, pType)

    def RunControl64(self, dwRunControlFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'ADDRESS_64') -> "unsigned long":
        return _connect.IConnectDebug2_RunControl64(self, dwRunControlFlags, byMemArea, aAddress)

    def SetBreakpointCond64(self, dwBreakpointFlags: 'DWORD', byMemArea: 'BYTE', aAddress: 'ADDRESS_64', pszAddress: 'LPCSTR', dwLine: 'DWORD', dwCondCount: 'DWORD', pszCondExpression: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectDebug2_SetBreakpointCond64(self, dwBreakpointFlags, byMemArea, aAddress, pszAddress, dwLine, dwCondCount, pszCondExpression)
    __swig_destroy__ = _connect.delete_IConnectDebug2
    __del__ = lambda self: None
IConnectDebug2_swigregister = _connect.IConnectDebug2_swigregister
IConnectDebug2_swigregister(IConnectDebug2)

class IConnectIDE2(IConnectIDE):
    __swig_setmethods__ = {}
    for _s in [IConnectIDE]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectIDE2, name, value)
    __swig_getmethods__ = {}
    for _s in [IConnectIDE]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectIDE2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxService = _connect.IConnectIDE2_ndxService
    ndxNum = _connect.IConnectIDE2_ndxNum
    sfiSystem = _connect.IConnectIDE2_sfiSystem
    sfiDebug = _connect.IConnectIDE2_sfiDebug
    sfiPlugin = _connect.IConnectIDE2_sfiPlugin
    sfiIDE = _connect.IConnectIDE2_sfiIDE
    sfiDocument = _connect.IConnectIDE2_sfiDocument
    sfiHIL = _connect.IConnectIDE2_sfiHIL
    sfiMask = _connect.IConnectIDE2_sfiMask
    sfOut1_TypeFlat = _connect.IConnectIDE2_sfOut1_TypeFlat
    sfOut1_TypeIBuffer = _connect.IConnectIDE2_sfOut1_TypeIBuffer
    sfOut1_TypeMask = _connect.IConnectIDE2_sfOut1_TypeMask

    def Service(self, dwServiceFlags: 'DWORD', rguidService: 'GUID const &', dwSizeIn: 'DWORD', pDataIn: 'void const *', dwSizeOut: 'DWORD', pDataOut: 'void *', pdwSizeOutRet: 'DWORD *'=None) -> "unsigned long":
        return _connect.IConnectIDE2_Service(self, dwServiceFlags, rguidService, dwSizeIn, pDataIn, dwSizeOut, pDataOut, pdwSizeOutRet)
    __swig_destroy__ = _connect.delete_IConnectIDE2
    __del__ = lambda self: None
IConnectIDE2_swigregister = _connect.IConnectIDE2_swigregister
IConnectIDE2_swigregister(IConnectIDE2)

class IConnectIDE3(IConnectIDE2):
    __swig_setmethods__ = {}
    for _s in [IConnectIDE2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectIDE3, name, value)
    __swig_getmethods__ = {}
    for _s in [IConnectIDE2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectIDE3, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectIDE3_ndxGetInfo
    ndxGetConsole = _connect.IConnectIDE3_ndxGetConsole
    ndxConsoleOutput = _connect.IConnectIDE3_ndxConsoleOutput
    ndxConsoleInput = _connect.IConnectIDE3_ndxConsoleInput
    ndxOption = _connect.IConnectIDE3_ndxOption
    ndxService1 = _connect.IConnectIDE3_ndxService1
    ndxService2 = _connect.IConnectIDE3_ndxService2
    ndxNum = _connect.IConnectIDE3_ndxNum
    gcOutput = _connect.IConnectIDE3_gcOutput
    gcInput = _connect.IConnectIDE3_gcInput
    gcExisting = _connect.IConnectIDE3_gcExisting
    gcNew = _connect.IConnectIDE3_gcNew
    gcExistingOrNew = _connect.IConnectIDE3_gcExistingOrNew
    coSTDOUT = _connect.IConnectIDE3_coSTDOUT
    coSTDERR = _connect.IConnectIDE3_coSTDERR

    def ConsoleOutput(self, dwConsoleOutputFlags: 'DWORD', dwConsoleHandle: 'DWORD', pszOutput: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectIDE3_ConsoleOutput(self, dwConsoleOutputFlags, dwConsoleHandle, pszOutput)
    ciSTDIN = _connect.IConnectIDE3_ciSTDIN

    def ConsoleInput(self, dwConsoleInputFlags: 'DWORD', dwConsoleHandle: 'DWORD', pszInput: 'LPSTR', dwInputLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectIDE3_ConsoleInput(self, dwConsoleInputFlags, dwConsoleHandle, pszInput, dwInputLen)

    def Option(self, dwOptionFlags: 'DWORD', pszScope: 'LPCSTR', pszOption: 'LPCSTR', pValue: 'SOptionValue') -> "unsigned long":
        return _connect.IConnectIDE3_Option(self, dwOptionFlags, pszScope, pszOption, pValue)

    def Service1(self, dwServiceFlags: 'DWORD', rguidService: 'GUID const &', dwSizeIn: 'DWORD', pDataIn: 'void const *', dwSizeIn1: 'DWORD', pDataIn1: 'void const *', dwSizeOut: 'DWORD', pDataOut: 'void *', dwSizeOut1: 'DWORD', pDataOut1: 'void *', pdwSizeOut1Ret: 'DWORD *'=None) -> "unsigned long":
        return _connect.IConnectIDE3_Service1(self, dwServiceFlags, rguidService, dwSizeIn, pDataIn, dwSizeIn1, pDataIn1, dwSizeOut, pDataOut, dwSizeOut1, pDataOut1, pdwSizeOut1Ret)

    def Service2(self, dwServiceFlags: 'DWORD', pszScope: 'LPCSTR', rguidService: 'GUID const &', dwSizeIn: 'DWORD', pDataIn: 'void const *', dwSizeIn1: 'DWORD', pDataIn1: 'void const *', dwSizeOut: 'DWORD', pDataOut: 'void *', dwSizeOut1: 'DWORD', pDataOut1: 'void *', pdwSizeOut1Ret: 'DWORD *'=None) -> "unsigned long":
        return _connect.IConnectIDE3_Service2(self, dwServiceFlags, pszScope, rguidService, dwSizeIn, pDataIn, dwSizeIn1, pDataIn1, dwSizeOut, pDataOut, dwSizeOut1, pDataOut1, pdwSizeOut1Ret)
    __swig_destroy__ = _connect.delete_IConnectIDE3
    __del__ = lambda self: None
IConnectIDE3_swigregister = _connect.IConnectIDE3_swigregister
IConnectIDE3_swigregister(IConnectIDE3)

indxCoverage = _connect.indxCoverage
indxTest = _connect.indxTest
indxHIL = _connect.indxHIL
indxUMI = _connect.indxUMI
indxAnalyzer = _connect.indxAnalyzer
class SCoverageRange(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SCoverageRange, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SCoverageRange, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_aAddress"] = _connect.SCoverageRange_m_aAddress_set
    __swig_getmethods__["m_aAddress"] = _connect.SCoverageRange_m_aAddress_get
    if _newclass:
        m_aAddress = _swig_property(_connect.SCoverageRange_m_aAddress_get, _connect.SCoverageRange_m_aAddress_set)
    __swig_setmethods__["m_aEnd"] = _connect.SCoverageRange_m_aEnd_set
    __swig_getmethods__["m_aEnd"] = _connect.SCoverageRange_m_aEnd_get
    if _newclass:
        m_aEnd = _swig_property(_connect.SCoverageRange_m_aEnd_get, _connect.SCoverageRange_m_aEnd_set)

    def __init__(self):
        this = _connect.new_SCoverageRange()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SCoverageRange
    __del__ = lambda self: None
SCoverageRange_swigregister = _connect.SCoverageRange_swigregister
SCoverageRange_swigregister(SCoverageRange)
IID_IConnectCoverage = cvar.IID_IConnectCoverage
IID_IConnectTest = cvar.IID_IConnectTest
IID_IConnectHIL = cvar.IID_IConnectHIL
IID_IConnectAnalyzer = cvar.IID_IConnectAnalyzer

class IConnectCoverage(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectCoverage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectCoverage, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetLastError = _connect.IConnectCoverage_ndxGetLastError
    ndxGetInfo = _connect.IConnectCoverage_ndxGetInfo
    ndxSetConfig = _connect.IConnectCoverage_ndxSetConfig
    ndxActivate = _connect.IConnectCoverage_ndxActivate
    ndxGetStatus = _connect.IConnectCoverage_ndxGetStatus
    ndxGetCoverageRanges = _connect.IConnectCoverage_ndxGetCoverageRanges
    ndxGetCoverageBitmap = _connect.IConnectCoverage_ndxGetCoverageBitmap
    ndxGetCoverageStatistics = _connect.IConnectCoverage_ndxGetCoverageStatistics
    ndxNum = _connect.IConnectCoverage_ndxNum
    efError = _connect.IConnectCoverage_efError
    efWarning = _connect.IConnectCoverage_efWarning
    errorOK = _connect.IConnectCoverage_errorOK
    errorInternal = _connect.IConnectCoverage_errorInternal
    errorNotImplemented = _connect.IConnectCoverage_errorNotImplemented
    errorInvalidParameter = _connect.IConnectCoverage_errorInvalidParameter
    errorInvalidRangeset = _connect.IConnectCoverage_errorInvalidRangeset
    errorUnsuportedCoverageType = _connect.IConnectCoverage_errorUnsuportedCoverageType

    def GetLastError(self, pszFileName: 'LPCSTR', dwErrorFlags: 'DWORD', pdwErrorCode: 'DWORD *', pszError: 'LPSTR', dwErrorLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectCoverage_GetLastError(self, pszFileName, dwErrorFlags, pdwErrorCode, pszError, dwErrorLen)
    ifGetCapabilities = _connect.IConnectCoverage_ifGetCapabilities
    ifGetType = _connect.IConnectCoverage_ifGetType
    icAvailable = _connect.IConnectCoverage_icAvailable
    icBranches = _connect.IConnectCoverage_icBranches
    itHardware = _connect.IConnectCoverage_itHardware
    itOffline = _connect.IConnectCoverage_itOffline

    def GetInfo(self, pszFileName: 'LPCSTR', dwInfoFlags: 'DWORD', pdwInfo: 'DWORD *') -> "unsigned long":
        return _connect.IConnectCoverage_GetInfo(self, pszFileName, dwInfoFlags, pdwInfo)
    cfNOP = _connect.IConnectCoverage_cfNOP
    cfSetConfigScope = _connect.IConnectCoverage_cfSetConfigScope
    cfSetConfigLevel = _connect.IConnectCoverage_cfSetConfigLevel
    cfSetConfigOperation = _connect.IConnectCoverage_cfSetConfigOperation
    cfAddRangeset = _connect.IConnectCoverage_cfAddRangeset
    cfSetRangesetScope = _connect.IConnectCoverage_cfSetRangesetScope
    cfAddRangesetExcludeFolder = _connect.IConnectCoverage_cfAddRangesetExcludeFolder
    cfAddRangesetExcludeModule = _connect.IConnectCoverage_cfAddRangesetExcludeModule
    cfAddRangesetExcludeFunction = _connect.IConnectCoverage_cfAddRangesetExcludeFunction
    cfAddRangesetExcludeItem = _connect.IConnectCoverage_cfAddRangesetExcludeItem
    cfAddRangesetIncludeFolder = _connect.IConnectCoverage_cfAddRangesetIncludeFolder
    cfAddRangesetIncludeModule = _connect.IConnectCoverage_cfAddRangesetIncludeModule
    cfAddRangesetIncludeFunction = _connect.IConnectCoverage_cfAddRangesetIncludeFunction
    cfAddRangesetIncludeItem = _connect.IConnectCoverage_cfAddRangesetIncludeItem
    cfSetActiveRangeset = _connect.IConnectCoverage_cfSetActiveRangeset
    cfSetActiveRangesetByIndex = _connect.IConnectCoverage_cfSetActiveRangesetByIndex
    cfClearConfiguration = _connect.IConnectCoverage_cfClearConfiguration
    cfgsAllDownloaded = _connect.IConnectCoverage_cfgsAllDownloaded
    cfgsEntireMemory = _connect.IConnectCoverage_cfgsEntireMemory
    cfgsUseRangeset = _connect.IConnectCoverage_cfgsUseRangeset
    cfglStatementCoverage = _connect.IConnectCoverage_cfglStatementCoverage
    cfglDecisionCoverage = _connect.IConnectCoverage_cfglDecisionCoverage
    cfgoAutoStartWithCPU = _connect.IConnectCoverage_cfgoAutoStartWithCPU
    cfgoAutoUpdateOnStop = _connect.IConnectCoverage_cfgoAutoUpdateOnStop
    rssAllDownloadedCode = _connect.IConnectCoverage_rssAllDownloadedCode
    rssEntireMemory = _connect.IConnectCoverage_rssEntireMemory
    rssRegions = _connect.IConnectCoverage_rssRegions

    def SetConfig(self, pszFileName: 'LPCSTR', dwConfigFlags: 'DWORD', pszParameter: 'LPCSTR'=None, dwParameter: 'DWORD'=0) -> "unsigned long":
        return _connect.IConnectCoverage_SetConfig(self, pszFileName, dwConfigFlags, pszParameter, dwParameter)
    afStart = _connect.IConnectCoverage_afStart
    afStop = _connect.IConnectCoverage_afStop
    afResume = _connect.IConnectCoverage_afResume

    def Activate(self, pszFileName: 'LPCSTR', dwActivateFlags: 'DWORD') -> "unsigned long":
        return _connect.IConnectCoverage_Activate(self, pszFileName, dwActivateFlags)
    sfActivationStatus = _connect.IConnectCoverage_sfActivationStatus
    asInactive = _connect.IConnectCoverage_asInactive
    asActive = _connect.IConnectCoverage_asActive

    def GetStatus(self, pszFileName: 'LPCSTR', dwStatusFlags: 'DWORD', pdwStatus: 'DWORD *') -> "unsigned long":
        return _connect.IConnectCoverage_GetStatus(self, pszFileName, dwStatusFlags, pdwStatus)
    crfActiveRanges = _connect.IConnectCoverage_crfActiveRanges
    crfResolveRange = _connect.IConnectCoverage_crfResolveRange
    crtFolder = _connect.IConnectCoverage_crtFolder
    crtModule = _connect.IConnectCoverage_crtModule
    crtFunction = _connect.IConnectCoverage_crtFunction
    crtItem = _connect.IConnectCoverage_crtItem

    def GetCoverageRanges(self, pszFileName: 'LPCSTR', dwRangesFlags: 'DWORD', pdwRangeCount: 'DWORD *', pRanges: 'SCoverageRange', pszParameter: 'LPCSTR'=None, dwParameter: 'DWORD'=0) -> "unsigned long":
        return _connect.IConnectCoverage_GetCoverageRanges(self, pszFileName, dwRangesFlags, pdwRangeCount, pRanges, pszParameter, dwParameter)
    cbfBitmap0 = _connect.IConnectCoverage_cbfBitmap0
    cbfBitmap1 = _connect.IConnectCoverage_cbfBitmap1
    cbfBitmapMask = _connect.IConnectCoverage_cbfBitmapMask
    cbfDefault = _connect.IConnectCoverage_cbfDefault
    bm0_Executed = _connect.IConnectCoverage_bm0_Executed
    bm0_Condition = _connect.IConnectCoverage_bm0_Condition
    bm0_ConditionTrue = _connect.IConnectCoverage_bm0_ConditionTrue
    bm0_ConditionFalse = _connect.IConnectCoverage_bm0_ConditionFalse
    modeBranch = _connect.IConnectCoverage_modeBranch
    modeBranchTaken = _connect.IConnectCoverage_modeBranchTaken
    modeBranchNotTaken = _connect.IConnectCoverage_modeBranchNotTaken

    def GetCoverageBitmap(self, pszFileName: 'LPCSTR', dwCoverageBitmapFlags: 'DWORD', aAddress: 'uint32_t', aEnd: 'uint32_t', dwBitmapSize: 'DWORD', pbyBitmap: 'BYTE *') -> "unsigned long":
        return _connect.IConnectCoverage_GetCoverageBitmap(self, pszFileName, dwCoverageBitmapFlags, aAddress, aEnd, dwBitmapSize, pbyBitmap)
    csftBytes = _connect.IConnectCoverage_csftBytes
    csftBytesExec = _connect.IConnectCoverage_csftBytesExec
    csftConditions = _connect.IConnectCoverage_csftConditions
    csftConditionsExec = _connect.IConnectCoverage_csftConditionsExec
    csftConditionsTrue = _connect.IConnectCoverage_csftConditionsTrue
    csftConditionsFalse = _connect.IConnectCoverage_csftConditionsFalse
    csftConditionsBoth = _connect.IConnectCoverage_csftConditionsBoth
    csftBranches = _connect.IConnectCoverage_csftBranches
    csftBranchesExec = _connect.IConnectCoverage_csftBranchesExec
    csftBranchesTaken = _connect.IConnectCoverage_csftBranchesTaken
    csftBranchesNotTaken = _connect.IConnectCoverage_csftBranchesNotTaken
    csftBranchesBoth = _connect.IConnectCoverage_csftBranchesBoth
    csftCountMin = _connect.IConnectCoverage_csftCountMin
    csftCountMax = _connect.IConnectCoverage_csftCountMax
    csftLines = _connect.IConnectCoverage_csftLines
    csftLinesExec = _connect.IConnectCoverage_csftLinesExec

    def GetCoverageStatistics(self, pszFileName: 'LPCSTR', dwCoverageStatisticsFlags: 'DWORD', aAddress: 'uint32_t', aEnd: 'uint32_t', pdwData: 'DWORD *') -> "unsigned long":
        return _connect.IConnectCoverage_GetCoverageStatistics(self, pszFileName, dwCoverageStatisticsFlags, aAddress, aEnd, pdwData)
    __swig_destroy__ = _connect.delete_IConnectCoverage
    __del__ = lambda self: None
IConnectCoverage_swigregister = _connect.IConnectCoverage_swigregister
IConnectCoverage_swigregister(IConnectCoverage)

class IConnectTest(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectTest, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectTest, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetLastError = _connect.IConnectTest_ndxGetLastError
    ndxCreateTestCase = _connect.IConnectTest_ndxCreateTestCase
    ndxDestroyTestCase = _connect.IConnectTest_ndxDestroyTestCase
    ndxCreateParameter = _connect.IConnectTest_ndxCreateParameter
    ndxCreateReturnValue = _connect.IConnectTest_ndxCreateReturnValue
    ndxCreateVariable = _connect.IConnectTest_ndxCreateVariable
    ndxDestroyVariable = _connect.IConnectTest_ndxDestroyVariable
    ndxCreateStub = _connect.IConnectTest_ndxCreateStub
    ndxDestroyStub = _connect.IConnectTest_ndxDestroyStub
    ndxCreateStubParameter = _connect.IConnectTest_ndxCreateStubParameter
    ndxCreateStubReturnValue = _connect.IConnectTest_ndxCreateStubReturnValue
    ndxEvaluateExpression = _connect.IConnectTest_ndxEvaluateExpression
    ndxModifyExpression = _connect.IConnectTest_ndxModifyExpression
    ndxControl = _connect.IConnectTest_ndxControl
    ndxGetStatus = _connect.IConnectTest_ndxGetStatus
    ndxCreateRealtimeStub = _connect.IConnectTest_ndxCreateRealtimeStub
    ndxCreateUserStub = _connect.IConnectTest_ndxCreateUserStub
    ndxGetInfo = _connect.IConnectTest_ndxGetInfo
    ndxCreateVariableEx = _connect.IConnectTest_ndxCreateVariableEx
    ndxCreateTestCaseEx = _connect.IConnectTest_ndxCreateTestCaseEx
    ndxDeleteVariableEx = _connect.IConnectTest_ndxDeleteVariableEx
    ndxSetTestCaseTimeOut = _connect.IConnectTest_ndxSetTestCaseTimeOut
    ndxCreateStubEx = _connect.IConnectTest_ndxCreateStubEx
    ndxNum = _connect.IConnectTest_ndxNum
    efError = _connect.IConnectTest_efError
    efWarning = _connect.IConnectTest_efWarning
    errorOK = _connect.IConnectTest_errorOK
    errorInvalidTransition = _connect.IConnectTest_errorInvalidTransition
    errorInvalidTestCase = _connect.IConnectTest_errorInvalidTestCase
    errorInvalidTestVariable = _connect.IConnectTest_errorInvalidTestVariable
    errorInvalidTestStub = _connect.IConnectTest_errorInvalidTestStub
    errorInvalidTestCasePointer = _connect.IConnectTest_errorInvalidTestCasePointer
    errorInvalidTestVariablePointer = _connect.IConnectTest_errorInvalidTestVariablePointer
    errorInvalidTestStubPointer = _connect.IConnectTest_errorInvalidTestStubPointer
    errorCannotCreateTestCase = _connect.IConnectTest_errorCannotCreateTestCase
    errorCannotCreateTestVariable = _connect.IConnectTest_errorCannotCreateTestVariable
    errorCannotCreateTestStub = _connect.IConnectTest_errorCannotCreateTestStub
    errorTestCaseInitFailed = _connect.IConnectTest_errorTestCaseInitFailed
    errorInternal = _connect.IConnectTest_errorInternal
    errorExpressionEvaluationFailed = _connect.IConnectTest_errorExpressionEvaluationFailed
    errorExpressionModificationFailed = _connect.IConnectTest_errorExpressionModificationFailed
    errorSymbolsNotLoaded = _connect.IConnectTest_errorSymbolsNotLoaded
    errorFunctionNotFound = _connect.IConnectTest_errorFunctionNotFound
    errorTestCaseSymbolNotAFunction = _connect.IConnectTest_errorTestCaseSymbolNotAFunction
    errorCannotSetStubBreakpoint = _connect.IConnectTest_errorCannotSetStubBreakpoint
    errorInvalidControlFlags = _connect.IConnectTest_errorInvalidControlFlags
    errorCannotUpdateStatus = _connect.IConnectTest_errorCannotUpdateStatus
    errorResumeFailed = _connect.IConnectTest_errorResumeFailed
    errorVariableTypeNotRecognized = _connect.IConnectTest_errorVariableTypeNotRecognized
    errorInvalidParameterIndex = _connect.IConnectTest_errorInvalidParameterIndex
    errorCannotClearStubBreakpoint = _connect.IConnectTest_errorCannotClearStubBreakpoint
    errorNotImplemented = _connect.IConnectTest_errorNotImplemented
    errorInvalidStatusFlags = _connect.IConnectTest_errorInvalidStatusFlags
    errorCannotSaveRegisters = _connect.IConnectTest_errorCannotSaveRegisters
    errorUnsupportedArchitecture = _connect.IConnectTest_errorUnsupportedArchitecture
    errorTestCaseCleanFailed = _connect.IConnectTest_errorTestCaseCleanFailed
    errorAdjustBeforeStartFailed = _connect.IConnectTest_errorAdjustBeforeStartFailed
    errorInvalidTestVariableName = _connect.IConnectTest_errorInvalidTestVariableName
    errorInvalidFlagValue = _connect.IConnectTest_errorInvalidFlagValue
    errorCannotSetExitBreakpoint = _connect.IConnectTest_errorCannotSetExitBreakpoint
    errorCannotAccessMemory = _connect.IConnectTest_errorCannotAccessMemory
    errorLicense = _connect.IConnectTest_errorLicense
    errorCallFrameAlocation = _connect.IConnectTest_errorCallFrameAlocation
    errorCannotSetExceptionBreakPoint = _connect.IConnectTest_errorCannotSetExceptionBreakPoint

    def GetLastError(self, dwErrorFlags: 'DWORD', pdwErrorCode: 'DWORD *', pszError: 'LPSTR', dwErrorLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectTest_GetLastError(self, dwErrorFlags, pdwErrorCode, pszError, dwErrorLen)

    def CreateTestCase(self, pdwTestCase: 'DWORD *', pszFunctionName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateTestCase(self, pdwTestCase, pszFunctionName)

    def DestroyTestCase(self, dwTestCase: 'DWORD') -> "unsigned long":
        return _connect.IConnectTest_DestroyTestCase(self, dwTestCase)

    def CreateParameter(self, *args) -> "unsigned long":
        return _connect.IConnectTest_CreateParameter(self, *args)

    def CreateReturnValue(self, dwTestCase: 'DWORD', pszName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateReturnValue(self, dwTestCase, pszName)

    def CreateVariable(self, pdwVariable: 'DWORD *', pszName: 'LPCSTR', pszType: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateVariable(self, pdwVariable, pszName, pszType)

    def DestroyVariable(self, dwVariable: 'DWORD') -> "unsigned long":
        return _connect.IConnectTest_DestroyVariable(self, dwVariable)

    def CreateStub(self, pdwStub: 'DWORD *', pszFunctionName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateStub(self, pdwStub, pszFunctionName)

    def DestroyStub(self, dwStub: 'DWORD') -> "unsigned long":
        return _connect.IConnectTest_DestroyStub(self, dwStub)

    def CreateStubParameter(self, dwStub: 'DWORD', dwIndex: 'DWORD', pszName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateStubParameter(self, dwStub, dwIndex, pszName)

    def CreateStubReturnValue(self, dwStub: 'DWORD', pszName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateStubReturnValue(self, dwStub, pszName)
    efVagueFloatEqual = _connect.IConnectTest_efVagueFloatEqual
    efIgnoreLocalScope = _connect.IConnectTest_efIgnoreLocalScope
    efUseRealTimeAccess = _connect.IConnectTest_efUseRealTimeAccess
    efModifyParameter = _connect.IConnectTest_efModifyParameter

    def EvaluateExpression(self, dwEvaluateFlags: 'DWORD', pszExpression: 'LPCSTR', pszResult: 'LPSTR', dwResultLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectTest_EvaluateExpression(self, dwEvaluateFlags, pszExpression, pszResult, dwResultLen)

    def ModifyExpression(self, dwModifyFlags: 'DWORD', pszExpression: 'LPCSTR', pszResult: 'LPSTR', dwResultLen: 'DWORD', pszValue: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_ModifyExpression(self, dwModifyFlags, pszExpression, pszResult, dwResultLen, pszValue)
    controlReset = _connect.IConnectTest_controlReset
    controlTestCaseInit = _connect.IConnectTest_controlTestCaseInit
    controlTestCaseClean = _connect.IConnectTest_controlTestCaseClean
    controlTestCaseRun = _connect.IConnectTest_controlTestCaseRun
    controlTestCaseAbort = _connect.IConnectTest_controlTestCaseAbort
    controlTestCasePause = _connect.IConnectTest_controlTestCasePause
    controlTestCaseSetDebugMode = _connect.IConnectTest_controlTestCaseSetDebugMode
    controlTestBatchBegin = _connect.IConnectTest_controlTestBatchBegin
    controlTestBatchEnd = _connect.IConnectTest_controlTestBatchEnd
    controlPersistentVariablesInit = _connect.IConnectTest_controlPersistentVariablesInit
    controlPersistentVariablesClean = _connect.IConnectTest_controlPersistentVariablesClean
    controlPersistentVariablesApply = _connect.IConnectTest_controlPersistentVariablesApply
    controlSystemTest = _connect.IConnectTest_controlSystemTest
    controlSystemTestInit = _connect.IConnectTest_controlSystemTestInit
    controlSystemTestClean = _connect.IConnectTest_controlSystemTestClean
    controlSystemTestRun = _connect.IConnectTest_controlSystemTestRun
    controlSystemTestStop = _connect.IConnectTest_controlSystemTestStop

    def Control(self, dwControlFlags: 'DWORD', dwHandle: 'DWORD') -> "unsigned long":
        return _connect.IConnectTest_Control(self, dwControlFlags, dwHandle)
    sfQueryTestCase = _connect.IConnectTest_sfQueryTestCase
    sfQueryStub = _connect.IConnectTest_sfQueryStub
    sfTestCase = _connect.IConnectTest_sfTestCase
    sfStub = _connect.IConnectTest_sfStub
    sfException = _connect.IConnectTest_sfException
    stateOffline = _connect.IConnectTest_stateOffline
    stateInitialized = _connect.IConnectTest_stateInitialized
    stateRunning = _connect.IConnectTest_stateRunning
    stateEnded = _connect.IConnectTest_stateEnded
    stateStub = _connect.IConnectTest_stateStub
    stateUnexpectedStop = _connect.IConnectTest_stateUnexpectedStop
    stateAborted = _connect.IConnectTest_stateAborted
    statePaused = _connect.IConnectTest_statePaused
    statePersistentReady = _connect.IConnectTest_statePersistentReady
    stateSystemTest = _connect.IConnectTest_stateSystemTest
    stateStop = _connect.IConnectTest_stateStop
    stateException = _connect.IConnectTest_stateException
    stateTimeOut = _connect.IConnectTest_stateTimeOut
    stateStubNotActive = _connect.IConnectTest_stateStubNotActive
    stateStubActive = _connect.IConnectTest_stateStubActive

    def GetStatus(self, dwStatusFlags: 'DWORD', dwHandle: 'DWORD', pdwStatus: 'DWORD *') -> "unsigned long":
        return _connect.IConnectTest_GetStatus(self, dwStatusFlags, dwHandle, pdwStatus)

    def CreateRealtimeStub(self, pdwStub: 'DWORD *', pszFunctionName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateRealtimeStub(self, pdwStub, pszFunctionName)

    def CreateUserStub(self, pdwStub: 'DWORD *', pszFunctionName: 'LPCSTR', pszUserFunctionName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateUserStub(self, pdwStub, pszFunctionName, pszUserFunctionName)
    infoSupported = _connect.IConnectTest_infoSupported

    def GetInfo(self, dwInfoFlags: 'DWORD', pdwInfo: 'DWORD *', pszInfo: 'LPSTR', dwInfoLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectTest_GetInfo(self, dwInfoFlags, pdwInfo, pszInfo, dwInfoLen)
    cveRegularVariable = _connect.IConnectTest_cveRegularVariable
    cvePersistentVariable = _connect.IConnectTest_cvePersistentVariable
    dveRegularVariable = _connect.IConnectTest_dveRegularVariable
    dvePersistentVariable = _connect.IConnectTest_dvePersistentVariable

    def CreateVariableEx(self, dwCreateVariableExFlags: 'DWORD', pdwVariable: 'DWORD *', pszName: 'LPCSTR', pszType: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_CreateVariableEx(self, dwCreateVariableExFlags, pdwVariable, pszName, pszType)

    def DeleteVariableEx(self, dwDeleteVariableExFlags: 'DWORD', pszName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectTest_DeleteVariableEx(self, dwDeleteVariableExFlags, pszName)

    def SetTestCaseTimeOut(self, dwTimeOut: 'DWORD'=0) -> "unsigned long":
        return _connect.IConnectTest_SetTestCaseTimeOut(self, dwTimeOut)
    sfeAutoBreakpoints = _connect.IConnectTest_sfeAutoBreakpoints
    sfeCustomBreakpoints = _connect.IConnectTest_sfeCustomBreakpoints

    def CreateStubEx(self, dwStubFlags: 'DWORD', pszFunctionName: 'LPCSTR', pdwStub: 'DWORD *') -> "unsigned long":
        return _connect.IConnectTest_CreateStubEx(self, dwStubFlags, pszFunctionName, pdwStub)
    __swig_destroy__ = _connect.delete_IConnectTest
    __del__ = lambda self: None
IConnectTest_swigregister = _connect.IConnectTest_swigregister
IConnectTest_swigregister(IConnectTest)

class IHILChannel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IHILChannel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IHILChannel, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        return _connect.IHILChannel_Name(self)
    mc_fl_Available = _connect.IHILChannel_mc_fl_Available

    def Flags(self) -> "DWORD":
        return _connect.IHILChannel_Flags(self)
    mc_cit_DIN = _connect.IHILChannel_mc_cit_DIN
    mc_cit_DOUT = _connect.IHILChannel_mc_cit_DOUT
    mc_cit_AIN = _connect.IHILChannel_mc_cit_AIN
    mc_cit_AOUT = _connect.IHILChannel_mc_cit_AOUT

    def Type(self) -> "DWORD":
        return _connect.IHILChannel_Type(self)

    def Index(self) -> "DWORD":
        return _connect.IHILChannel_Index(self)
    psUnit = _connect.IHILChannel_psUnit
    psQualifiedName = _connect.IHILChannel_psQualifiedName

    def PropertyStr(self, eProperty: 'IHILChannel::EPropertyStr') -> "LPCSTR":
        return _connect.IHILChannel_PropertyStr(self, eProperty)
    piDefault = _connect.IHILChannel_piDefault

    def PropertyInt(self, eProperty: 'IHILChannel::EPropertyInt') -> "DWORD":
        return _connect.IHILChannel_PropertyInt(self, eProperty)
    pfAMin = _connect.IHILChannel_pfAMin
    pfAMax = _connect.IHILChannel_pfAMax

    def PropertyFlt(self, eProperty: 'IHILChannel::EPropertyFlt') -> "double":
        return _connect.IHILChannel_PropertyFlt(self, eProperty)
    __swig_destroy__ = _connect.delete_IHILChannel
    __del__ = lambda self: None
IHILChannel_swigregister = _connect.IHILChannel_swigregister
IHILChannel_swigregister(IHILChannel)

class IHILInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IHILInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IHILInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Channels(self) -> "IHILChannels *":
        return _connect.IHILInfo_Channels(self)
    __swig_destroy__ = _connect.delete_IHILInfo
    __del__ = lambda self: None
IHILInfo_swigregister = _connect.IHILInfo_swigregister
IHILInfo_swigregister(IHILInfo)

class IConnectHIL(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectHIL, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectHIL, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxRead = _connect.IConnectHIL_ndxRead
    ndxWrite = _connect.IConnectHIL_ndxWrite
    ndxGetInfo = _connect.IConnectHIL_ndxGetInfo
    ndxAction = _connect.IConnectHIL_ndxAction
    ndxNum = _connect.IConnectHIL_ndxNum
    cPathSeparator = _connect.IConnectHIL_cPathSeparator
    cValueSeparator = _connect.IConnectHIL_cValueSeparator
    cPathValuePairSeparator = _connect.IConnectHIL_cPathValuePairSeparator

    def Read(self, dwFlags: 'DWORD', dwGenParam: 'DWORD', pszPaths: 'LPCSTR', pszValues: 'LPSTR', dwValuesSize: 'DWORD') -> "unsigned long":
        return _connect.IConnectHIL_Read(self, dwFlags, dwGenParam, pszPaths, pszValues, dwValuesSize)

    def Write(self, dwFlags: 'DWORD', dwGenParam: 'DWORD', pszValues: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectHIL_Write(self, dwFlags, dwGenParam, pszValues)
    afNone = _connect.IConnectHIL_afNone
    afActionString = _connect.IConnectHIL_afActionString

    def Action(self, dwFlags: 'DWORD', dwGenParam: 'DWORD', dwAction: 'DWORD', pszPath: 'LPCSTR', pszCommand: 'LPCSTR', pszCommandParam: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectHIL_Action(self, dwFlags, dwGenParam, dwAction, pszPath, pszCommand, pszCommandParam)
    __swig_destroy__ = _connect.delete_IConnectHIL
    __del__ = lambda self: None
IConnectHIL_swigregister = _connect.IConnectHIL_swigregister
IConnectHIL_swigregister(IConnectHIL)

class IConnectUMI(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectUMI, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectUMI, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxOperation = _connect.IConnectUMI_ndxOperation
    ndxNum = _connect.IConnectUMI_ndxNum
    wOpWrite = _connect.IConnectUMI_wOpWrite
    wOpRead = _connect.IConnectUMI_wOpRead
    wOpFlush = _connect.IConnectUMI_wOpFlush
    wOpErase = _connect.IConnectUMI_wOpErase
    wOpVerify = _connect.IConnectUMI_wOpVerify
    wOpBlankCheck = _connect.IConnectUMI_wOpBlankCheck
    wOpSecure = _connect.IConnectUMI_wOpSecure
    wOpUnsecure = _connect.IConnectUMI_wOpUnsecure
    wOpSecureCheck = _connect.IConnectUMI_wOpSecureCheck
    wOpReadHASH = _connect.IConnectUMI_wOpReadHASH
    wOpReadPgmState = _connect.IConnectUMI_wOpReadPgmState
    wOpGetLastError = _connect.IConnectUMI_wOpGetLastError
    wOpMask = _connect.IConnectUMI_wOpMask
    wScopeDevice = _connect.IConnectUMI_wScopeDevice
    wProgDevice = _connect.IConnectUMI_wProgDevice
    wProgCache = _connect.IConnectUMI_wProgCache
    wProgMask = _connect.IConnectUMI_wProgMask
    wFileFormatAuto = _connect.IConnectUMI_wFileFormatAuto
    wFileFormatBin = _connect.IConnectUMI_wFileFormatBin
    wFileFormatS = _connect.IConnectUMI_wFileFormatS
    wFileFormatHex = _connect.IConnectUMI_wFileFormatHex
    wFileFormatMask = _connect.IConnectUMI_wFileFormatMask

    def Operation(self, dwFlags: 'DWORD', dwDevice: 'DWORD', aAddress: 'uint32_t', aSize: 'uint32_t', pbyData: 'BYTE *', pszFileName: 'LPCSTR') -> "unsigned long":
        return _connect.IConnectUMI_Operation(self, dwFlags, dwDevice, aAddress, aSize, pbyData, pszFileName)
    HASH_SIZE = _connect.IConnectUMI_HASH_SIZE
    __swig_destroy__ = _connect.delete_IConnectUMI
    __del__ = lambda self: None
IConnectUMI_swigregister = _connect.IConnectUMI_swigregister
IConnectUMI_swigregister(IConnectUMI)
IID_IConnectUMI = cvar.IID_IConnectUMI

indxEclipse = _connect.indxEclipse
class SInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_dwNumRegisters"] = _connect.SInfo_m_dwNumRegisters_set
    __swig_getmethods__["m_dwNumRegisters"] = _connect.SInfo_m_dwNumRegisters_get
    if _newclass:
        m_dwNumRegisters = _swig_property(_connect.SInfo_m_dwNumRegisters_get, _connect.SInfo_m_dwNumRegisters_set)

    def __init__(self):
        this = _connect.new_SInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SInfo
    __del__ = lambda self: None
SInfo_swigregister = _connect.SInfo_swigregister
SInfo_swigregister(SInfo)
IID_IConnectEclipse = cvar.IID_IConnectEclipse

class SRegisterInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SRegisterInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SRegisterInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_szRegName"] = _connect.SRegisterInfo_m_szRegName_set
    __swig_getmethods__["m_szRegName"] = _connect.SRegisterInfo_m_szRegName_get
    if _newclass:
        m_szRegName = _swig_property(_connect.SRegisterInfo_m_szRegName_get, _connect.SRegisterInfo_m_szRegName_set)
    __swig_setmethods__["m_Type"] = _connect.SRegisterInfo_m_Type_set
    __swig_getmethods__["m_Type"] = _connect.SRegisterInfo_m_Type_get
    if _newclass:
        m_Type = _swig_property(_connect.SRegisterInfo_m_Type_get, _connect.SRegisterInfo_m_Type_set)

    def __init__(self):
        this = _connect.new_SRegisterInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SRegisterInfo
    __del__ = lambda self: None
SRegisterInfo_swigregister = _connect.SRegisterInfo_swigregister
SRegisterInfo_swigregister(SRegisterInfo)

class IDisassemblyLine(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDisassemblyLine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDisassemblyLine, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Address(self) -> "ADDRESS_64":
        return _connect.IDisassemblyLine_Address(self)

    def OpCode(self) -> "LPCSTR":
        return _connect.IDisassemblyLine_OpCode(self)

    def OpCodeArgs(self) -> "LPCSTR":
        return _connect.IDisassemblyLine_OpCodeArgs(self)

    def FileName(self) -> "LPCSTR":
        return _connect.IDisassemblyLine_FileName(self)

    def LineNumber(self) -> "DWORD":
        return _connect.IDisassemblyLine_LineNumber(self)

    def FunctionName(self) -> "LPCSTR":
        return _connect.IDisassemblyLine_FunctionName(self)

    def FunctionOffset(self) -> "ADDRESS_64":
        return _connect.IDisassemblyLine_FunctionOffset(self)

    def IsBranch(self) -> "bool":
        return _connect.IDisassemblyLine_IsBranch(self)

    def IsCall(self) -> "bool":
        return _connect.IDisassemblyLine_IsCall(self)

    def IsIndirect(self) -> "bool":
        return _connect.IDisassemblyLine_IsIndirect(self)

    def IsConditional(self) -> "bool":
        return _connect.IDisassemblyLine_IsConditional(self)

    def Length(self) -> "BYTE":
        return _connect.IDisassemblyLine_Length(self)

    def BranchTarget(self) -> "ADDRESS_64":
        return _connect.IDisassemblyLine_BranchTarget(self)
    __swig_destroy__ = _connect.delete_IDisassemblyLine
    __del__ = lambda self: None
IDisassemblyLine_swigregister = _connect.IDisassemblyLine_swigregister
IDisassemblyLine_swigregister(IDisassemblyLine)

class IDisassemblyBlock(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDisassemblyBlock, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDisassemblyBlock, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Lines(self) -> "iEclipse::IDisassemblyLines *":
        return _connect.IDisassemblyBlock_Lines(self)
    __swig_destroy__ = _connect.delete_IDisassemblyBlock
    __del__ = lambda self: None
IDisassemblyBlock_swigregister = _connect.IDisassemblyBlock_swigregister
IDisassemblyBlock_swigregister(IDisassemblyBlock)

class IVariable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVariable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVariable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        return _connect.IVariable_Name(self)

    def QualifiedName(self) -> "LPCSTR":
        return _connect.IVariable_QualifiedName(self)

    def TypeName(self) -> "LPCSTR":
        return _connect.IVariable_TypeName(self)

    def NumBytes(self) -> "DWORD":
        return _connect.IVariable_NumBytes(self)
    tSimple = _connect.IVariable_tSimple
    tPointer = _connect.IVariable_tPointer
    tReference = _connect.IVariable_tReference
    tArray = _connect.IVariable_tArray
    tStruct = _connect.IVariable_tStruct
    tUnion = _connect.IVariable_tUnion
    tClass = _connect.IVariable_tClass
    tFunction = _connect.IVariable_tFunction

    def Type(self) -> "BYTE":
        return _connect.IVariable_Type(self)

    def ArrayDimension(self) -> "DWORD":
        return _connect.IVariable_ArrayDimension(self)

    def Module(self) -> "WORD":
        return _connect.IVariable_Module(self)

    def Scope(self) -> "LPCSTR":
        return _connect.IVariable_Scope(self)

    def ArrayFirstElement(self) -> "LONG":
        return _connect.IVariable_ArrayFirstElement(self)

    def MemArea(self) -> "BYTE":
        return _connect.IVariable_MemArea(self)

    def Address(self) -> "ADDRESS_64":
        return _connect.IVariable_Address(self)

    def Size(self) -> "ADDRESS_64":
        return _connect.IVariable_Size(self)

    def GetIType(self) -> "iEclipse::IType *":
        return _connect.IVariable_GetIType(self)
    __swig_destroy__ = _connect.delete_IVariable
    __del__ = lambda self: None
IVariable_swigregister = _connect.IVariable_swigregister
IVariable_swigregister(IVariable)

class ICallee(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICallee, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICallee, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CallSite(self) -> "ADDRESS_64":
        return _connect.ICallee_CallSite(self)

    def DirectCall(self) -> "bool":
        return _connect.ICallee_DirectCall(self)

    def Callee(self) -> "ADDRESS_64":
        return _connect.ICallee_Callee(self)
    __swig_destroy__ = _connect.delete_ICallee
    __del__ = lambda self: None
ICallee_swigregister = _connect.ICallee_swigregister
ICallee_swigregister(ICallee)

class ICaller(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICaller, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICaller, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CallSite(self) -> "ADDRESS_64":
        return _connect.ICaller_CallSite(self)
    __swig_destroy__ = _connect.delete_ICaller
    __del__ = lambda self: None
ICaller_swigregister = _connect.ICaller_swigregister
ICaller_swigregister(ICaller)

class IFunction(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFunction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFunction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        return _connect.IFunction_Name(self)

    def Scope(self) -> "LPCSTR":
        return _connect.IFunction_Scope(self)

    def ReturnTypeName(self) -> "LPCSTR":
        return _connect.IFunction_ReturnTypeName(self)

    def Module(self) -> "WORD":
        return _connect.IFunction_Module(self)

    def Parameters(self) -> "iEclipse::IVariables *":
        return _connect.IFunction_Parameters(self)

    def Variables(self) -> "iEclipse::IVariables *":
        return _connect.IFunction_Variables(self)

    def QualifiedName(self) -> "LPCSTR":
        return _connect.IFunction_QualifiedName(self)

    def MemArea(self) -> "BYTE":
        return _connect.IFunction_MemArea(self)

    def Address(self) -> "ADDRESS_64":
        return _connect.IFunction_Address(self)

    def Size(self) -> "ADDRESS_64":
        return _connect.IFunction_Size(self)

    def SignatureName(self) -> "LPCSTR":
        return _connect.IFunction_SignatureName(self)

    def HasVarParams(self) -> "bool":
        return _connect.IFunction_HasVarParams(self)

    def Callees(self) -> "iEclipse::ICallees *":
        return _connect.IFunction_Callees(self)

    def Callers(self) -> "iEclipse::ICallers *":
        return _connect.IFunction_Callers(self)
    __swig_destroy__ = _connect.delete_IFunction
    __del__ = lambda self: None
IFunction_swigregister = _connect.IFunction_swigregister
IFunction_swigregister(IFunction)

class IType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IType, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeName(self) -> "LPCSTR":
        return _connect.IType_TypeName(self)

    def Type(self) -> "SType2 const *":
        return _connect.IType_Type(self)
    __swig_destroy__ = _connect.delete_IType
    __del__ = lambda self: None
IType_swigregister = _connect.IType_swigregister
IType_swigregister(IType)

class ITypedef(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ITypedef, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ITypedef, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        return _connect.ITypedef_Name(self)

    def TypeName(self) -> "LPCSTR":
        return _connect.ITypedef_TypeName(self)
    __swig_destroy__ = _connect.delete_ITypedef
    __del__ = lambda self: None
ITypedef_swigregister = _connect.ITypedef_swigregister
ITypedef_swigregister(ITypedef)

class IMacro(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMacro, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMacro, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        return _connect.IMacro_Name(self)

    def Value(self) -> "LPCSTR":
        return _connect.IMacro_Value(self)
    __swig_destroy__ = _connect.delete_IMacro
    __del__ = lambda self: None
IMacro_swigregister = _connect.IMacro_swigregister
IMacro_swigregister(IMacro)

class IInstruction(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IInstruction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IInstruction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    flFlowSequential = _connect.IInstruction_flFlowSequential
    flFlowDirectJump = _connect.IInstruction_flFlowDirectJump
    flFlowIndirectJump = _connect.IInstruction_flFlowIndirectJump
    flFlowMask = _connect.IInstruction_flFlowMask
    flConditional = _connect.IInstruction_flConditional
    flCall = _connect.IInstruction_flCall
    flRelative = _connect.IInstruction_flRelative
    flWrite = _connect.IInstruction_flWrite
    flRead = _connect.IInstruction_flRead

    def OpCode(self) -> "LPCSTR":
        return _connect.IInstruction_OpCode(self)

    def Address(self) -> "ADDRESS_64":
        return _connect.IInstruction_Address(self)

    def JumpTarget(self) -> "ADDRESS_64":
        return _connect.IInstruction_JumpTarget(self)

    def Size(self) -> "DWORD":
        return _connect.IInstruction_Size(self)

    def Flags(self) -> "DWORD":
        return _connect.IInstruction_Flags(self)

    def MemAccessSize(self) -> "DWORD":
        return _connect.IInstruction_MemAccessSize(self)
    __swig_destroy__ = _connect.delete_IInstruction
    __del__ = lambda self: None
IInstruction_swigregister = _connect.IInstruction_swigregister
IInstruction_swigregister(IInstruction)

class IStackFrame(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IStackFrame, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IStackFrame, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Address(self) -> "ADDRESS_64":
        return _connect.IStackFrame_Address(self)

    def MemoryArea(self) -> "BYTE":
        return _connect.IStackFrame_MemoryArea(self)

    def FileName(self) -> "LPCSTR":
        return _connect.IStackFrame_FileName(self)

    def LineNumber(self) -> "DWORD":
        return _connect.IStackFrame_LineNumber(self)

    def FunctionName(self) -> "LPCSTR":
        return _connect.IStackFrame_FunctionName(self)

    def Variables(self) -> "iEclipse::IVariables *":
        return _connect.IStackFrame_Variables(self)

    def Arguments(self) -> "iEclipse::IVariables *":
        return _connect.IStackFrame_Arguments(self)

    def Function(self) -> "iEclipse::IFunction *":
        return _connect.IStackFrame_Function(self)

    def Partition(self) -> "DWORD":
        return _connect.IStackFrame_Partition(self)
    __swig_destroy__ = _connect.delete_IStackFrame
    __del__ = lambda self: None
IStackFrame_swigregister = _connect.IStackFrame_swigregister
IStackFrame_swigregister(IStackFrame)

class IStackFrameInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IStackFrameInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IStackFrameInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def StackFrames(self) -> "iEclipse::IStackFrames *":
        return _connect.IStackFrameInfo_StackFrames(self)
    __swig_destroy__ = _connect.delete_IStackFrameInfo
    __del__ = lambda self: None
IStackFrameInfo_swigregister = _connect.IStackFrameInfo_swigregister
IStackFrameInfo_swigregister(IStackFrameInfo)

class IExpressionType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IExpressionType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IExpressionType, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Expression(self) -> "iEclipse::IVariable *":
        return _connect.IExpressionType_Expression(self)

    def Children(self) -> "iEclipse::IVariables *":
        return _connect.IExpressionType_Children(self)
    __swig_destroy__ = _connect.delete_IExpressionType
    __del__ = lambda self: None
IExpressionType_swigregister = _connect.IExpressionType_swigregister
IExpressionType_swigregister(IExpressionType)

class IModule(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IModule, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IModule, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        return _connect.IModule_Name(self)

    def Path(self) -> "LPCSTR":
        return _connect.IModule_Path(self)
    __swig_destroy__ = _connect.delete_IModule
    __del__ = lambda self: None
IModule_swigregister = _connect.IModule_swigregister
IModule_swigregister(IModule)

class IGlobals(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGlobals, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IGlobals, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Variables(self) -> "iEclipse::IVariables *":
        return _connect.IGlobals_Variables(self)

    def Labels(self) -> "iEclipse::IVariables *":
        return _connect.IGlobals_Labels(self)

    def Modules(self) -> "iEclipse::IModules *":
        return _connect.IGlobals_Modules(self)

    def Functions(self) -> "iEclipse::IFunctions *":
        return _connect.IGlobals_Functions(self)

    def Types(self) -> "iEclipse::ITypes *":
        return _connect.IGlobals_Types(self)

    def Typedefs(self) -> "iEclipse::ITypedefs *":
        return _connect.IGlobals_Typedefs(self)

    def Macros(self) -> "iEclipse::IMacros *":
        return _connect.IGlobals_Macros(self)

    def Instructions(self) -> "iEclipse::IInstructions *":
        return _connect.IGlobals_Instructions(self)
    __swig_destroy__ = _connect.delete_IGlobals
    __del__ = lambda self: None
IGlobals_swigregister = _connect.IGlobals_swigregister
IGlobals_swigregister(IGlobals)

class IPartition(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPartition, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPartition, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        return _connect.IPartition_Name(self)

    def Path(self) -> "LPCSTR":
        return _connect.IPartition_Path(self)
    __swig_destroy__ = _connect.delete_IPartition
    __del__ = lambda self: None
IPartition_swigregister = _connect.IPartition_swigregister
IPartition_swigregister(IPartition)

class IConfiguration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConfiguration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConfiguration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Partitions(self) -> "iEclipse::IPartitions *":
        return _connect.IConfiguration_Partitions(self)
    __swig_destroy__ = _connect.delete_IConfiguration
    __del__ = lambda self: None
IConfiguration_swigregister = _connect.IConfiguration_swigregister
IConfiguration_swigregister(IConfiguration)

class ISFRValueMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISFRValueMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ISFRValueMap, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def String(self) -> "LPCSTR":
        return _connect.ISFRValueMap_String(self)

    def Value(self) -> "DWORD":
        return _connect.ISFRValueMap_Value(self)

    def Description(self) -> "LPCSTR":
        return _connect.ISFRValueMap_Description(self)
    __swig_destroy__ = _connect.delete_ISFRValueMap
    __del__ = lambda self: None
ISFRValueMap_swigregister = _connect.ISFRValueMap_swigregister
ISFRValueMap_swigregister(ISFRValueMap)

class ISFR(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ISFR, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ISFR, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Handle(self) -> "DWORD":
        return _connect.ISFR_Handle(self)

    def HasValue(self) -> "BOOL":
        return _connect.ISFR_HasValue(self)

    def Name(self) -> "LPCSTR":
        return _connect.ISFR_Name(self)

    def BitSize(self) -> "DWORD":
        return _connect.ISFR_BitSize(self)
    pRead = _connect.ISFR_pRead
    pWrite = _connect.ISFR_pWrite
    pSubReg = _connect.ISFR_pSubReg
    pFloat = _connect.ISFR_pFloat

    def Properties(self) -> "DWORD":
        return _connect.ISFR_Properties(self)

    def ValueMaps(self) -> "iEclipse::ISFRValueMaps *":
        return _connect.ISFR_ValueMaps(self)

    def SFRs(self) -> "iEclipse::ISFRs *":
        return _connect.ISFR_SFRs(self)

    def Description(self) -> "LPCSTR":
        return _connect.ISFR_Description(self)

    def Address(self) -> "ADDRESS_64":
        return _connect.ISFR_Address(self)

    def BitOffset(self) -> "DWORD":
        return _connect.ISFR_BitOffset(self)
    __swig_destroy__ = _connect.delete_ISFR
    __del__ = lambda self: None
ISFR_swigregister = _connect.ISFR_swigregister
ISFR_swigregister(ISFR)

class ICPUSFR(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICPUSFR, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICPUSFR, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CPUName(self) -> "LPCSTR":
        return _connect.ICPUSFR_CPUName(self)

    def SFRs(self) -> "iEclipse::ISFRs *":
        return _connect.ICPUSFR_SFRs(self)

    def Property(self) -> "isys::IProperty *":
        return _connect.ICPUSFR_Property(self)
    __swig_destroy__ = _connect.delete_ICPUSFR
    __del__ = lambda self: None
ICPUSFR_swigregister = _connect.ICPUSFR_swigregister
ICPUSFR_swigregister(ICPUSFR)
sName = cvar.sName
iBitsPerMAU = cvar.iBitsPerMAU
iStart = cvar.iStart
iEnd = cvar.iEnd

class IConnectEclipse(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IConnectEclipse, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IConnectEclipse, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectEclipse_ndxGetInfo
    ndxGetRegisterInfo = _connect.IConnectEclipse_ndxGetRegisterInfo
    ndxGetDisassemblySrc = _connect.IConnectEclipse_ndxGetDisassemblySrc
    ndxGetDisassemblyAdr = _connect.IConnectEclipse_ndxGetDisassemblyAdr
    ndxGetStackFrameInfo = _connect.IConnectEclipse_ndxGetStackFrameInfo
    ndxSetStackFrameContext = _connect.IConnectEclipse_ndxSetStackFrameContext
    ndxGetExpressionType = _connect.IConnectEclipse_ndxGetExpressionType
    ndxGetGlobals = _connect.IConnectEclipse_ndxGetGlobals
    ndxGetConfiguration = _connect.IConnectEclipse_ndxGetConfiguration
    ndxGetCPUSFR = _connect.IConnectEclipse_ndxGetCPUSFR
    ndxSFRValue = _connect.IConnectEclipse_ndxSFRValue
    ndxRemoteFileOperation = _connect.IConnectEclipse_ndxRemoteFileOperation
    ndxNum = _connect.IConnectEclipse_ndxNum

    def GetInfo(self, dwFlags: 'DWORD', pInfo: 'SInfo') -> "unsigned long":
        return _connect.IConnectEclipse_GetInfo(self, dwFlags, pInfo)

    def GetRegisterInfo(self, dwFlags: 'DWORD', dwRegister: 'DWORD', pInfo: 'SRegisterInfo') -> "unsigned long":
        return _connect.IConnectEclipse_GetRegisterInfo(self, dwFlags, dwRegister, pInfo)
    dfSymNone = _connect.IConnectEclipse_dfSymNone
    dfSymSymbols = _connect.IConnectEclipse_dfSymSymbols
    dfSymSymbolsAndValues = _connect.IConnectEclipse_dfSymSymbolsAndValues
    dfSymMask = _connect.IConnectEclipse_dfSymMask
    dfNextNone = _connect.IConnectEclipse_dfNextNone
    dfNextImm = _connect.IConnectEclipse_dfNextImm
    dfNextAll = _connect.IConnectEclipse_dfNextAll
    dfNextMask = _connect.IConnectEclipse_dfNextMask
    sfiActiveFrameOnly = _connect.IConnectEclipse_sfiActiveFrameOnly
    sfiAbsolutePath = _connect.IConnectEclipse_sfiAbsolutePath

    def SetStackFrameContext(self, dwFlags: 'DWORD', dwContext: 'DWORD') -> "unsigned long":
        return _connect.IConnectEclipse_SetStackFrameContext(self, dwFlags, dwContext)
    gvfVariables = _connect.IConnectEclipse_gvfVariables
    gvfLabels = _connect.IConnectEclipse_gvfLabels
    gvfModules = _connect.IConnectEclipse_gvfModules
    gvfFunctions = _connect.IConnectEclipse_gvfFunctions
    gvfTypes = _connect.IConnectEclipse_gvfTypes
    gvfTypedefs = _connect.IConnectEclipse_gvfTypedefs
    gvfMacros = _connect.IConnectEclipse_gvfMacros
    gvfInstructions = _connect.IConnectEclipse_gvfInstructions
    gvfMask = _connect.IConnectEclipse_gvfMask
    gvfSortAddress = _connect.IConnectEclipse_gvfSortAddress
    gvfSortName = _connect.IConnectEclipse_gvfSortName
    gvfSortMask = _connect.IConnectEclipse_gvfSortMask
    gvfPartitionSpecify = _connect.IConnectEclipse_gvfPartitionSpecify
    gvfPartitionDefault = _connect.IConnectEclipse_gvfPartitionDefault
    gvfPartitionCurrent = _connect.IConnectEclipse_gvfPartitionCurrent
    gvfPartitionMask = _connect.IConnectEclipse_gvfPartitionMask
    gcsSFRs = _connect.IConnectEclipse_gcsSFRs
    gcsGPRs = _connect.IConnectEclipse_gcsGPRs
    gcsAreas = _connect.IConnectEclipse_gcsAreas
    svRead = _connect.IConnectEclipse_svRead
    svWrite = _connect.IConnectEclipse_svWrite
    svWriteThenRead = _connect.IConnectEclipse_svWriteThenRead
    svNoRefresh = _connect.IConnectEclipse_svNoRefresh
    svErrorInfo = _connect.IConnectEclipse_svErrorInfo

    def SFRValue(self, dwFlags: 'DWORD', dwHandle: 'DWORD', rValue: 'SValue', pszError: 'LPSTR', dwErrorLen: 'DWORD') -> "unsigned long":
        return _connect.IConnectEclipse_SFRValue(self, dwFlags, dwHandle, rValue, pszError, dwErrorLen)
    rfoExists = _connect.IConnectEclipse_rfoExists
    rfoDelete = _connect.IConnectEclipse_rfoDelete
    rfoRead = _connect.IConnectEclipse_rfoRead
    rfoWrite = _connect.IConnectEclipse_rfoWrite
    rfoOpMask = _connect.IConnectEclipse_rfoOpMask

    def RemoteFileOperation(self, dwFlags: 'DWORD', pszFileName: 'char const *', rdwP1: 'DWORD &', rdwP2: 'DWORD &', pIBuffer: 'IBuffer *') -> "unsigned long":
        return _connect.IConnectEclipse_RemoteFileOperation(self, dwFlags, pszFileName, rdwP1, rdwP2, pIBuffer)
    __swig_destroy__ = _connect.delete_IConnectEclipse
    __del__ = lambda self: None
IConnectEclipse_swigregister = _connect.IConnectEclipse_swigregister
IConnectEclipse_swigregister(IConnectEclipse)

class CPropertyWrapper(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPropertyWrapper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CPropertyWrapper, name)
    __repr__ = _swig_repr

    def __init__(self, pIProperty: 'isys::IProperty *'):
        this = _connect.new_CPropertyWrapper(pIProperty)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsValid(self) -> "bool":
        return _connect.CPropertyWrapper_IsValid(self)

    def Find(self, pszKey: 'LPCSTR') -> "isys::IProperty *":
        return _connect.CPropertyWrapper_Find(self, pszKey)

    def Key(self) -> "LPCSTR":
        return _connect.CPropertyWrapper_Key(self)

    def Value(self) -> "LPCSTR":
        return _connect.CPropertyWrapper_Value(self)

    def PropertyValue(self, pszKey: 'LPCSTR') -> "LPCSTR":
        return _connect.CPropertyWrapper_PropertyValue(self, pszKey)

    def NumProperties(self) -> "DWORD":
        return _connect.CPropertyWrapper_NumProperties(self)

    def Property(self, dwIndex: 'DWORD') -> "CPropertyWrapper":
        return _connect.CPropertyWrapper_Property(self, dwIndex)
    __swig_destroy__ = _connect.delete_CPropertyWrapper
    __del__ = lambda self: None
CPropertyWrapper_swigregister = _connect.CPropertyWrapper_swigregister
CPropertyWrapper_swigregister(CPropertyWrapper)

class IMenuItem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMenuItem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMenuItem, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    tItem = _connect.IMenuItem_tItem
    tMenu = _connect.IMenuItem_tMenu
    tSeparator = _connect.IMenuItem_tSeparator

    def Type(self) -> "isys::IMenuItem::EType":
        return _connect.IMenuItem_Type(self)

    def Name(self) -> "LPCSTR":
        return _connect.IMenuItem_Name(self)

    def Command(self) -> "DWORD":
        return _connect.IMenuItem_Command(self)
    stateEnabled = _connect.IMenuItem_stateEnabled
    stateChecked = _connect.IMenuItem_stateChecked
    stateDialogBox = _connect.IMenuItem_stateDialogBox

    def State(self) -> "DWORD":
        return _connect.IMenuItem_State(self)

    def MenuItems(self) -> "isys::IMenuItems *":
        return _connect.IMenuItem_MenuItems(self)
    __swig_destroy__ = _connect.delete_IMenuItem
    __del__ = lambda self: None
IMenuItem_swigregister = _connect.IMenuItem_swigregister
IMenuItem_swigregister(IMenuItem)

class IMenuStructure(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMenuStructure, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMenuStructure, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Root(self) -> "isys::IMenuItems *":
        return _connect.IMenuStructure_Root(self)

    def RootItem(self) -> "isys::IMenuItem *":
        return _connect.IMenuStructure_RootItem(self)
    __swig_destroy__ = _connect.delete_IMenuStructure
    __del__ = lambda self: None
IMenuStructure_swigregister = _connect.IMenuStructure_swigregister
IMenuStructure_swigregister(IMenuStructure)

ofValNone = _connect.ofValNone
ofValString = _connect.ofValString
ofValInt = _connect.ofValInt
ofValFloat = _connect.ofValFloat
ofValStringInt = _connect.ofValStringInt
ofValBuffer = _connect.ofValBuffer
ofValFile = _connect.ofValFile
ofValMask = _connect.ofValMask
ofDestIDE = _connect.ofDestIDE
ofDestDocument = _connect.ofDestDocument
ofDestIOPEN = _connect.ofDestIOPEN
ofDestPlugin = _connect.ofDestPlugin
ofDestHIL = _connect.ofDestHIL
ofDestAuto = _connect.ofDestAuto
ofDestMask = _connect.ofDestMask
ofSet = _connect.ofSet
ofGet = _connect.ofGet
ofAdd = _connect.ofAdd
ofRemove = _connect.ofRemove
ofGetSize = _connect.ofGetSize
ofCall = _connect.ofCall
ofGetType = _connect.ofGetType
ofMask = _connect.ofMask
ofCommit = _connect.ofCommit
ofGetDescriptor = _connect.ofGetDescriptor
ofGetMenu = _connect.ofGetMenu
ofGetObjectMask = _connect.ofGetObjectMask
ofUseDescriptor = _connect.ofUseDescriptor
ofDataCreate = _connect.ofDataCreate
ofDataApply = _connect.ofDataApply
ofDataDestroy = _connect.ofDataDestroy
ofDataMask = _connect.ofDataMask
ofExact = _connect.ofExact
OPTION_URL_DestIDE = _connect.OPTION_URL_DestIDE
OPTION_URL_DestDocument = _connect.OPTION_URL_DestDocument
OPTION_URL_DestIOPEN = _connect.OPTION_URL_DestIOPEN
OPTION_URL_DestPlugin = _connect.OPTION_URL_DestPlugin
OPTION_URL_DestHIL = _connect.OPTION_URL_DestHIL
oseDataChanged = _connect.oseDataChanged
oseDescChanged = _connect.oseDescChanged
class SOptionValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SOptionValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SOptionValue, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_cPathSeparator"] = _connect.SOptionValue_m_cPathSeparator_set
    __swig_getmethods__["m_cPathSeparator"] = _connect.SOptionValue_m_cPathSeparator_get
    if _newclass:
        m_cPathSeparator = _swig_property(_connect.SOptionValue_m_cPathSeparator_get, _connect.SOptionValue_m_cPathSeparator_set)
    __swig_setmethods__["m_cValueSeparator"] = _connect.SOptionValue_m_cValueSeparator_set
    __swig_getmethods__["m_cValueSeparator"] = _connect.SOptionValue_m_cValueSeparator_get
    if _newclass:
        m_cValueSeparator = _swig_property(_connect.SOptionValue_m_cValueSeparator_get, _connect.SOptionValue_m_cValueSeparator_set)
    __swig_setmethods__["m_cOptionSeparator"] = _connect.SOptionValue_m_cOptionSeparator_set
    __swig_getmethods__["m_cOptionSeparator"] = _connect.SOptionValue_m_cOptionSeparator_get
    if _newclass:
        m_cOptionSeparator = _swig_property(_connect.SOptionValue_m_cOptionSeparator_get, _connect.SOptionValue_m_cOptionSeparator_set)
    __swig_setmethods__["m_bySideEffects"] = _connect.SOptionValue_m_bySideEffects_set
    __swig_getmethods__["m_bySideEffects"] = _connect.SOptionValue_m_bySideEffects_get
    if _newclass:
        m_bySideEffects = _swig_property(_connect.SOptionValue_m_bySideEffects_get, _connect.SOptionValue_m_bySideEffects_set)
    __swig_setmethods__["m_pszStringIn"] = _connect.SOptionValue_m_pszStringIn_set
    __swig_getmethods__["m_pszStringIn"] = _connect.SOptionValue_m_pszStringIn_get
    if _newclass:
        m_pszStringIn = _swig_property(_connect.SOptionValue_m_pszStringIn_get, _connect.SOptionValue_m_pszStringIn_set)
    __swig_setmethods__["m_pszStringOut"] = _connect.SOptionValue_m_pszStringOut_set
    __swig_getmethods__["m_pszStringOut"] = _connect.SOptionValue_m_pszStringOut_get
    if _newclass:
        m_pszStringOut = _swig_property(_connect.SOptionValue_m_pszStringOut_get, _connect.SOptionValue_m_pszStringOut_set)
    __swig_setmethods__["m_dwStringOutSize"] = _connect.SOptionValue_m_dwStringOutSize_set
    __swig_getmethods__["m_dwStringOutSize"] = _connect.SOptionValue_m_dwStringOutSize_get
    if _newclass:
        m_dwStringOutSize = _swig_property(_connect.SOptionValue_m_dwStringOutSize_get, _connect.SOptionValue_m_dwStringOutSize_set)
    __swig_setmethods__["m_dwInteger"] = _connect.SOptionValue_m_dwInteger_set
    __swig_getmethods__["m_dwInteger"] = _connect.SOptionValue_m_dwInteger_get
    if _newclass:
        m_dwInteger = _swig_property(_connect.SOptionValue_m_dwInteger_get, _connect.SOptionValue_m_dwInteger_set)
    __swig_setmethods__["m_dFloat"] = _connect.SOptionValue_m_dFloat_set
    __swig_getmethods__["m_dFloat"] = _connect.SOptionValue_m_dFloat_get
    if _newclass:
        m_dFloat = _swig_property(_connect.SOptionValue_m_dFloat_get, _connect.SOptionValue_m_dFloat_set)

    def __init__(self):
        this = _connect.new_SOptionValue()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SOptionValue
    __del__ = lambda self: None
SOptionValue_swigregister = _connect.SOptionValue_swigregister
SOptionValue_swigregister(SOptionValue)

DD_INF_SEPARATOR = _connect.DD_INF_SEPARATOR
DD_INF_TOKEN_LEADER = _connect.DD_INF_TOKEN_LEADER
DD_INF_FILE_FILTER = _connect.DD_INF_FILE_FILTER
DD_INF_FILE_DEFEXT = _connect.DD_INF_FILE_DEFEXT
DD_INF_GUI = _connect.DD_INF_GUI
DD_INF_VALUE_FORMAT = _connect.DD_INF_VALUE_FORMAT
DD_INF_OPTIONS_ID = _connect.DD_INF_OPTIONS_ID
DD_INF_GUI_DATA = _connect.DD_INF_GUI_DATA
DD_INF_GUI_SHORT = _connect.DD_INF_GUI_SHORT
DD_INF_FILE_FOLDER = _connect.DD_INF_FILE_FOLDER
DD_INF_HELP = _connect.DD_INF_HELP
DD_INF_KEY_ALT = _connect.DD_INF_KEY_ALT
optDisabled = _connect.optDisabled
optRDOnly = _connect.optRDOnly
optHidden = _connect.optHidden
optNoSerialize = _connect.optNoSerialize
optHex = _connect.optHex
optBitField = _connect.optBitField
optValueSet = _connect.optValueSet
optBitFieldSize_Pos = _connect.optBitFieldSize_Pos
optBitFieldSize_Num = _connect.optBitFieldSize_Num
optBitFieldOffs_Pos = _connect.optBitFieldOffs_Pos
optBitFieldOffs_Num = _connect.optBitFieldOffs_Num
optKindFilePath = _connect.optKindFilePath
optKindFilePath_Open = _connect.optKindFilePath_Open
optKindFilePath_Overwrite = _connect.optKindFilePath_Overwrite
optKindFilePath_RelMask = _connect.optKindFilePath_RelMask
optKindFilePath_RelWorkspace = _connect.optKindFilePath_RelWorkspace
optKindFilePath_RelEXE = _connect.optKindFilePath_RelEXE
optKindSymbol = _connect.optKindSymbol
optKindColor = _connect.optKindColor
optKindFont = _connect.optKindFont
optKindFolder = _connect.optKindFolder
optKindUser = _connect.optKindUser
optKindMask = _connect.optKindMask
optMiscValMask = _connect.optMiscValMask

def BitFieldSize(ulOptions: 'unsigned long') -> "unsigned char":
    return _connect.BitFieldSize(ulOptions)
BitFieldSize = _connect.BitFieldSize

def BitFieldOffs(ulOptions: 'unsigned long') -> "unsigned char":
    return _connect.BitFieldOffs(ulOptions)
BitFieldOffs = _connect.BitFieldOffs
class IEnumMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEnumMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEnumMap, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Value(self) -> "int":
        return _connect.IEnumMap_Value(self)

    def Name(self) -> "LPCSTR":
        return _connect.IEnumMap_Name(self)

    def Info(self) -> "LPCSTR":
        return _connect.IEnumMap_Info(self)

    def Options(self) -> "unsigned int":
        return _connect.IEnumMap_Options(self)
    __swig_destroy__ = _connect.delete_IEnumMap
    __del__ = lambda self: None
IEnumMap_swigregister = _connect.IEnumMap_swigregister
IEnumMap_swigregister(IEnumMap)

class IItemDescriptor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IItemDescriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IItemDescriptor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self) -> "LPCSTR":
        return _connect.IItemDescriptor_Name(self)

    def DataDescriptor(self) -> "DataDescriptor::IDataDescriptor const *":
        return _connect.IItemDescriptor_DataDescriptor(self)

    def Dimension(self) -> "unsigned int":
        return _connect.IItemDescriptor_Dimension(self)

    def ArrayIndex(self) -> "DataDescriptor::IEnumMaps const *":
        return _connect.IItemDescriptor_ArrayIndex(self)

    def Info(self) -> "LPCSTR":
        return _connect.IItemDescriptor_Info(self)

    def Options(self) -> "unsigned int":
        return _connect.IItemDescriptor_Options(self)

    def EnumOptions(self, pIEnumMap: 'IEnumMap') -> "unsigned int":
        return _connect.IItemDescriptor_EnumOptions(self, pIEnumMap)

    def Offset(self) -> "unsigned long":
        return _connect.IItemDescriptor_Offset(self)

    def Data(self) -> "void *":
        return _connect.IItemDescriptor_Data(self)
    __swig_destroy__ = _connect.delete_IItemDescriptor
    __del__ = lambda self: None
IItemDescriptor_swigregister = _connect.IItemDescriptor_swigregister
IItemDescriptor_swigregister(IItemDescriptor)

class IDataDescriptor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDataDescriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDataDescriptor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    tbool = _connect.IDataDescriptor_tbool
    tBOOL = _connect.IDataDescriptor_tBOOL
    tINT = _connect.IDataDescriptor_tINT
    tUINT = _connect.IDataDescriptor_tUINT
    tFLOAT = _connect.IDataDescriptor_tFLOAT
    tENUM = _connect.IDataDescriptor_tENUM
    tSTRUCT = _connect.IDataDescriptor_tSTRUCT
    tSTRING = _connect.IDataDescriptor_tSTRING
    tCString = _connect.IDataDescriptor_tCString
    tstdString = _connect.IDataDescriptor_tstdString
    tIDataBase = _connect.IDataDescriptor_tIDataBase

    def Type(self) -> "DataDescriptor::IDataDescriptor::EType":
        return _connect.IDataDescriptor_Type(self)

    def Size(self) -> "unsigned long":
        return _connect.IDataDescriptor_Size(self)

    def Struct(self) -> "DataDescriptor::IItemDescriptors const *":
        return _connect.IDataDescriptor_Struct(self)

    def Enum(self) -> "DataDescriptor::IEnumMaps const *":
        return _connect.IDataDescriptor_Enum(self)
    cNone = _connect.IDataDescriptor_cNone
    cIDArray = _connect.IDataDescriptor_cIDArray

    def Container(self) -> "DataDescriptor::IDataDescriptor::EContainer":
        return _connect.IDataDescriptor_Container(self)
    __swig_destroy__ = _connect.delete_IDataDescriptor
    __del__ = lambda self: None
IDataDescriptor_swigregister = _connect.IDataDescriptor_swigregister
IDataDescriptor_swigregister(IDataDescriptor)

class IDescriptor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IDescriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IDescriptor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VariableDescriptors(self) -> "DataDescriptor::IItemDescriptors const *":
        return _connect.IDescriptor_VariableDescriptors(self)
    __swig_destroy__ = _connect.delete_IDescriptor
    __del__ = lambda self: None
IDescriptor_swigregister = _connect.IDescriptor_swigregister
IDescriptor_swigregister(IDescriptor)
IID_IDescriptor = cvar.IID_IDescriptor

cDefaultPathSeparator = _connect.cDefaultPathSeparator
cDefaultValueSeparator = _connect.cDefaultValueSeparator
cDefaultOptionSeparator = _connect.cDefaultOptionSeparator

def PathSeparator(c: 'char') -> "char":
    return _connect.PathSeparator(c)
PathSeparator = _connect.PathSeparator

def ValueSeparator(c: 'char') -> "char":
    return _connect.ValueSeparator(c)
ValueSeparator = _connect.ValueSeparator

def OptionSeparator(c: 'char') -> "char":
    return _connect.OptionSeparator(c)
OptionSeparator = _connect.OptionSeparator
class ICodeCache(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICodeCache, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICodeCache, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    cfNoData = _connect.ICodeCache_cfNoData
    cfData = _connect.ICodeCache_cfData
    dtEqual = _connect.ICodeCache_dtEqual
    dtNotIn1 = _connect.ICodeCache_dtNotIn1
    dtNotIn2 = _connect.ICodeCache_dtNotIn2
    dtDif = _connect.ICodeCache_dtDif
    dfReportEqual = _connect.ICodeCache_dfReportEqual
    dfReportNotIn1 = _connect.ICodeCache_dfReportNotIn1
    dfReportNotIn2 = _connect.ICodeCache_dfReportNotIn2
    dfReportDif = _connect.ICodeCache_dfReportDif
    dfReportAllDif = _connect.ICodeCache_dfReportAllDif
    dfReportAll = _connect.ICodeCache_dfReportAll
    sfAddressSize4 = _connect.ICodeCache_sfAddressSize4
    sfAddressSize8 = _connect.ICodeCache_sfAddressSize8
    sfAddressMask = _connect.ICodeCache_sfAddressMask
    sfData = _connect.ICodeCache_sfData
    sfMAUSize = _connect.ICodeCache_sfMAUSize
    lFormatAuto = _connect.ICodeCache_lFormatAuto
    lFormatMotorolaS = _connect.ICodeCache_lFormatMotorolaS
    lFormatIntelHex = _connect.ICodeCache_lFormatIntelHex
    lFormatBinary = _connect.ICodeCache_lFormatBinary
    lFormatELF = _connect.ICodeCache_lFormatELF
    lFormatMask = _connect.ICodeCache_lFormatMask
    lAllowOverlap = _connect.ICodeCache_lAllowOverlap
    lSaveBytes10 = _connect.ICodeCache_lSaveBytes10
    lSaveBytes20 = _connect.ICodeCache_lSaveBytes20
    lSaveBytes40 = _connect.ICodeCache_lSaveBytes40
    lSaveBytes80 = _connect.ICodeCache_lSaveBytes80
    lSaveBytesMask = _connect.ICodeCache_lSaveBytesMask
    lOptionELF_Addr_PH_Virtual = _connect.ICodeCache_lOptionELF_Addr_PH_Virtual
    lOptionELF_Addr_PH_Physical = _connect.ICodeCache_lOptionELF_Addr_PH_Physical
    lOptionELF_Addr_Mask = _connect.ICodeCache_lOptionELF_Addr_Mask
    lOptionELF_IgnoreZeros = _connect.ICodeCache_lOptionELF_IgnoreZeros
    lOptionELF_RecognizeAuto = _connect.ICodeCache_lOptionELF_RecognizeAuto
    lOptionMask = _connect.ICodeCache_lOptionMask
    E_OPEN = _connect.ICodeCache_E_OPEN
    E_FORMAT = _connect.ICodeCache_E_FORMAT
    E_OVERLAPPING = _connect.ICodeCache_E_OVERLAPPING
    E_ADDRESSRANGE = _connect.ICodeCache_E_ADDRESSRANGE
    E_NOTSUPPORTED = _connect.ICodeCache_E_NOTSUPPORTED
    rfTypeNormal = _connect.ICodeCache_rfTypeNormal
    rfTypeDif = _connect.ICodeCache_rfTypeDif
    rfTypeMask = _connect.ICodeCache_rfTypeMask
    rfAppend = _connect.ICodeCache_rfAppend
    rfAlign = _connect.ICodeCache_rfAlign

    def Report(self, dwFlags: 'DWORD', pszFileName: 'LPCSTR', rReport: 'ICodeCache::SReport const &') -> "unsigned long":
        return _connect.ICodeCache_Report(self, dwFlags, pszFileName, rReport)

    def Offset(self, aOffset: 'TCC_ADDRESS') -> "void":
        return _connect.ICodeCache_Offset(self, aOffset)
    __swig_destroy__ = _connect.delete_ICodeCache
    __del__ = lambda self: None
ICodeCache_swigregister = _connect.ICodeCache_swigregister
ICodeCache_swigregister(ICodeCache)

class SISL_IN(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SISL_IN, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SISL_IN, name)
    __repr__ = _swig_repr
    fInit = _connect.SISL_IN_fInit
    fDone = _connect.SISL_IN_fDone
    fAPISleep = _connect.SISL_IN_fAPISleep
    fAPIMessageBoxYesNo = _connect.SISL_IN_fAPIMessageBoxYesNo
    fAPIMessageBox = _connect.SISL_IN_fAPIMessageBox
    fAPISetOutput = _connect.SISL_IN_fAPISetOutput
    fAPISetOutput1 = _connect.SISL_IN_fAPISetOutput1
    fAPIAppendOutput = _connect.SISL_IN_fAPIAppendOutput
    fAPIGotoLC = _connect.SISL_IN_fAPIGotoLC
    fAPIInputNumber = _connect.SISL_IN_fAPIInputNumber
    fAPIPrintString = _connect.SISL_IN_fAPIPrintString
    fAPIPrintStringLC = _connect.SISL_IN_fAPIPrintStringLC
    fAPIPrintInteger = _connect.SISL_IN_fAPIPrintInteger
    fAPIPrintIntegerLC = _connect.SISL_IN_fAPIPrintIntegerLC
    fAPIPrintF1 = _connect.SISL_IN_fAPIPrintF1
    fAPIPrintF1LC = _connect.SISL_IN_fAPIPrintF1LC
    fAPIPrintF2 = _connect.SISL_IN_fAPIPrintF2
    fAPIPrintF3 = _connect.SISL_IN_fAPIPrintF3
    fAPIPrintB = _connect.SISL_IN_fAPIPrintB
    fAPIClearDisplay = _connect.SISL_IN_fAPIClearDisplay
    fAPIBeep = _connect.SISL_IN_fAPIBeep
    fAPILoadProject = _connect.SISL_IN_fAPILoadProject
    fAPILoadProject1 = _connect.SISL_IN_fAPILoadProject1
    fAPISaveProject = _connect.SISL_IN_fAPISaveProject
    fAPIExit = _connect.SISL_IN_fAPIExit
    fAPIPassParameter = _connect.SISL_IN_fAPIPassParameter
    fAPICreateProcess = _connect.SISL_IN_fAPICreateProcess
    fAPISetRegisterDump = _connect.SISL_IN_fAPISetRegisterDump
    fAPIDownload = _connect.SISL_IN_fAPIDownload
    fAPIVerifyDownload = _connect.SISL_IN_fAPIVerifyDownload
    fAPIDownloadFile = _connect.SISL_IN_fAPIDownloadFile
    fAPIDownloadFile1 = _connect.SISL_IN_fAPIDownloadFile1
    fAPIReset = _connect.SISL_IN_fAPIReset
    fAPIRun = _connect.SISL_IN_fAPIRun
    fAPIStop = _connect.SISL_IN_fAPIStop
    fAPIGoto = _connect.SISL_IN_fAPIGoto
    fAPIGoto1 = _connect.SISL_IN_fAPIGoto1
    fAPIStepInto = _connect.SISL_IN_fAPIStepInto
    fAPIStepOver = _connect.SISL_IN_fAPIStepOver
    fAPISetBreakpoint = _connect.SISL_IN_fAPISetBreakpoint
    fAPIClearBreakpoint = _connect.SISL_IN_fAPIClearBreakpoint
    fAPIClearBreakpoints = _connect.SISL_IN_fAPIClearBreakpoints
    fAPIReapplyBreakpoints = _connect.SISL_IN_fAPIReapplyBreakpoints
    fAPIReadMemory = _connect.SISL_IN_fAPIReadMemory
    fAPIReadMemory1 = _connect.SISL_IN_fAPIReadMemory1
    fAPIReadMemory2 = _connect.SISL_IN_fAPIReadMemory2
    fAPIWriteMemory = _connect.SISL_IN_fAPIWriteMemory
    fAPIWriteMemory1 = _connect.SISL_IN_fAPIWriteMemory1
    fAPIWriteMemory2 = _connect.SISL_IN_fAPIWriteMemory2
    fAPIReadInt = _connect.SISL_IN_fAPIReadInt
    fAPIWriteInt = _connect.SISL_IN_fAPIWriteInt
    fAPIFillMemory = _connect.SISL_IN_fAPIFillMemory
    fAPICopyMemory = _connect.SISL_IN_fAPICopyMemory
    fAPIEvaluate = _connect.SISL_IN_fAPIEvaluate
    fAPIEvaluate1 = _connect.SISL_IN_fAPIEvaluate1
    fAPIEvaluate2 = _connect.SISL_IN_fAPIEvaluate2
    fAPIModify = _connect.SISL_IN_fAPIModify
    fAPIModify1 = _connect.SISL_IN_fAPIModify1
    fAPIBeginTrace = _connect.SISL_IN_fAPIBeginTrace
    fAPIWriteTrace = _connect.SISL_IN_fAPIWriteTrace
    fAPIWriteTrace1 = _connect.SISL_IN_fAPIWriteTrace1
    fAPISaveTrace = _connect.SISL_IN_fAPISaveTrace
    fAPIBeginProfiler = _connect.SISL_IN_fAPIBeginProfiler
    fAPISaveProfiler = _connect.SISL_IN_fAPISaveProfiler
    fAPISaveExecutionCoverage = _connect.SISL_IN_fAPISaveExecutionCoverage
    fAPISaveAccessCoverage = _connect.SISL_IN_fAPISaveAccessCoverage
    fAPIWaitStatus = _connect.SISL_IN_fAPIWaitStatus
    fAPIWaitStatus1 = _connect.SISL_IN_fAPIWaitStatus1
    fAPIFLASHProgramFile = _connect.SISL_IN_fAPIFLASHProgramFile
    fAPIFLASHProgramFile1 = _connect.SISL_IN_fAPIFLASHProgramFile1
    fAPIProjectSetTarget = _connect.SISL_IN_fAPIProjectSetTarget
    fAPIProjectMake = _connect.SISL_IN_fAPIProjectMake
    fAPIProjectIsUpToDate = _connect.SISL_IN_fAPIProjectIsUpToDate
    fAPIProjectImport = _connect.SISL_IN_fAPIProjectImport
    fAPICompareFiles = _connect.SISL_IN_fAPICompareFiles
    fAPIOpenMemoryDumpFile = _connect.SISL_IN_fAPIOpenMemoryDumpFile
    fAPIWriteMemoryDump = _connect.SISL_IN_fAPIWriteMemoryDump
    fAPIReadMemoryDump = _connect.SISL_IN_fAPIReadMemoryDump
    fAPITerminalConnect = _connect.SISL_IN_fAPITerminalConnect
    fAPI_HASYST_First = _connect.SISL_IN_fAPI_HASYST_First
    fAPI_HASYST_SetTraceOperation = _connect.SISL_IN_fAPI_HASYST_SetTraceOperation
    fAPI_HASYST_SetTraceTrigger = _connect.SISL_IN_fAPI_HASYST_SetTraceTrigger
    fAPI_HASYST_WriteID = _connect.SISL_IN_fAPI_HASYST_WriteID
    fAPI_HASYST_SetMapping = _connect.SISL_IN_fAPI_HASYST_SetMapping
    fAPI_HASYST_SetClock = _connect.SISL_IN_fAPI_HASYST_SetClock
    fAPI_HASYST_SetAccessBP = _connect.SISL_IN_fAPI_HASYST_SetAccessBP
    fAPI_HASYST_ClearAccessBP = _connect.SISL_IN_fAPI_HASYST_ClearAccessBP
    fAPI_HASYST_SetAccessBP1 = _connect.SISL_IN_fAPI_HASYST_SetAccessBP1
    fAPI_HASYST_SetParameter = _connect.SISL_IN_fAPI_HASYST_SetParameter
    fAPI_HASYST_WriteID2 = _connect.SISL_IN_fAPI_HASYST_WriteID2
    fAPI_HASYST_Last = _connect.SISL_IN_fAPI_HASYST_Last
    __swig_setmethods__["m_byFunction"] = _connect.SISL_IN_m_byFunction_set
    __swig_getmethods__["m_byFunction"] = _connect.SISL_IN_m_byFunction_get
    if _newclass:
        m_byFunction = _swig_property(_connect.SISL_IN_m_byFunction_get, _connect.SISL_IN_m_byFunction_set)
    __swig_setmethods__["m_szString1"] = _connect.SISL_IN_m_szString1_set
    __swig_getmethods__["m_szString1"] = _connect.SISL_IN_m_szString1_get
    if _newclass:
        m_szString1 = _swig_property(_connect.SISL_IN_m_szString1_get, _connect.SISL_IN_m_szString1_set)
    __swig_setmethods__["m_szString2"] = _connect.SISL_IN_m_szString2_set
    __swig_getmethods__["m_szString2"] = _connect.SISL_IN_m_szString2_get
    if _newclass:
        m_szString2 = _swig_property(_connect.SISL_IN_m_szString2_get, _connect.SISL_IN_m_szString2_set)
    __swig_setmethods__["m_szString3"] = _connect.SISL_IN_m_szString3_set
    __swig_getmethods__["m_szString3"] = _connect.SISL_IN_m_szString3_get
    if _newclass:
        m_szString3 = _swig_property(_connect.SISL_IN_m_szString3_get, _connect.SISL_IN_m_szString3_set)
    __swig_setmethods__["m_szString4"] = _connect.SISL_IN_m_szString4_set
    __swig_getmethods__["m_szString4"] = _connect.SISL_IN_m_szString4_get
    if _newclass:
        m_szString4 = _swig_property(_connect.SISL_IN_m_szString4_get, _connect.SISL_IN_m_szString4_set)
    __swig_setmethods__["m_lInt1"] = _connect.SISL_IN_m_lInt1_set
    __swig_getmethods__["m_lInt1"] = _connect.SISL_IN_m_lInt1_get
    if _newclass:
        m_lInt1 = _swig_property(_connect.SISL_IN_m_lInt1_get, _connect.SISL_IN_m_lInt1_set)
    __swig_setmethods__["m_lInt2"] = _connect.SISL_IN_m_lInt2_set
    __swig_getmethods__["m_lInt2"] = _connect.SISL_IN_m_lInt2_get
    if _newclass:
        m_lInt2 = _swig_property(_connect.SISL_IN_m_lInt2_get, _connect.SISL_IN_m_lInt2_set)
    __swig_setmethods__["m_lInt3"] = _connect.SISL_IN_m_lInt3_set
    __swig_getmethods__["m_lInt3"] = _connect.SISL_IN_m_lInt3_get
    if _newclass:
        m_lInt3 = _swig_property(_connect.SISL_IN_m_lInt3_get, _connect.SISL_IN_m_lInt3_set)
    __swig_setmethods__["m_lInt4"] = _connect.SISL_IN_m_lInt4_set
    __swig_getmethods__["m_lInt4"] = _connect.SISL_IN_m_lInt4_get
    if _newclass:
        m_lInt4 = _swig_property(_connect.SISL_IN_m_lInt4_get, _connect.SISL_IN_m_lInt4_set)
    __swig_setmethods__["m_lInt5"] = _connect.SISL_IN_m_lInt5_set
    __swig_getmethods__["m_lInt5"] = _connect.SISL_IN_m_lInt5_get
    if _newclass:
        m_lInt5 = _swig_property(_connect.SISL_IN_m_lInt5_get, _connect.SISL_IN_m_lInt5_set)
    __swig_setmethods__["m_lInt6"] = _connect.SISL_IN_m_lInt6_set
    __swig_getmethods__["m_lInt6"] = _connect.SISL_IN_m_lInt6_get
    if _newclass:
        m_lInt6 = _swig_property(_connect.SISL_IN_m_lInt6_get, _connect.SISL_IN_m_lInt6_set)
    __swig_setmethods__["m_lInt7"] = _connect.SISL_IN_m_lInt7_set
    __swig_getmethods__["m_lInt7"] = _connect.SISL_IN_m_lInt7_get
    if _newclass:
        m_lInt7 = _swig_property(_connect.SISL_IN_m_lInt7_get, _connect.SISL_IN_m_lInt7_set)
    __swig_setmethods__["m_lInt8"] = _connect.SISL_IN_m_lInt8_set
    __swig_getmethods__["m_lInt8"] = _connect.SISL_IN_m_lInt8_get
    if _newclass:
        m_lInt8 = _swig_property(_connect.SISL_IN_m_lInt8_get, _connect.SISL_IN_m_lInt8_set)

    def __init__(self):
        this = _connect.new_SISL_IN()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SISL_IN
    __del__ = lambda self: None
SISL_IN_swigregister = _connect.SISL_IN_swigregister
SISL_IN_swigregister(SISL_IN)
SERVICE_ISL = cvar.SERVICE_ISL

class SISL_OUT(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SISL_OUT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SISL_OUT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_lRetVal"] = _connect.SISL_OUT_m_lRetVal_set
    __swig_getmethods__["m_lRetVal"] = _connect.SISL_OUT_m_lRetVal_get
    if _newclass:
        m_lRetVal = _swig_property(_connect.SISL_OUT_m_lRetVal_get, _connect.SISL_OUT_m_lRetVal_set)
    __swig_setmethods__["m_szPrint"] = _connect.SISL_OUT_m_szPrint_set
    __swig_getmethods__["m_szPrint"] = _connect.SISL_OUT_m_szPrint_get
    if _newclass:
        m_szPrint = _swig_property(_connect.SISL_OUT_m_szPrint_get, _connect.SISL_OUT_m_szPrint_set)

    def __init__(self):
        this = _connect.new_SISL_OUT()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SISL_OUT
    __del__ = lambda self: None
SISL_OUT_swigregister = _connect.SISL_OUT_swigregister
SISL_OUT_swigregister(SISL_OUT)

class SBatchAccessHeader(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBatchAccessHeader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBatchAccessHeader, name)
    __repr__ = _swig_repr
    flWantTimeStamp = _connect.SBatchAccessHeader_flWantTimeStamp
    flAbortIfTooSlow = _connect.SBatchAccessHeader_flAbortIfTooSlow
    flRealTime = _connect.SBatchAccessHeader_flRealTime
    flStopResume = _connect.SBatchAccessHeader_flStopResume
    baDomainDefault = _connect.SBatchAccessHeader_baDomainDefault
    baDomainHost = _connect.SBatchAccessHeader_baDomainHost
    baDomainEmulator = _connect.SBatchAccessHeader_baDomainEmulator
    baDomainMask = _connect.SBatchAccessHeader_baDomainMask
    __swig_setmethods__["m_dwFlags"] = _connect.SBatchAccessHeader_m_dwFlags_set
    __swig_getmethods__["m_dwFlags"] = _connect.SBatchAccessHeader_m_dwFlags_get
    if _newclass:
        m_dwFlags = _swig_property(_connect.SBatchAccessHeader_m_dwFlags_get, _connect.SBatchAccessHeader_m_dwFlags_set)
    __swig_setmethods__["m_dwNumItems"] = _connect.SBatchAccessHeader_m_dwNumItems_set
    __swig_getmethods__["m_dwNumItems"] = _connect.SBatchAccessHeader_m_dwNumItems_get
    if _newclass:
        m_dwNumItems = _swig_property(_connect.SBatchAccessHeader_m_dwNumItems_get, _connect.SBatchAccessHeader_m_dwNumItems_set)
    __swig_setmethods__["m_dwNumRuns"] = _connect.SBatchAccessHeader_m_dwNumRuns_set
    __swig_getmethods__["m_dwNumRuns"] = _connect.SBatchAccessHeader_m_dwNumRuns_get
    if _newclass:
        m_dwNumRuns = _swig_property(_connect.SBatchAccessHeader_m_dwNumRuns_get, _connect.SBatchAccessHeader_m_dwNumRuns_set)
    __swig_setmethods__["m_qwStartAtTime"] = _connect.SBatchAccessHeader_m_qwStartAtTime_set
    __swig_getmethods__["m_qwStartAtTime"] = _connect.SBatchAccessHeader_m_qwStartAtTime_get
    if _newclass:
        m_qwStartAtTime = _swig_property(_connect.SBatchAccessHeader_m_qwStartAtTime_get, _connect.SBatchAccessHeader_m_qwStartAtTime_set)
    __swig_setmethods__["m_qwRunInterval"] = _connect.SBatchAccessHeader_m_qwRunInterval_set
    __swig_getmethods__["m_qwRunInterval"] = _connect.SBatchAccessHeader_m_qwRunInterval_get
    if _newclass:
        m_qwRunInterval = _swig_property(_connect.SBatchAccessHeader_m_qwRunInterval_get, _connect.SBatchAccessHeader_m_qwRunInterval_set)

    def __init__(self):
        this = _connect.new_SBatchAccessHeader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SBatchAccessHeader
    __del__ = lambda self: None
SBatchAccessHeader_swigregister = _connect.SBatchAccessHeader_swigregister
SBatchAccessHeader_swigregister(SBatchAccessHeader)

class SBatchAccessItem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBatchAccessItem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBatchAccessItem, name)
    __repr__ = _swig_repr
    MAX_DATA_SIZE = _connect.SBatchAccessItem_MAX_DATA_SIZE
    flRead = _connect.SBatchAccessItem_flRead
    flWrite = _connect.SBatchAccessItem_flWrite
    flTimeOffsetRel = _connect.SBatchAccessItem_flTimeOffsetRel
    flAccessSizeAuto = _connect.SBatchAccessItem_flAccessSizeAuto
    flAccessSize1MAU = _connect.SBatchAccessItem_flAccessSize1MAU
    flAccessSize2MAU = _connect.SBatchAccessItem_flAccessSize2MAU
    flAccessSize4MAU = _connect.SBatchAccessItem_flAccessSize4MAU
    flAccessSize8MAU = _connect.SBatchAccessItem_flAccessSize8MAU
    flAccessSizeMask = _connect.SBatchAccessItem_flAccessSizeMask
    __swig_setmethods__["m_byFlags"] = _connect.SBatchAccessItem_m_byFlags_set
    __swig_getmethods__["m_byFlags"] = _connect.SBatchAccessItem_m_byFlags_get
    if _newclass:
        m_byFlags = _swig_property(_connect.SBatchAccessItem_m_byFlags_get, _connect.SBatchAccessItem_m_byFlags_set)
    __swig_setmethods__["m_bySize"] = _connect.SBatchAccessItem_m_bySize_set
    __swig_getmethods__["m_bySize"] = _connect.SBatchAccessItem_m_bySize_get
    if _newclass:
        m_bySize = _swig_property(_connect.SBatchAccessItem_m_bySize_get, _connect.SBatchAccessItem_m_bySize_set)
    __swig_setmethods__["m_byMemArea"] = _connect.SBatchAccessItem_m_byMemArea_set
    __swig_getmethods__["m_byMemArea"] = _connect.SBatchAccessItem_m_byMemArea_get
    if _newclass:
        m_byMemArea = _swig_property(_connect.SBatchAccessItem_m_byMemArea_get, _connect.SBatchAccessItem_m_byMemArea_set)
    __swig_setmethods__["m_byReserved"] = _connect.SBatchAccessItem_m_byReserved_set
    __swig_getmethods__["m_byReserved"] = _connect.SBatchAccessItem_m_byReserved_get
    if _newclass:
        m_byReserved = _swig_property(_connect.SBatchAccessItem_m_byReserved_get, _connect.SBatchAccessItem_m_byReserved_set)
    __swig_setmethods__["m_aAddress"] = _connect.SBatchAccessItem_m_aAddress_set
    __swig_getmethods__["m_aAddress"] = _connect.SBatchAccessItem_m_aAddress_get
    if _newclass:
        m_aAddress = _swig_property(_connect.SBatchAccessItem_m_aAddress_get, _connect.SBatchAccessItem_m_aAddress_set)
    __swig_setmethods__["m_abyData"] = _connect.SBatchAccessItem_m_abyData_set
    __swig_getmethods__["m_abyData"] = _connect.SBatchAccessItem_m_abyData_get
    if _newclass:
        m_abyData = _swig_property(_connect.SBatchAccessItem_m_abyData_get, _connect.SBatchAccessItem_m_abyData_set)
    __swig_setmethods__["m_qwTimeOffset"] = _connect.SBatchAccessItem_m_qwTimeOffset_set
    __swig_getmethods__["m_qwTimeOffset"] = _connect.SBatchAccessItem_m_qwTimeOffset_get
    if _newclass:
        m_qwTimeOffset = _swig_property(_connect.SBatchAccessItem_m_qwTimeOffset_get, _connect.SBatchAccessItem_m_qwTimeOffset_set)

    def __init__(self):
        this = _connect.new_SBatchAccessItem()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SBatchAccessItem
    __del__ = lambda self: None
SBatchAccessItem_swigregister = _connect.SBatchAccessItem_swigregister
SBatchAccessItem_swigregister(SBatchAccessItem)

class SBatchAccessItemResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SBatchAccessItemResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SBatchAccessItemResult, name)
    __repr__ = _swig_repr
    resOK = _connect.SBatchAccessItemResult_resOK
    resAccess = _connect.SBatchAccessItemResult_resAccess
    resTimeout = _connect.SBatchAccessItemResult_resTimeout
    __swig_setmethods__["m_byResult"] = _connect.SBatchAccessItemResult_m_byResult_set
    __swig_getmethods__["m_byResult"] = _connect.SBatchAccessItemResult_m_byResult_get
    if _newclass:
        m_byResult = _swig_property(_connect.SBatchAccessItemResult_m_byResult_get, _connect.SBatchAccessItemResult_m_byResult_set)
    __swig_setmethods__["m_abyData"] = _connect.SBatchAccessItemResult_m_abyData_set
    __swig_getmethods__["m_abyData"] = _connect.SBatchAccessItemResult_m_abyData_get
    if _newclass:
        m_abyData = _swig_property(_connect.SBatchAccessItemResult_m_abyData_get, _connect.SBatchAccessItemResult_m_abyData_set)
    __swig_setmethods__["m_qwTimeStamp"] = _connect.SBatchAccessItemResult_m_qwTimeStamp_set
    __swig_getmethods__["m_qwTimeStamp"] = _connect.SBatchAccessItemResult_m_qwTimeStamp_get
    if _newclass:
        m_qwTimeStamp = _swig_property(_connect.SBatchAccessItemResult_m_qwTimeStamp_get, _connect.SBatchAccessItemResult_m_qwTimeStamp_set)

    def __init__(self):
        this = _connect.new_SBatchAccessItemResult()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SBatchAccessItemResult
    __del__ = lambda self: None
SBatchAccessItemResult_swigregister = _connect.SBatchAccessItemResult_swigregister
SBatchAccessItemResult_swigregister(SBatchAccessItemResult)

class SStartingPoint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SStartingPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SStartingPoint, name)
    __repr__ = _swig_repr
    eAnything = _connect.SStartingPoint_eAnything
    eExecution = _connect.SStartingPoint_eExecution
    eRead = _connect.SStartingPoint_eRead
    eWrite = _connect.SStartingPoint_eWrite
    eRW = _connect.SStartingPoint_eRW
    eAUX_State = _connect.SStartingPoint_eAUX_State
    eAUX_Edge = _connect.SStartingPoint_eAUX_Edge
    eMaskEvt = _connect.SStartingPoint_eMaskEvt
    eAddressRange = _connect.SStartingPoint_eAddressRange
    eAddressMask = _connect.SStartingPoint_eAddressMask
    eDataRange = _connect.SStartingPoint_eDataRange
    eDataMask = _connect.SStartingPoint_eDataMask
    __swig_setmethods__["m_byEvent"] = _connect.SStartingPoint_m_byEvent_set
    __swig_getmethods__["m_byEvent"] = _connect.SStartingPoint_m_byEvent_get
    if _newclass:
        m_byEvent = _swig_property(_connect.SStartingPoint_m_byEvent_get, _connect.SStartingPoint_m_byEvent_set)
    __swig_setmethods__["m_byMemArea"] = _connect.SStartingPoint_m_byMemArea_set
    __swig_getmethods__["m_byMemArea"] = _connect.SStartingPoint_m_byMemArea_get
    if _newclass:
        m_byMemArea = _swig_property(_connect.SStartingPoint_m_byMemArea_get, _connect.SStartingPoint_m_byMemArea_set)
    __swig_setmethods__["m_byDataSize"] = _connect.SStartingPoint_m_byDataSize_set
    __swig_getmethods__["m_byDataSize"] = _connect.SStartingPoint_m_byDataSize_get
    if _newclass:
        m_byDataSize = _swig_property(_connect.SStartingPoint_m_byDataSize_get, _connect.SStartingPoint_m_byDataSize_set)
    __swig_setmethods__["m_byReserved"] = _connect.SStartingPoint_m_byReserved_set
    __swig_getmethods__["m_byReserved"] = _connect.SStartingPoint_m_byReserved_get
    if _newclass:
        m_byReserved = _swig_property(_connect.SStartingPoint_m_byReserved_get, _connect.SStartingPoint_m_byReserved_set)
    __swig_setmethods__["m_aAddress"] = _connect.SStartingPoint_m_aAddress_set
    __swig_getmethods__["m_aAddress"] = _connect.SStartingPoint_m_aAddress_get
    if _newclass:
        m_aAddress = _swig_property(_connect.SStartingPoint_m_aAddress_get, _connect.SStartingPoint_m_aAddress_set)
    __swig_setmethods__["m_aAddressRM"] = _connect.SStartingPoint_m_aAddressRM_set
    __swig_getmethods__["m_aAddressRM"] = _connect.SStartingPoint_m_aAddressRM_get
    if _newclass:
        m_aAddressRM = _swig_property(_connect.SStartingPoint_m_aAddressRM_get, _connect.SStartingPoint_m_aAddressRM_set)
    __swig_setmethods__["m_dwDataAUX"] = _connect.SStartingPoint_m_dwDataAUX_set
    __swig_getmethods__["m_dwDataAUX"] = _connect.SStartingPoint_m_dwDataAUX_get
    if _newclass:
        m_dwDataAUX = _swig_property(_connect.SStartingPoint_m_dwDataAUX_get, _connect.SStartingPoint_m_dwDataAUX_set)
    __swig_setmethods__["m_dwDataAUXRM"] = _connect.SStartingPoint_m_dwDataAUXRM_set
    __swig_getmethods__["m_dwDataAUXRM"] = _connect.SStartingPoint_m_dwDataAUXRM_get
    if _newclass:
        m_dwDataAUXRM = _swig_property(_connect.SStartingPoint_m_dwDataAUXRM_get, _connect.SStartingPoint_m_dwDataAUXRM_set)

    def __init__(self):
        this = _connect.new_SStartingPoint()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SStartingPoint
    __del__ = lambda self: None
SStartingPoint_swigregister = _connect.SStartingPoint_swigregister
SStartingPoint_swigregister(SStartingPoint)

class SProfilerStartingPoint(SStartingPoint):
    __swig_setmethods__ = {}
    for _s in [SStartingPoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SProfilerStartingPoint, name, value)
    __swig_getmethods__ = {}
    for _s in [SStartingPoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SProfilerStartingPoint, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _connect.new_SProfilerStartingPoint()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SProfilerStartingPoint
    __del__ = lambda self: None
SProfilerStartingPoint_swigregister = _connect.SProfilerStartingPoint_swigregister
SProfilerStartingPoint_swigregister(SProfilerStartingPoint)

acquTrace = _connect.acquTrace
acquDAQ = _connect.acquDAQ
acquSampling = _connect.acquSampling
acquInspector = _connect.acquInspector
acquNetwork = _connect.acquNetwork
acquIOM = _connect.acquIOM
acq_NUM = _connect.acq_NUM
vtState = _connect.vtState
vtLSB_Exit_Entry = _connect.vtLSB_Exit_Entry
vtZero_Exit_Entry = _connect.vtZero_Exit_Entry
vtRegular = _connect.vtRegular
pdvdHex = _connect.pdvdHex
pdvdDec = _connect.pdvdDec
pdvdBin = _connect.pdvdBin
hValueInvalid = _connect.hValueInvalid
hpInvalid = _connect.hpInvalid
hAllTasks = _connect.hAllTasks
plNone = _connect.plNone
plTask = _connect.plTask
plIRQ_Lowest = _connect.plIRQ_Lowest
plIRQ_Highest = _connect.plIRQ_Highest
plApplication = _connect.plApplication
plRunnable = _connect.plRunnable
plSignal = _connect.plSignal
plNum = _connect.plNum
possUnknown = _connect.possUnknown
possContextRET = _connect.possContextRET
possContextRET_OS = _connect.possContextRET_OS
class SProfilerHistory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SProfilerHistory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SProfilerHistory, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_dwHandle"] = _connect.SProfilerHistory_m_dwHandle_set
    __swig_getmethods__["m_dwHandle"] = _connect.SProfilerHistory_m_dwHandle_get
    if _newclass:
        m_dwHandle = _swig_property(_connect.SProfilerHistory_m_dwHandle_get, _connect.SProfilerHistory_m_dwHandle_set)
    __swig_setmethods__["m_dwValue"] = _connect.SProfilerHistory_m_dwValue_set
    __swig_getmethods__["m_dwValue"] = _connect.SProfilerHistory_m_dwValue_get
    if _newclass:
        m_dwValue = _swig_property(_connect.SProfilerHistory_m_dwValue_get, _connect.SProfilerHistory_m_dwValue_set)
    __swig_setmethods__["m_qwTime"] = _connect.SProfilerHistory_m_qwTime_set
    __swig_getmethods__["m_qwTime"] = _connect.SProfilerHistory_m_qwTime_get
    if _newclass:
        m_qwTime = _swig_property(_connect.SProfilerHistory_m_qwTime_get, _connect.SProfilerHistory_m_qwTime_set)
    valExecEntry = _connect.SProfilerHistory_valExecEntry
    valExecSuspend = _connect.SProfilerHistory_valExecSuspend
    valExecResume = _connect.SProfilerHistory_valExecResume
    valExecExit = _connect.SProfilerHistory_valExecExit

    def __init__(self):
        this = _connect.new_SProfilerHistory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SProfilerHistory
    __del__ = lambda self: None
SProfilerHistory_swigregister = _connect.SProfilerHistory_swigregister
SProfilerHistory_swigregister(SProfilerHistory)

UNKNOWN_TASK_ID = _connect.UNKNOWN_TASK_ID
class SProfilerEncode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SProfilerEncode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SProfilerEncode, name)
    __repr__ = _swig_repr
    eNone = _connect.SProfilerEncode_eNone
    eStop_Start_Id_LSB = _connect.SProfilerEncode_eStop_Start_Id_LSB
    eStop_Start_MSB_Id = _connect.SProfilerEncode_eStop_Start_MSB_Id
    eSync_Toggle_MSB_Id = _connect.SProfilerEncode_eSync_Toggle_MSB_Id
    eMSB_Id = _connect.SProfilerEncode_eMSB_Id
    eNum = _connect.SProfilerEncode_eNum
    __swig_setmethods__["m_byEncode"] = _connect.SProfilerEncode_m_byEncode_set
    __swig_getmethods__["m_byEncode"] = _connect.SProfilerEncode_m_byEncode_get
    if _newclass:
        m_byEncode = _swig_property(_connect.SProfilerEncode_m_byEncode_get, _connect.SProfilerEncode_m_byEncode_set)
    __swig_setmethods__["m_byParam1"] = _connect.SProfilerEncode_m_byParam1_set
    __swig_getmethods__["m_byParam1"] = _connect.SProfilerEncode_m_byParam1_get
    if _newclass:
        m_byParam1 = _swig_property(_connect.SProfilerEncode_m_byParam1_get, _connect.SProfilerEncode_m_byParam1_set)
    __swig_setmethods__["m_byParam2"] = _connect.SProfilerEncode_m_byParam2_set
    __swig_getmethods__["m_byParam2"] = _connect.SProfilerEncode_m_byParam2_get
    if _newclass:
        m_byParam2 = _swig_property(_connect.SProfilerEncode_m_byParam2_get, _connect.SProfilerEncode_m_byParam2_set)
    __swig_setmethods__["m_byParam3"] = _connect.SProfilerEncode_m_byParam3_set
    __swig_getmethods__["m_byParam3"] = _connect.SProfilerEncode_m_byParam3_get
    if _newclass:
        m_byParam3 = _swig_property(_connect.SProfilerEncode_m_byParam3_get, _connect.SProfilerEncode_m_byParam3_set)

    def __init__(self):
        this = _connect.new_SProfilerEncode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SProfilerEncode
    __del__ = lambda self: None
SProfilerEncode_swigregister = _connect.SProfilerEncode_swigregister
SProfilerEncode_swigregister(SProfilerEncode)

lfSet = _connect.lfSet
lfGet = _connect.lfGet
lVcc = _connect.lVcc
lRESET = _connect.lRESET
lSRESET = _connect.lSRESET
lBREAK = _connect.lBREAK
lTRISTATE = _connect.lTRISTATE
lJTAG_TCK = _connect.lJTAG_TCK
lJTAG_TRST = _connect.lJTAG_TRST
lJTAG_TMS = _connect.lJTAG_TMS
lJTAG_TDI = _connect.lJTAG_TDI
lJTAG_TDO = _connect.lJTAG_TDO
lslLow = _connect.lslLow
lslHigh = _connect.lslHigh
class SLine_IN(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SLine_IN, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SLine_IN, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_dwFlags"] = _connect.SLine_IN_m_dwFlags_set
    __swig_getmethods__["m_dwFlags"] = _connect.SLine_IN_m_dwFlags_get
    if _newclass:
        m_dwFlags = _swig_property(_connect.SLine_IN_m_dwFlags_get, _connect.SLine_IN_m_dwFlags_set)
    __swig_setmethods__["m_dwLine"] = _connect.SLine_IN_m_dwLine_set
    __swig_getmethods__["m_dwLine"] = _connect.SLine_IN_m_dwLine_get
    if _newclass:
        m_dwLine = _swig_property(_connect.SLine_IN_m_dwLine_get, _connect.SLine_IN_m_dwLine_set)
    __swig_setmethods__["m_dwState"] = _connect.SLine_IN_m_dwState_set
    __swig_getmethods__["m_dwState"] = _connect.SLine_IN_m_dwState_get
    if _newclass:
        m_dwState = _swig_property(_connect.SLine_IN_m_dwState_get, _connect.SLine_IN_m_dwState_set)

    def __init__(self):
        this = _connect.new_SLine_IN()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SLine_IN
    __del__ = lambda self: None
SLine_IN_swigregister = _connect.SLine_IN_swigregister
SLine_IN_swigregister(SLine_IN)
SERVICE_Line = cvar.SERVICE_Line

class SLine_OUT(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SLine_OUT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SLine_OUT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_dwState"] = _connect.SLine_OUT_m_dwState_set
    __swig_getmethods__["m_dwState"] = _connect.SLine_OUT_m_dwState_get
    if _newclass:
        m_dwState = _swig_property(_connect.SLine_OUT_m_dwState_get, _connect.SLine_OUT_m_dwState_set)

    def __init__(self):
        this = _connect.new_SLine_OUT()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SLine_OUT
    __del__ = lambda self: None
SLine_OUT_swigregister = _connect.SLine_OUT_swigregister
SLine_OUT_swigregister(SLine_OUT)

JTAG_flTestLogicReset_RTI = _connect.JTAG_flTestLogicReset_RTI
JTAG_flInvertOrder = _connect.JTAG_flInvertOrder
JTAG_flShortTDO_TDI = _connect.JTAG_flShortTDO_TDI
JTAG_flPAUSE_EXIT2 = _connect.JTAG_flPAUSE_EXIT2
JTAG_flOverridePrePostFix = _connect.JTAG_flOverridePrePostFix
JTAG_flIgnoreTDI = _connect.JTAG_flIgnoreTDI
JTAG_flIgnoreTDO = _connect.JTAG_flIgnoreTDO
JTAG_SCAN_IR = _connect.JTAG_SCAN_IR
JTAG_SCAN_DR = _connect.JTAG_SCAN_DR
JTAG_SCAN_MASK = _connect.JTAG_SCAN_MASK
JTAG_EXIT_RTI = _connect.JTAG_EXIT_RTI
JTAG_EXIT_SDRS = _connect.JTAG_EXIT_SDRS
JTAG_EXIT_P = _connect.JTAG_EXIT_P
JTAG_EXIT_MASK = _connect.JTAG_EXIT_MASK
JTAG_flRTI_IR = _connect.JTAG_flRTI_IR
JTAG_flRTI_DR = _connect.JTAG_flRTI_DR
JTAG_flSDRS_IR = _connect.JTAG_flSDRS_IR
JTAG_flSDRS_DR = _connect.JTAG_flSDRS_DR
JTAG_flP_IR = _connect.JTAG_flP_IR
JTAG_flP_DR = _connect.JTAG_flP_DR
JTAG_flResetByTRSTPin = _connect.JTAG_flResetByTRSTPin
JTAG_flResetByTMS_RTI = _connect.JTAG_flResetByTMS_RTI
class SScan_IN(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SScan_IN, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SScan_IN, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_dwFlags"] = _connect.SScan_IN_m_dwFlags_set
    __swig_getmethods__["m_dwFlags"] = _connect.SScan_IN_m_dwFlags_get
    if _newclass:
        m_dwFlags = _swig_property(_connect.SScan_IN_m_dwFlags_get, _connect.SScan_IN_m_dwFlags_set)
    __swig_setmethods__["m_dwScanFlags"] = _connect.SScan_IN_m_dwScanFlags_set
    __swig_getmethods__["m_dwScanFlags"] = _connect.SScan_IN_m_dwScanFlags_get
    if _newclass:
        m_dwScanFlags = _swig_property(_connect.SScan_IN_m_dwScanFlags_get, _connect.SScan_IN_m_dwScanFlags_set)
    __swig_setmethods__["m_dwNumBits"] = _connect.SScan_IN_m_dwNumBits_set
    __swig_getmethods__["m_dwNumBits"] = _connect.SScan_IN_m_dwNumBits_get
    if _newclass:
        m_dwNumBits = _swig_property(_connect.SScan_IN_m_dwNumBits_get, _connect.SScan_IN_m_dwNumBits_set)
    __swig_setmethods__["m_wIRPrefix"] = _connect.SScan_IN_m_wIRPrefix_set
    __swig_getmethods__["m_wIRPrefix"] = _connect.SScan_IN_m_wIRPrefix_get
    if _newclass:
        m_wIRPrefix = _swig_property(_connect.SScan_IN_m_wIRPrefix_get, _connect.SScan_IN_m_wIRPrefix_set)
    __swig_setmethods__["m_wIRPostfix"] = _connect.SScan_IN_m_wIRPostfix_set
    __swig_getmethods__["m_wIRPostfix"] = _connect.SScan_IN_m_wIRPostfix_get
    if _newclass:
        m_wIRPostfix = _swig_property(_connect.SScan_IN_m_wIRPostfix_get, _connect.SScan_IN_m_wIRPostfix_set)
    __swig_setmethods__["m_wDRPrefix"] = _connect.SScan_IN_m_wDRPrefix_set
    __swig_getmethods__["m_wDRPrefix"] = _connect.SScan_IN_m_wDRPrefix_get
    if _newclass:
        m_wDRPrefix = _swig_property(_connect.SScan_IN_m_wDRPrefix_get, _connect.SScan_IN_m_wDRPrefix_set)
    __swig_setmethods__["m_wDRPostfix"] = _connect.SScan_IN_m_wDRPostfix_set
    __swig_getmethods__["m_wDRPostfix"] = _connect.SScan_IN_m_wDRPostfix_get
    if _newclass:
        m_wDRPostfix = _swig_property(_connect.SScan_IN_m_wDRPostfix_get, _connect.SScan_IN_m_wDRPostfix_set)

    def __init__(self):
        this = _connect.new_SScan_IN()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SScan_IN
    __del__ = lambda self: None
SScan_IN_swigregister = _connect.SScan_IN_swigregister
SScan_IN_swigregister(SScan_IN)
SERVICE_Scan = cvar.SERVICE_Scan


def Scan_IN_Size(rIN: 'SScan_IN') -> "unsigned long":
    return _connect.Scan_IN_Size(rIN)
Scan_IN_Size = _connect.Scan_IN_Size
class SScan_OUT(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SScan_OUT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SScan_OUT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_dwResult"] = _connect.SScan_OUT_m_dwResult_set
    __swig_getmethods__["m_dwResult"] = _connect.SScan_OUT_m_dwResult_get
    if _newclass:
        m_dwResult = _swig_property(_connect.SScan_OUT_m_dwResult_get, _connect.SScan_OUT_m_dwResult_set)

    def __init__(self):
        this = _connect.new_SScan_OUT()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_SScan_OUT
    __del__ = lambda self: None
SScan_OUT_swigregister = _connect.SScan_OUT_swigregister
SScan_OUT_swigregister(SScan_OUT)


def Scan_OUT_Size(rIN: 'SScan_IN') -> "unsigned long":
    return _connect.Scan_OUT_Size(rIN)
Scan_OUT_Size = _connect.Scan_OUT_Size
mmu_None = _connect.mmu_None
mmu_z1 = _connect.mmu_z1
mmu_z3 = _connect.mmu_z3
mmu_z4 = _connect.mmu_z4
mmu_z6 = _connect.mmu_z6
mmu_z7 = _connect.mmu_z7
mmu_Mask = _connect.mmu_Mask
mmu_NumTLBsMask = _connect.mmu_NumTLBsMask
class STLBEntry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, STLBEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, STLBEntry, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_dwMAS1"] = _connect.STLBEntry_m_dwMAS1_set
    __swig_getmethods__["m_dwMAS1"] = _connect.STLBEntry_m_dwMAS1_get
    if _newclass:
        m_dwMAS1 = _swig_property(_connect.STLBEntry_m_dwMAS1_get, _connect.STLBEntry_m_dwMAS1_set)
    __swig_setmethods__["m_dwMAS2"] = _connect.STLBEntry_m_dwMAS2_set
    __swig_getmethods__["m_dwMAS2"] = _connect.STLBEntry_m_dwMAS2_get
    if _newclass:
        m_dwMAS2 = _swig_property(_connect.STLBEntry_m_dwMAS2_get, _connect.STLBEntry_m_dwMAS2_set)
    __swig_setmethods__["m_dwMAS3"] = _connect.STLBEntry_m_dwMAS3_set
    __swig_getmethods__["m_dwMAS3"] = _connect.STLBEntry_m_dwMAS3_get
    if _newclass:
        m_dwMAS3 = _swig_property(_connect.STLBEntry_m_dwMAS3_get, _connect.STLBEntry_m_dwMAS3_set)
    __swig_setmethods__["m_dwMAS4"] = _connect.STLBEntry_m_dwMAS4_set
    __swig_getmethods__["m_dwMAS4"] = _connect.STLBEntry_m_dwMAS4_get
    if _newclass:
        m_dwMAS4 = _swig_property(_connect.STLBEntry_m_dwMAS4_get, _connect.STLBEntry_m_dwMAS4_set)
    __swig_setmethods__["m_dwMAS6"] = _connect.STLBEntry_m_dwMAS6_set
    __swig_getmethods__["m_dwMAS6"] = _connect.STLBEntry_m_dwMAS6_get
    if _newclass:
        m_dwMAS6 = _swig_property(_connect.STLBEntry_m_dwMAS6_get, _connect.STLBEntry_m_dwMAS6_set)

    def __init__(self):
        this = _connect.new_STLBEntry()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_STLBEntry
    __del__ = lambda self: None
STLBEntry_swigregister = _connect.STLBEntry_swigregister
STLBEntry_swigregister(STLBEntry)

CPUSFR_PROP_AREAS = _connect.CPUSFR_PROP_AREAS
CPUSFR_PROP_AREA = _connect.CPUSFR_PROP_AREA
CPUSFR_PROP_AREA_START = _connect.CPUSFR_PROP_AREA_START
CPUSFR_PROP_AREA_END = _connect.CPUSFR_PROP_AREA_END
CPUSFR_PROP_AREA_MAU = _connect.CPUSFR_PROP_AREA_MAU
CPUSFR_PROP_AREA_VISIBLE = _connect.CPUSFR_PROP_AREA_VISIBLE
CPUSFR_PROP_REGISTERS = _connect.CPUSFR_PROP_REGISTERS
CPUSFR_PROP_REGISTER = _connect.CPUSFR_PROP_REGISTER
CPUSFR_PROP_REGISTER_SIZE = _connect.CPUSFR_PROP_REGISTER_SIZE
CPUSFR_PROP_REGISTER_VISIBLE = _connect.CPUSFR_PROP_REGISTER_VISIBLE
class CEvent(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CEvent, name)
    __repr__ = _swig_repr

    def __init__(self, bManualReset: 'bool', bInitialState: 'bool', eventName: 'std::string const &'):
        this = _connect.new_CEvent(bManualReset, bInitialState, eventName)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _connect.delete_CEvent
    __del__ = lambda self: None

    def set(self) -> "void":
        return _connect.CEvent_set(self)

    def pulse(self) -> "void":
        return _connect.CEvent_pulse(self)

    def reset(self) -> "void":
        return _connect.CEvent_reset(self)

    def waitFor(self, *args) -> "bool":
        return _connect.CEvent_waitFor(self, *args)

    def getHandle(self) -> "HANDLE":
        return _connect.CEvent_getHandle(self)

    def alreadyExists(self) -> "bool":
        return _connect.CEvent_alreadyExists(self)

    def close(self) -> "void":
        return _connect.CEvent_close(self)
CEvent_swigregister = _connect.CEvent_swigregister
CEvent_swigregister(CEvent)

class VectorBYTE(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorBYTE, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorBYTE, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorBYTE_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorBYTE___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorBYTE___bool__(self)

    def __len__(self) -> "std::vector< unsigned char >::size_type":
        return _connect.VectorBYTE___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned char >::difference_type', j: 'std::vector< unsigned char >::difference_type') -> "std::vector< unsigned char,std::allocator< unsigned char > > *":
        return _connect.VectorBYTE___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorBYTE___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned char >::difference_type', j: 'std::vector< unsigned char >::difference_type') -> "void":
        return _connect.VectorBYTE___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorBYTE___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned char >::value_type const &":
        return _connect.VectorBYTE___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorBYTE___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned char >::value_type":
        return _connect.VectorBYTE_pop(self)

    def append(self, x: 'std::vector< unsigned char >::value_type const &') -> "void":
        return _connect.VectorBYTE_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorBYTE_empty(self)

    def size(self) -> "std::vector< unsigned char >::size_type":
        return _connect.VectorBYTE_size(self)

    def swap(self, v: 'VectorBYTE') -> "void":
        return _connect.VectorBYTE_swap(self, v)

    def begin(self) -> "std::vector< unsigned char >::iterator":
        return _connect.VectorBYTE_begin(self)

    def end(self) -> "std::vector< unsigned char >::iterator":
        return _connect.VectorBYTE_end(self)

    def rbegin(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _connect.VectorBYTE_rbegin(self)

    def rend(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _connect.VectorBYTE_rend(self)

    def clear(self) -> "void":
        return _connect.VectorBYTE_clear(self)

    def get_allocator(self) -> "std::vector< unsigned char >::allocator_type":
        return _connect.VectorBYTE_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorBYTE_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned char >::iterator":
        return _connect.VectorBYTE_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_VectorBYTE(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned char >::value_type const &') -> "void":
        return _connect.VectorBYTE_push_back(self, x)

    def front(self) -> "std::vector< unsigned char >::value_type const &":
        return _connect.VectorBYTE_front(self)

    def back(self) -> "std::vector< unsigned char >::value_type const &":
        return _connect.VectorBYTE_back(self)

    def assign(self, n: 'std::vector< unsigned char >::size_type', x: 'std::vector< unsigned char >::value_type const &') -> "void":
        return _connect.VectorBYTE_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorBYTE_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorBYTE_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned char >::size_type') -> "void":
        return _connect.VectorBYTE_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned char >::size_type":
        return _connect.VectorBYTE_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBYTE
    __del__ = lambda self: None
VectorBYTE_swigregister = _connect.VectorBYTE_swigregister
VectorBYTE_swigregister(VectorBYTE)

class VectorBatchAccessItem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorBatchAccessItem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorBatchAccessItem, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorBatchAccessItem_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorBatchAccessItem___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorBatchAccessItem___bool__(self)

    def __len__(self) -> "std::vector< SBatchAccessItem >::size_type":
        return _connect.VectorBatchAccessItem___len__(self)

    def __getslice__(self, i: 'std::vector< SBatchAccessItem >::difference_type', j: 'std::vector< SBatchAccessItem >::difference_type') -> "std::vector< SBatchAccessItem,std::allocator< SBatchAccessItem > > *":
        return _connect.VectorBatchAccessItem___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorBatchAccessItem___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< SBatchAccessItem >::difference_type', j: 'std::vector< SBatchAccessItem >::difference_type') -> "void":
        return _connect.VectorBatchAccessItem___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorBatchAccessItem___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SBatchAccessItem >::value_type const &":
        return _connect.VectorBatchAccessItem___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorBatchAccessItem___setitem__(self, *args)

    def pop(self) -> "std::vector< SBatchAccessItem >::value_type":
        return _connect.VectorBatchAccessItem_pop(self)

    def append(self, x: 'SBatchAccessItem') -> "void":
        return _connect.VectorBatchAccessItem_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorBatchAccessItem_empty(self)

    def size(self) -> "std::vector< SBatchAccessItem >::size_type":
        return _connect.VectorBatchAccessItem_size(self)

    def swap(self, v: 'VectorBatchAccessItem') -> "void":
        return _connect.VectorBatchAccessItem_swap(self, v)

    def begin(self) -> "std::vector< SBatchAccessItem >::iterator":
        return _connect.VectorBatchAccessItem_begin(self)

    def end(self) -> "std::vector< SBatchAccessItem >::iterator":
        return _connect.VectorBatchAccessItem_end(self)

    def rbegin(self) -> "std::vector< SBatchAccessItem >::reverse_iterator":
        return _connect.VectorBatchAccessItem_rbegin(self)

    def rend(self) -> "std::vector< SBatchAccessItem >::reverse_iterator":
        return _connect.VectorBatchAccessItem_rend(self)

    def clear(self) -> "void":
        return _connect.VectorBatchAccessItem_clear(self)

    def get_allocator(self) -> "std::vector< SBatchAccessItem >::allocator_type":
        return _connect.VectorBatchAccessItem_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorBatchAccessItem_pop_back(self)

    def erase(self, *args) -> "std::vector< SBatchAccessItem >::iterator":
        return _connect.VectorBatchAccessItem_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_VectorBatchAccessItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'SBatchAccessItem') -> "void":
        return _connect.VectorBatchAccessItem_push_back(self, x)

    def front(self) -> "std::vector< SBatchAccessItem >::value_type const &":
        return _connect.VectorBatchAccessItem_front(self)

    def back(self) -> "std::vector< SBatchAccessItem >::value_type const &":
        return _connect.VectorBatchAccessItem_back(self)

    def assign(self, n: 'std::vector< SBatchAccessItem >::size_type', x: 'SBatchAccessItem') -> "void":
        return _connect.VectorBatchAccessItem_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorBatchAccessItem_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorBatchAccessItem_insert(self, *args)

    def reserve(self, n: 'std::vector< SBatchAccessItem >::size_type') -> "void":
        return _connect.VectorBatchAccessItem_reserve(self, n)

    def capacity(self) -> "std::vector< SBatchAccessItem >::size_type":
        return _connect.VectorBatchAccessItem_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBatchAccessItem
    __del__ = lambda self: None
VectorBatchAccessItem_swigregister = _connect.VectorBatchAccessItem_swigregister
VectorBatchAccessItem_swigregister(VectorBatchAccessItem)

class VectorBatchAccessResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorBatchAccessResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorBatchAccessResult, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorBatchAccessResult_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorBatchAccessResult___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorBatchAccessResult___bool__(self)

    def __len__(self) -> "std::vector< SBatchAccessItemResult >::size_type":
        return _connect.VectorBatchAccessResult___len__(self)

    def __getslice__(self, i: 'std::vector< SBatchAccessItemResult >::difference_type', j: 'std::vector< SBatchAccessItemResult >::difference_type') -> "std::vector< SBatchAccessItemResult,std::allocator< SBatchAccessItemResult > > *":
        return _connect.VectorBatchAccessResult___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorBatchAccessResult___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< SBatchAccessItemResult >::difference_type', j: 'std::vector< SBatchAccessItemResult >::difference_type') -> "void":
        return _connect.VectorBatchAccessResult___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorBatchAccessResult___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SBatchAccessItemResult >::value_type const &":
        return _connect.VectorBatchAccessResult___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorBatchAccessResult___setitem__(self, *args)

    def pop(self) -> "std::vector< SBatchAccessItemResult >::value_type":
        return _connect.VectorBatchAccessResult_pop(self)

    def append(self, x: 'SBatchAccessItemResult') -> "void":
        return _connect.VectorBatchAccessResult_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorBatchAccessResult_empty(self)

    def size(self) -> "std::vector< SBatchAccessItemResult >::size_type":
        return _connect.VectorBatchAccessResult_size(self)

    def swap(self, v: 'VectorBatchAccessResult') -> "void":
        return _connect.VectorBatchAccessResult_swap(self, v)

    def begin(self) -> "std::vector< SBatchAccessItemResult >::iterator":
        return _connect.VectorBatchAccessResult_begin(self)

    def end(self) -> "std::vector< SBatchAccessItemResult >::iterator":
        return _connect.VectorBatchAccessResult_end(self)

    def rbegin(self) -> "std::vector< SBatchAccessItemResult >::reverse_iterator":
        return _connect.VectorBatchAccessResult_rbegin(self)

    def rend(self) -> "std::vector< SBatchAccessItemResult >::reverse_iterator":
        return _connect.VectorBatchAccessResult_rend(self)

    def clear(self) -> "void":
        return _connect.VectorBatchAccessResult_clear(self)

    def get_allocator(self) -> "std::vector< SBatchAccessItemResult >::allocator_type":
        return _connect.VectorBatchAccessResult_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorBatchAccessResult_pop_back(self)

    def erase(self, *args) -> "std::vector< SBatchAccessItemResult >::iterator":
        return _connect.VectorBatchAccessResult_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_VectorBatchAccessResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'SBatchAccessItemResult') -> "void":
        return _connect.VectorBatchAccessResult_push_back(self, x)

    def front(self) -> "std::vector< SBatchAccessItemResult >::value_type const &":
        return _connect.VectorBatchAccessResult_front(self)

    def back(self) -> "std::vector< SBatchAccessItemResult >::value_type const &":
        return _connect.VectorBatchAccessResult_back(self)

    def assign(self, n: 'std::vector< SBatchAccessItemResult >::size_type', x: 'SBatchAccessItemResult') -> "void":
        return _connect.VectorBatchAccessResult_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorBatchAccessResult_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorBatchAccessResult_insert(self, *args)

    def reserve(self, n: 'std::vector< SBatchAccessItemResult >::size_type') -> "void":
        return _connect.VectorBatchAccessResult_reserve(self, n)

    def capacity(self) -> "std::vector< SBatchAccessItemResult >::size_type":
        return _connect.VectorBatchAccessResult_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBatchAccessResult
    __del__ = lambda self: None
VectorBatchAccessResult_swigregister = _connect.VectorBatchAccessResult_swigregister
VectorBatchAccessResult_swigregister(VectorBatchAccessResult)

class VectorWinIDEAInstanceInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorWinIDEAInstanceInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorWinIDEAInstanceInfo, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorWinIDEAInstanceInfo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorWinIDEAInstanceInfo___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorWinIDEAInstanceInfo___bool__(self)

    def __len__(self) -> "std::vector< isys::WinIDEAInstanceInfo >::size_type":
        return _connect.VectorWinIDEAInstanceInfo___len__(self)

    def __getslice__(self, i: 'std::vector< isys::WinIDEAInstanceInfo >::difference_type', j: 'std::vector< isys::WinIDEAInstanceInfo >::difference_type') -> "std::vector< isys::WinIDEAInstanceInfo,std::allocator< isys::WinIDEAInstanceInfo > > *":
        return _connect.VectorWinIDEAInstanceInfo___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::WinIDEAInstanceInfo >::difference_type', j: 'std::vector< isys::WinIDEAInstanceInfo >::difference_type') -> "void":
        return _connect.VectorWinIDEAInstanceInfo___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::WinIDEAInstanceInfo >::value_type const &":
        return _connect.VectorWinIDEAInstanceInfo___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::WinIDEAInstanceInfo >::value_type":
        return _connect.VectorWinIDEAInstanceInfo_pop(self)

    def append(self, x: 'WinIDEAInstanceInfo') -> "void":
        return _connect.VectorWinIDEAInstanceInfo_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorWinIDEAInstanceInfo_empty(self)

    def size(self) -> "std::vector< isys::WinIDEAInstanceInfo >::size_type":
        return _connect.VectorWinIDEAInstanceInfo_size(self)

    def swap(self, v: 'VectorWinIDEAInstanceInfo') -> "void":
        return _connect.VectorWinIDEAInstanceInfo_swap(self, v)

    def begin(self) -> "std::vector< isys::WinIDEAInstanceInfo >::iterator":
        return _connect.VectorWinIDEAInstanceInfo_begin(self)

    def end(self) -> "std::vector< isys::WinIDEAInstanceInfo >::iterator":
        return _connect.VectorWinIDEAInstanceInfo_end(self)

    def rbegin(self) -> "std::vector< isys::WinIDEAInstanceInfo >::reverse_iterator":
        return _connect.VectorWinIDEAInstanceInfo_rbegin(self)

    def rend(self) -> "std::vector< isys::WinIDEAInstanceInfo >::reverse_iterator":
        return _connect.VectorWinIDEAInstanceInfo_rend(self)

    def clear(self) -> "void":
        return _connect.VectorWinIDEAInstanceInfo_clear(self)

    def get_allocator(self) -> "std::vector< isys::WinIDEAInstanceInfo >::allocator_type":
        return _connect.VectorWinIDEAInstanceInfo_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorWinIDEAInstanceInfo_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::WinIDEAInstanceInfo >::iterator":
        return _connect.VectorWinIDEAInstanceInfo_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_VectorWinIDEAInstanceInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'WinIDEAInstanceInfo') -> "void":
        return _connect.VectorWinIDEAInstanceInfo_push_back(self, x)

    def front(self) -> "std::vector< isys::WinIDEAInstanceInfo >::value_type const &":
        return _connect.VectorWinIDEAInstanceInfo_front(self)

    def back(self) -> "std::vector< isys::WinIDEAInstanceInfo >::value_type const &":
        return _connect.VectorWinIDEAInstanceInfo_back(self)

    def assign(self, n: 'std::vector< isys::WinIDEAInstanceInfo >::size_type', x: 'WinIDEAInstanceInfo') -> "void":
        return _connect.VectorWinIDEAInstanceInfo_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorWinIDEAInstanceInfo_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::WinIDEAInstanceInfo >::size_type') -> "void":
        return _connect.VectorWinIDEAInstanceInfo_reserve(self, n)

    def capacity(self) -> "std::vector< isys::WinIDEAInstanceInfo >::size_type":
        return _connect.VectorWinIDEAInstanceInfo_capacity(self)
    __swig_destroy__ = _connect.delete_VectorWinIDEAInstanceInfo
    __del__ = lambda self: None
VectorWinIDEAInstanceInfo_swigregister = _connect.VectorWinIDEAInstanceInfo_swigregister
VectorWinIDEAInstanceInfo_swigregister(VectorWinIDEAInstanceInfo)

class VectorDataComposite(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorDataComposite, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorDataComposite, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorDataComposite_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorDataComposite___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorDataComposite___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::size_type":
        return _connect.VectorDataComposite___len__(self)

    def __getslice__(self, i: 'std::vector< std::shared_ptr< isys::CDataComposite > >::difference_type', j: 'std::vector< std::shared_ptr< isys::CDataComposite > >::difference_type') -> "std::vector< std::shared_ptr< isys::CDataComposite >,std::allocator< std::shared_ptr< isys::CDataComposite > > > *":
        return _connect.VectorDataComposite___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorDataComposite___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::shared_ptr< isys::CDataComposite > >::difference_type', j: 'std::vector< std::shared_ptr< isys::CDataComposite > >::difference_type') -> "void":
        return _connect.VectorDataComposite___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorDataComposite___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &":
        return _connect.VectorDataComposite___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorDataComposite___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type":
        return _connect.VectorDataComposite_pop(self)

    def append(self, x: 'std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &') -> "void":
        return _connect.VectorDataComposite_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorDataComposite_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::size_type":
        return _connect.VectorDataComposite_size(self)

    def swap(self, v: 'VectorDataComposite') -> "void":
        return _connect.VectorDataComposite_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::iterator":
        return _connect.VectorDataComposite_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::iterator":
        return _connect.VectorDataComposite_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::reverse_iterator":
        return _connect.VectorDataComposite_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::reverse_iterator":
        return _connect.VectorDataComposite_rend(self)

    def clear(self) -> "void":
        return _connect.VectorDataComposite_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::allocator_type":
        return _connect.VectorDataComposite_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorDataComposite_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::iterator":
        return _connect.VectorDataComposite_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_VectorDataComposite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &') -> "void":
        return _connect.VectorDataComposite_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &":
        return _connect.VectorDataComposite_front(self)

    def back(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &":
        return _connect.VectorDataComposite_back(self)

    def assign(self, n: 'std::vector< std::shared_ptr< isys::CDataComposite > >::size_type', x: 'std::vector< std::shared_ptr< isys::CDataComposite > >::value_type const &') -> "void":
        return _connect.VectorDataComposite_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorDataComposite_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorDataComposite_insert(self, *args)

    def reserve(self, n: 'std::vector< std::shared_ptr< isys::CDataComposite > >::size_type') -> "void":
        return _connect.VectorDataComposite_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< isys::CDataComposite > >::size_type":
        return _connect.VectorDataComposite_capacity(self)
    __swig_destroy__ = _connect.delete_VectorDataComposite
    __del__ = lambda self: None
VectorDataComposite_swigregister = _connect.VectorDataComposite_swigregister
VectorDataComposite_swigregister(VectorDataComposite)

class VectorOnChipData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorOnChipData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorOnChipData, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VectorOnChipData_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VectorOnChipData___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VectorOnChipData___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _connect.VectorOnChipData___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _connect.VectorOnChipData___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VectorOnChipData___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        return _connect.VectorOnChipData___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VectorOnChipData___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _connect.VectorOnChipData___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VectorOnChipData___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _connect.VectorOnChipData_pop(self)

    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _connect.VectorOnChipData_append(self, x)

    def empty(self) -> "bool":
        return _connect.VectorOnChipData_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _connect.VectorOnChipData_size(self)

    def swap(self, v: 'VectorOnChipData') -> "void":
        return _connect.VectorOnChipData_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _connect.VectorOnChipData_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _connect.VectorOnChipData_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _connect.VectorOnChipData_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _connect.VectorOnChipData_rend(self)

    def clear(self) -> "void":
        return _connect.VectorOnChipData_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _connect.VectorOnChipData_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VectorOnChipData_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _connect.VectorOnChipData_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_VectorOnChipData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _connect.VectorOnChipData_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _connect.VectorOnChipData_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _connect.VectorOnChipData_back(self)

    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _connect.VectorOnChipData_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VectorOnChipData_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VectorOnChipData_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        return _connect.VectorOnChipData_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _connect.VectorOnChipData_capacity(self)
    __swig_destroy__ = _connect.delete_VectorOnChipData
    __del__ = lambda self: None
VectorOnChipData_swigregister = _connect.VectorOnChipData_swigregister
VectorOnChipData_swigregister(VectorOnChipData)

class IVectorDisassemblyLines(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorDisassemblyLines, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorDisassemblyLines, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IDisassemblyLine >::size_type":
        return _connect.IVectorDisassemblyLines_size(self)

    def at(self, _Pos: 'IVector< iEclipse::IDisassemblyLine >::size_type') -> "IVector< iEclipse::IDisassemblyLine >::interface_type *":
        return _connect.IVectorDisassemblyLines_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorDisassemblyLines
    __del__ = lambda self: None
IVectorDisassemblyLines_swigregister = _connect.IVectorDisassemblyLines_swigregister
IVectorDisassemblyLines_swigregister(IVectorDisassemblyLines)

class IVectorVariables(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorVariables, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorVariables, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IVariable >::size_type":
        return _connect.IVectorVariables_size(self)

    def at(self, _Pos: 'IVector< iEclipse::IVariable >::size_type') -> "IVector< iEclipse::IVariable >::interface_type *":
        return _connect.IVectorVariables_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorVariables
    __del__ = lambda self: None
IVectorVariables_swigregister = _connect.IVectorVariables_swigregister
IVectorVariables_swigregister(IVectorVariables)

class IVectorFunctions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorFunctions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorFunctions, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IFunction >::size_type":
        return _connect.IVectorFunctions_size(self)

    def at(self, _Pos: 'IVector< iEclipse::IFunction >::size_type') -> "IVector< iEclipse::IFunction >::interface_type *":
        return _connect.IVectorFunctions_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorFunctions
    __del__ = lambda self: None
IVectorFunctions_swigregister = _connect.IVectorFunctions_swigregister
IVectorFunctions_swigregister(IVectorFunctions)

class IVectorStackFrames(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorStackFrames, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorStackFrames, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IStackFrame >::size_type":
        return _connect.IVectorStackFrames_size(self)

    def at(self, _Pos: 'IVector< iEclipse::IStackFrame >::size_type') -> "IVector< iEclipse::IStackFrame >::interface_type *":
        return _connect.IVectorStackFrames_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorStackFrames
    __del__ = lambda self: None
IVectorStackFrames_swigregister = _connect.IVectorStackFrames_swigregister
IVectorStackFrames_swigregister(IVectorStackFrames)

class IVectorPartitions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorPartitions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorPartitions, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IPartition >::size_type":
        return _connect.IVectorPartitions_size(self)

    def at(self, _Pos: 'IVector< iEclipse::IPartition >::size_type') -> "IVector< iEclipse::IPartition >::interface_type *":
        return _connect.IVectorPartitions_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorPartitions
    __del__ = lambda self: None
IVectorPartitions_swigregister = _connect.IVectorPartitions_swigregister
IVectorPartitions_swigregister(IVectorPartitions)

class IVectorModules(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorModules, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorModules, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IModule >::size_type":
        return _connect.IVectorModules_size(self)

    def at(self, _Pos: 'IVector< iEclipse::IModule >::size_type') -> "IVector< iEclipse::IModule >::interface_type *":
        return _connect.IVectorModules_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorModules
    __del__ = lambda self: None
IVectorModules_swigregister = _connect.IVectorModules_swigregister
IVectorModules_swigregister(IVectorModules)

class IVectorSFRs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorSFRs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorSFRs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::ISFR >::size_type":
        return _connect.IVectorSFRs_size(self)

    def at(self, _Pos: 'IVector< iEclipse::ISFR >::size_type') -> "IVector< iEclipse::ISFR >::interface_type *":
        return _connect.IVectorSFRs_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorSFRs
    __del__ = lambda self: None
IVectorSFRs_swigregister = _connect.IVectorSFRs_swigregister
IVectorSFRs_swigregister(IVectorSFRs)

class IVectorValueMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorValueMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorValueMap, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::ISFRValueMap >::size_type":
        return _connect.IVectorValueMap_size(self)

    def at(self, _Pos: 'IVector< iEclipse::ISFRValueMap >::size_type') -> "IVector< iEclipse::ISFRValueMap >::interface_type *":
        return _connect.IVectorValueMap_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorValueMap
    __del__ = lambda self: None
IVectorValueMap_swigregister = _connect.IVectorValueMap_swigregister
IVectorValueMap_swigregister(IVectorValueMap)

class IVectorTypes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorTypes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorTypes, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::IType >::size_type":
        return _connect.IVectorTypes_size(self)

    def at(self, _Pos: 'IVector< iEclipse::IType >::size_type') -> "IVector< iEclipse::IType >::interface_type *":
        return _connect.IVectorTypes_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorTypes
    __del__ = lambda self: None
IVectorTypes_swigregister = _connect.IVectorTypes_swigregister
IVectorTypes_swigregister(IVectorTypes)

class IVectorTypedefs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorTypedefs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorTypedefs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::ITypedef >::size_type":
        return _connect.IVectorTypedefs_size(self)

    def at(self, _Pos: 'IVector< iEclipse::ITypedef >::size_type') -> "IVector< iEclipse::ITypedef >::interface_type *":
        return _connect.IVectorTypedefs_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorTypedefs
    __del__ = lambda self: None
IVectorTypedefs_swigregister = _connect.IVectorTypedefs_swigregister
IVectorTypedefs_swigregister(IVectorTypedefs)

class IVectorItemDescriptors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorItemDescriptors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorItemDescriptors, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< DataDescriptor::IItemDescriptor >::size_type":
        return _connect.IVectorItemDescriptors_size(self)

    def at(self, _Pos: 'IVector< DataDescriptor::IItemDescriptor >::size_type') -> "IVector< DataDescriptor::IItemDescriptor >::interface_type *":
        return _connect.IVectorItemDescriptors_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorItemDescriptors
    __del__ = lambda self: None
IVectorItemDescriptors_swigregister = _connect.IVectorItemDescriptors_swigregister
IVectorItemDescriptors_swigregister(IVectorItemDescriptors)

class IVectorEnumMaps(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorEnumMaps, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorEnumMaps, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< DataDescriptor::IEnumMap >::size_type":
        return _connect.IVectorEnumMaps_size(self)

    def at(self, _Pos: 'IVector< DataDescriptor::IEnumMap >::size_type') -> "IVector< DataDescriptor::IEnumMap >::interface_type *":
        return _connect.IVectorEnumMaps_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorEnumMaps
    __del__ = lambda self: None
IVectorEnumMaps_swigregister = _connect.IVectorEnumMaps_swigregister
IVectorEnumMaps_swigregister(IVectorEnumMaps)

class IVectorMenuItems(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorMenuItems, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorMenuItems, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< isys::IMenuItem >::size_type":
        return _connect.IVectorMenuItems_size(self)

    def at(self, _Pos: 'IVector< isys::IMenuItem >::size_type') -> "IVector< isys::IMenuItem >::interface_type *":
        return _connect.IVectorMenuItems_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorMenuItems
    __del__ = lambda self: None
IVectorMenuItems_swigregister = _connect.IVectorMenuItems_swigregister
IVectorMenuItems_swigregister(IVectorMenuItems)

class IVectorCallees(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IVectorCallees, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IVectorCallees, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self) -> "IVector< iEclipse::ICallee >::size_type":
        return _connect.IVectorCallees_size(self)

    def at(self, _Pos: 'IVector< iEclipse::ICallee >::size_type') -> "IVector< iEclipse::ICallee >::interface_type *":
        return _connect.IVectorCallees_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorCallees
    __del__ = lambda self: None
IVectorCallees_swigregister = _connect.IVectorCallees_swigregister
IVectorCallees_swigregister(IVectorCallees)

class ProfilerStatistics2Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProfilerStatistics2Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ProfilerStatistics2Vector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ProfilerStatistics2Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ProfilerStatistics2Vector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ProfilerStatistics2Vector___bool__(self)

    def __len__(self) -> "std::vector< isys::CProfilerStatistics2 >::size_type":
        return _connect.ProfilerStatistics2Vector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CProfilerStatistics2 >::difference_type', j: 'std::vector< isys::CProfilerStatistics2 >::difference_type') -> "std::vector< isys::CProfilerStatistics2,std::allocator< isys::CProfilerStatistics2 > > *":
        return _connect.ProfilerStatistics2Vector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CProfilerStatistics2 >::difference_type', j: 'std::vector< isys::CProfilerStatistics2 >::difference_type') -> "void":
        return _connect.ProfilerStatistics2Vector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CProfilerStatistics2 >::value_type const &":
        return _connect.ProfilerStatistics2Vector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CProfilerStatistics2 >::value_type":
        return _connect.ProfilerStatistics2Vector_pop(self)

    def append(self, x: 'CProfilerStatistics2') -> "void":
        return _connect.ProfilerStatistics2Vector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ProfilerStatistics2Vector_empty(self)

    def size(self) -> "std::vector< isys::CProfilerStatistics2 >::size_type":
        return _connect.ProfilerStatistics2Vector_size(self)

    def swap(self, v: 'ProfilerStatistics2Vector') -> "void":
        return _connect.ProfilerStatistics2Vector_swap(self, v)

    def begin(self) -> "std::vector< isys::CProfilerStatistics2 >::iterator":
        return _connect.ProfilerStatistics2Vector_begin(self)

    def end(self) -> "std::vector< isys::CProfilerStatistics2 >::iterator":
        return _connect.ProfilerStatistics2Vector_end(self)

    def rbegin(self) -> "std::vector< isys::CProfilerStatistics2 >::reverse_iterator":
        return _connect.ProfilerStatistics2Vector_rbegin(self)

    def rend(self) -> "std::vector< isys::CProfilerStatistics2 >::reverse_iterator":
        return _connect.ProfilerStatistics2Vector_rend(self)

    def clear(self) -> "void":
        return _connect.ProfilerStatistics2Vector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CProfilerStatistics2 >::allocator_type":
        return _connect.ProfilerStatistics2Vector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ProfilerStatistics2Vector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CProfilerStatistics2 >::iterator":
        return _connect.ProfilerStatistics2Vector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_ProfilerStatistics2Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CProfilerStatistics2') -> "void":
        return _connect.ProfilerStatistics2Vector_push_back(self, x)

    def front(self) -> "std::vector< isys::CProfilerStatistics2 >::value_type const &":
        return _connect.ProfilerStatistics2Vector_front(self)

    def back(self) -> "std::vector< isys::CProfilerStatistics2 >::value_type const &":
        return _connect.ProfilerStatistics2Vector_back(self)

    def assign(self, n: 'std::vector< isys::CProfilerStatistics2 >::size_type', x: 'CProfilerStatistics2') -> "void":
        return _connect.ProfilerStatistics2Vector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ProfilerStatistics2Vector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CProfilerStatistics2 >::size_type') -> "void":
        return _connect.ProfilerStatistics2Vector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CProfilerStatistics2 >::size_type":
        return _connect.ProfilerStatistics2Vector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerStatistics2Vector
    __del__ = lambda self: None
ProfilerStatistics2Vector_swigregister = _connect.ProfilerStatistics2Vector_swigregister
ProfilerStatistics2Vector_swigregister(ProfilerStatistics2Vector)

class ProfilerStatisticVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProfilerStatisticVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ProfilerStatisticVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ProfilerStatisticVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ProfilerStatisticVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ProfilerStatisticVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CProfilerStatistic >::size_type":
        return _connect.ProfilerStatisticVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CProfilerStatistic >::difference_type', j: 'std::vector< isys::CProfilerStatistic >::difference_type') -> "std::vector< isys::CProfilerStatistic,std::allocator< isys::CProfilerStatistic > > *":
        return _connect.ProfilerStatisticVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ProfilerStatisticVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CProfilerStatistic >::difference_type', j: 'std::vector< isys::CProfilerStatistic >::difference_type') -> "void":
        return _connect.ProfilerStatisticVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ProfilerStatisticVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CProfilerStatistic >::value_type const &":
        return _connect.ProfilerStatisticVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ProfilerStatisticVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CProfilerStatistic >::value_type":
        return _connect.ProfilerStatisticVector_pop(self)

    def append(self, x: 'CProfilerStatistic') -> "void":
        return _connect.ProfilerStatisticVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ProfilerStatisticVector_empty(self)

    def size(self) -> "std::vector< isys::CProfilerStatistic >::size_type":
        return _connect.ProfilerStatisticVector_size(self)

    def swap(self, v: 'ProfilerStatisticVector') -> "void":
        return _connect.ProfilerStatisticVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CProfilerStatistic >::iterator":
        return _connect.ProfilerStatisticVector_begin(self)

    def end(self) -> "std::vector< isys::CProfilerStatistic >::iterator":
        return _connect.ProfilerStatisticVector_end(self)

    def rbegin(self) -> "std::vector< isys::CProfilerStatistic >::reverse_iterator":
        return _connect.ProfilerStatisticVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CProfilerStatistic >::reverse_iterator":
        return _connect.ProfilerStatisticVector_rend(self)

    def clear(self) -> "void":
        return _connect.ProfilerStatisticVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CProfilerStatistic >::allocator_type":
        return _connect.ProfilerStatisticVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ProfilerStatisticVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CProfilerStatistic >::iterator":
        return _connect.ProfilerStatisticVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_ProfilerStatisticVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CProfilerStatistic') -> "void":
        return _connect.ProfilerStatisticVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CProfilerStatistic >::value_type const &":
        return _connect.ProfilerStatisticVector_front(self)

    def back(self) -> "std::vector< isys::CProfilerStatistic >::value_type const &":
        return _connect.ProfilerStatisticVector_back(self)

    def assign(self, n: 'std::vector< isys::CProfilerStatistic >::size_type', x: 'CProfilerStatistic') -> "void":
        return _connect.ProfilerStatisticVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ProfilerStatisticVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ProfilerStatisticVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CProfilerStatistic >::size_type') -> "void":
        return _connect.ProfilerStatisticVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CProfilerStatistic >::size_type":
        return _connect.ProfilerStatisticVector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerStatisticVector
    __del__ = lambda self: None
ProfilerStatisticVector_swigregister = _connect.ProfilerStatisticVector_swigregister
ProfilerStatisticVector_swigregister(ProfilerStatisticVector)

class ProfilerHistoryVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProfilerHistoryVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ProfilerHistoryVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ProfilerHistoryVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ProfilerHistoryVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ProfilerHistoryVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CProfilerHistory >::size_type":
        return _connect.ProfilerHistoryVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CProfilerHistory >::difference_type', j: 'std::vector< isys::CProfilerHistory >::difference_type') -> "std::vector< isys::CProfilerHistory,std::allocator< isys::CProfilerHistory > > *":
        return _connect.ProfilerHistoryVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ProfilerHistoryVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CProfilerHistory >::difference_type', j: 'std::vector< isys::CProfilerHistory >::difference_type') -> "void":
        return _connect.ProfilerHistoryVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ProfilerHistoryVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CProfilerHistory >::value_type const &":
        return _connect.ProfilerHistoryVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ProfilerHistoryVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CProfilerHistory >::value_type":
        return _connect.ProfilerHistoryVector_pop(self)

    def append(self, x: 'CProfilerHistory') -> "void":
        return _connect.ProfilerHistoryVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ProfilerHistoryVector_empty(self)

    def size(self) -> "std::vector< isys::CProfilerHistory >::size_type":
        return _connect.ProfilerHistoryVector_size(self)

    def swap(self, v: 'ProfilerHistoryVector') -> "void":
        return _connect.ProfilerHistoryVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CProfilerHistory >::iterator":
        return _connect.ProfilerHistoryVector_begin(self)

    def end(self) -> "std::vector< isys::CProfilerHistory >::iterator":
        return _connect.ProfilerHistoryVector_end(self)

    def rbegin(self) -> "std::vector< isys::CProfilerHistory >::reverse_iterator":
        return _connect.ProfilerHistoryVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CProfilerHistory >::reverse_iterator":
        return _connect.ProfilerHistoryVector_rend(self)

    def clear(self) -> "void":
        return _connect.ProfilerHistoryVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CProfilerHistory >::allocator_type":
        return _connect.ProfilerHistoryVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ProfilerHistoryVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CProfilerHistory >::iterator":
        return _connect.ProfilerHistoryVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_ProfilerHistoryVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CProfilerHistory') -> "void":
        return _connect.ProfilerHistoryVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CProfilerHistory >::value_type const &":
        return _connect.ProfilerHistoryVector_front(self)

    def back(self) -> "std::vector< isys::CProfilerHistory >::value_type const &":
        return _connect.ProfilerHistoryVector_back(self)

    def assign(self, n: 'std::vector< isys::CProfilerHistory >::size_type', x: 'CProfilerHistory') -> "void":
        return _connect.ProfilerHistoryVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ProfilerHistoryVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ProfilerHistoryVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CProfilerHistory >::size_type') -> "void":
        return _connect.ProfilerHistoryVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CProfilerHistory >::size_type":
        return _connect.ProfilerHistoryVector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerHistoryVector
    __del__ = lambda self: None
ProfilerHistoryVector_swigregister = _connect.ProfilerHistoryVector_swigregister
ProfilerHistoryVector_swigregister(ProfilerHistoryVector)

class CoverageRangeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoverageRangeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoverageRangeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.CoverageRangeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.CoverageRangeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.CoverageRangeVector___bool__(self)

    def __len__(self) -> "std::vector< SCoverageRange >::size_type":
        return _connect.CoverageRangeVector___len__(self)

    def __getslice__(self, i: 'std::vector< SCoverageRange >::difference_type', j: 'std::vector< SCoverageRange >::difference_type') -> "std::vector< SCoverageRange,std::allocator< SCoverageRange > > *":
        return _connect.CoverageRangeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.CoverageRangeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< SCoverageRange >::difference_type', j: 'std::vector< SCoverageRange >::difference_type') -> "void":
        return _connect.CoverageRangeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.CoverageRangeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< SCoverageRange >::value_type const &":
        return _connect.CoverageRangeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.CoverageRangeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< SCoverageRange >::value_type":
        return _connect.CoverageRangeVector_pop(self)

    def append(self, x: 'SCoverageRange') -> "void":
        return _connect.CoverageRangeVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.CoverageRangeVector_empty(self)

    def size(self) -> "std::vector< SCoverageRange >::size_type":
        return _connect.CoverageRangeVector_size(self)

    def swap(self, v: 'CoverageRangeVector') -> "void":
        return _connect.CoverageRangeVector_swap(self, v)

    def begin(self) -> "std::vector< SCoverageRange >::iterator":
        return _connect.CoverageRangeVector_begin(self)

    def end(self) -> "std::vector< SCoverageRange >::iterator":
        return _connect.CoverageRangeVector_end(self)

    def rbegin(self) -> "std::vector< SCoverageRange >::reverse_iterator":
        return _connect.CoverageRangeVector_rbegin(self)

    def rend(self) -> "std::vector< SCoverageRange >::reverse_iterator":
        return _connect.CoverageRangeVector_rend(self)

    def clear(self) -> "void":
        return _connect.CoverageRangeVector_clear(self)

    def get_allocator(self) -> "std::vector< SCoverageRange >::allocator_type":
        return _connect.CoverageRangeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.CoverageRangeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< SCoverageRange >::iterator":
        return _connect.CoverageRangeVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_CoverageRangeVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'SCoverageRange') -> "void":
        return _connect.CoverageRangeVector_push_back(self, x)

    def front(self) -> "std::vector< SCoverageRange >::value_type const &":
        return _connect.CoverageRangeVector_front(self)

    def back(self) -> "std::vector< SCoverageRange >::value_type const &":
        return _connect.CoverageRangeVector_back(self)

    def assign(self, n: 'std::vector< SCoverageRange >::size_type', x: 'SCoverageRange') -> "void":
        return _connect.CoverageRangeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.CoverageRangeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.CoverageRangeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< SCoverageRange >::size_type') -> "void":
        return _connect.CoverageRangeVector_reserve(self, n)

    def capacity(self) -> "std::vector< SCoverageRange >::size_type":
        return _connect.CoverageRangeVector_capacity(self)
    __swig_destroy__ = _connect.delete_CoverageRangeVector
    __del__ = lambda self: None
CoverageRangeVector_swigregister = _connect.CoverageRangeVector_swigregister
CoverageRangeVector_swigregister(CoverageRangeVector)

class DownloadListVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DownloadListVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DownloadListVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.DownloadListVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.DownloadListVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.DownloadListVector___bool__(self)

    def __len__(self) -> "std::vector< isys::DownloadListMember >::size_type":
        return _connect.DownloadListVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::DownloadListMember >::difference_type', j: 'std::vector< isys::DownloadListMember >::difference_type') -> "std::vector< isys::DownloadListMember,std::allocator< isys::DownloadListMember > > *":
        return _connect.DownloadListVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.DownloadListVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::DownloadListMember >::difference_type', j: 'std::vector< isys::DownloadListMember >::difference_type') -> "void":
        return _connect.DownloadListVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.DownloadListVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::DownloadListMember >::value_type const &":
        return _connect.DownloadListVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.DownloadListVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::DownloadListMember >::value_type":
        return _connect.DownloadListVector_pop(self)

    def append(self, x: 'DownloadListMember') -> "void":
        return _connect.DownloadListVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.DownloadListVector_empty(self)

    def size(self) -> "std::vector< isys::DownloadListMember >::size_type":
        return _connect.DownloadListVector_size(self)

    def swap(self, v: 'DownloadListVector') -> "void":
        return _connect.DownloadListVector_swap(self, v)

    def begin(self) -> "std::vector< isys::DownloadListMember >::iterator":
        return _connect.DownloadListVector_begin(self)

    def end(self) -> "std::vector< isys::DownloadListMember >::iterator":
        return _connect.DownloadListVector_end(self)

    def rbegin(self) -> "std::vector< isys::DownloadListMember >::reverse_iterator":
        return _connect.DownloadListVector_rbegin(self)

    def rend(self) -> "std::vector< isys::DownloadListMember >::reverse_iterator":
        return _connect.DownloadListVector_rend(self)

    def clear(self) -> "void":
        return _connect.DownloadListVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::DownloadListMember >::allocator_type":
        return _connect.DownloadListVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.DownloadListVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::DownloadListMember >::iterator":
        return _connect.DownloadListVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_DownloadListVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'DownloadListMember') -> "void":
        return _connect.DownloadListVector_push_back(self, x)

    def front(self) -> "std::vector< isys::DownloadListMember >::value_type const &":
        return _connect.DownloadListVector_front(self)

    def back(self) -> "std::vector< isys::DownloadListMember >::value_type const &":
        return _connect.DownloadListVector_back(self)

    def assign(self, n: 'std::vector< isys::DownloadListMember >::size_type', x: 'DownloadListMember') -> "void":
        return _connect.DownloadListVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.DownloadListVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.DownloadListVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::DownloadListMember >::size_type') -> "void":
        return _connect.DownloadListVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::DownloadListMember >::size_type":
        return _connect.DownloadListVector_capacity(self)
    __swig_destroy__ = _connect.delete_DownloadListVector
    __del__ = lambda self: None
DownloadListVector_swigregister = _connect.DownloadListVector_swigregister
DownloadListVector_swigregister(DownloadListVector)

class StackFrameVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StackFrameVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StackFrameVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StackFrameVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StackFrameVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StackFrameVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CStackFrame >::size_type":
        return _connect.StackFrameVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CStackFrame >::difference_type', j: 'std::vector< isys::CStackFrame >::difference_type') -> "std::vector< isys::CStackFrame,std::allocator< isys::CStackFrame > > *":
        return _connect.StackFrameVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.StackFrameVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CStackFrame >::difference_type', j: 'std::vector< isys::CStackFrame >::difference_type') -> "void":
        return _connect.StackFrameVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.StackFrameVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CStackFrame >::value_type const &":
        return _connect.StackFrameVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.StackFrameVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CStackFrame >::value_type":
        return _connect.StackFrameVector_pop(self)

    def append(self, x: 'CStackFrame') -> "void":
        return _connect.StackFrameVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.StackFrameVector_empty(self)

    def size(self) -> "std::vector< isys::CStackFrame >::size_type":
        return _connect.StackFrameVector_size(self)

    def swap(self, v: 'StackFrameVector') -> "void":
        return _connect.StackFrameVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CStackFrame >::iterator":
        return _connect.StackFrameVector_begin(self)

    def end(self) -> "std::vector< isys::CStackFrame >::iterator":
        return _connect.StackFrameVector_end(self)

    def rbegin(self) -> "std::vector< isys::CStackFrame >::reverse_iterator":
        return _connect.StackFrameVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CStackFrame >::reverse_iterator":
        return _connect.StackFrameVector_rend(self)

    def clear(self) -> "void":
        return _connect.StackFrameVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CStackFrame >::allocator_type":
        return _connect.StackFrameVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.StackFrameVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CStackFrame >::iterator":
        return _connect.StackFrameVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_StackFrameVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CStackFrame') -> "void":
        return _connect.StackFrameVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CStackFrame >::value_type const &":
        return _connect.StackFrameVector_front(self)

    def back(self) -> "std::vector< isys::CStackFrame >::value_type const &":
        return _connect.StackFrameVector_back(self)

    def assign(self, n: 'std::vector< isys::CStackFrame >::size_type', x: 'CStackFrame') -> "void":
        return _connect.StackFrameVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.StackFrameVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.StackFrameVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CStackFrame >::size_type') -> "void":
        return _connect.StackFrameVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CStackFrame >::size_type":
        return _connect.StackFrameVector_capacity(self)
    __swig_destroy__ = _connect.delete_StackFrameVector
    __del__ = lambda self: None
StackFrameVector_swigregister = _connect.StackFrameVector_swigregister
StackFrameVector_swigregister(StackFrameVector)

class VariableVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariableVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VariableVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.VariableVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.VariableVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.VariableVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CVariable >::size_type":
        return _connect.VariableVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CVariable >::difference_type', j: 'std::vector< isys::CVariable >::difference_type') -> "std::vector< isys::CVariable,std::allocator< isys::CVariable > > *":
        return _connect.VariableVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.VariableVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CVariable >::difference_type', j: 'std::vector< isys::CVariable >::difference_type') -> "void":
        return _connect.VariableVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.VariableVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CVariable >::value_type const &":
        return _connect.VariableVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.VariableVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CVariable >::value_type":
        return _connect.VariableVector_pop(self)

    def append(self, x: 'CVariable') -> "void":
        return _connect.VariableVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.VariableVector_empty(self)

    def size(self) -> "std::vector< isys::CVariable >::size_type":
        return _connect.VariableVector_size(self)

    def swap(self, v: 'VariableVector') -> "void":
        return _connect.VariableVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CVariable >::iterator":
        return _connect.VariableVector_begin(self)

    def end(self) -> "std::vector< isys::CVariable >::iterator":
        return _connect.VariableVector_end(self)

    def rbegin(self) -> "std::vector< isys::CVariable >::reverse_iterator":
        return _connect.VariableVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CVariable >::reverse_iterator":
        return _connect.VariableVector_rend(self)

    def clear(self) -> "void":
        return _connect.VariableVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CVariable >::allocator_type":
        return _connect.VariableVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.VariableVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CVariable >::iterator":
        return _connect.VariableVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_VariableVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CVariable') -> "void":
        return _connect.VariableVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CVariable >::value_type const &":
        return _connect.VariableVector_front(self)

    def back(self) -> "std::vector< isys::CVariable >::value_type const &":
        return _connect.VariableVector_back(self)

    def assign(self, n: 'std::vector< isys::CVariable >::size_type', x: 'CVariable') -> "void":
        return _connect.VariableVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.VariableVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.VariableVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CVariable >::size_type') -> "void":
        return _connect.VariableVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CVariable >::size_type":
        return _connect.VariableVector_capacity(self)
    __swig_destroy__ = _connect.delete_VariableVector
    __del__ = lambda self: None
VariableVector_swigregister = _connect.VariableVector_swigregister
VariableVector_swigregister(VariableVector)

class FunctionVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FunctionVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.FunctionVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.FunctionVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.FunctionVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CFunction >::size_type":
        return _connect.FunctionVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CFunction >::difference_type', j: 'std::vector< isys::CFunction >::difference_type') -> "std::vector< isys::CFunction,std::allocator< isys::CFunction > > *":
        return _connect.FunctionVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.FunctionVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CFunction >::difference_type', j: 'std::vector< isys::CFunction >::difference_type') -> "void":
        return _connect.FunctionVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.FunctionVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CFunction >::value_type const &":
        return _connect.FunctionVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.FunctionVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CFunction >::value_type":
        return _connect.FunctionVector_pop(self)

    def append(self, x: 'CFunction') -> "void":
        return _connect.FunctionVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.FunctionVector_empty(self)

    def size(self) -> "std::vector< isys::CFunction >::size_type":
        return _connect.FunctionVector_size(self)

    def swap(self, v: 'FunctionVector') -> "void":
        return _connect.FunctionVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CFunction >::iterator":
        return _connect.FunctionVector_begin(self)

    def end(self) -> "std::vector< isys::CFunction >::iterator":
        return _connect.FunctionVector_end(self)

    def rbegin(self) -> "std::vector< isys::CFunction >::reverse_iterator":
        return _connect.FunctionVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CFunction >::reverse_iterator":
        return _connect.FunctionVector_rend(self)

    def clear(self) -> "void":
        return _connect.FunctionVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CFunction >::allocator_type":
        return _connect.FunctionVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.FunctionVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CFunction >::iterator":
        return _connect.FunctionVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_FunctionVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CFunction') -> "void":
        return _connect.FunctionVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CFunction >::value_type const &":
        return _connect.FunctionVector_front(self)

    def back(self) -> "std::vector< isys::CFunction >::value_type const &":
        return _connect.FunctionVector_back(self)

    def assign(self, n: 'std::vector< isys::CFunction >::size_type', x: 'CFunction') -> "void":
        return _connect.FunctionVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.FunctionVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.FunctionVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CFunction >::size_type') -> "void":
        return _connect.FunctionVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CFunction >::size_type":
        return _connect.FunctionVector_capacity(self)
    __swig_destroy__ = _connect.delete_FunctionVector
    __del__ = lambda self: None
FunctionVector_swigregister = _connect.FunctionVector_swigregister
FunctionVector_swigregister(FunctionVector)

class ModuleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModuleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModuleVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.ModuleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.ModuleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.ModuleVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CModule >::size_type":
        return _connect.ModuleVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CModule >::difference_type', j: 'std::vector< isys::CModule >::difference_type') -> "std::vector< isys::CModule,std::allocator< isys::CModule > > *":
        return _connect.ModuleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.ModuleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CModule >::difference_type', j: 'std::vector< isys::CModule >::difference_type') -> "void":
        return _connect.ModuleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.ModuleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CModule >::value_type const &":
        return _connect.ModuleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.ModuleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CModule >::value_type":
        return _connect.ModuleVector_pop(self)

    def append(self, x: 'CModule') -> "void":
        return _connect.ModuleVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.ModuleVector_empty(self)

    def size(self) -> "std::vector< isys::CModule >::size_type":
        return _connect.ModuleVector_size(self)

    def swap(self, v: 'ModuleVector') -> "void":
        return _connect.ModuleVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CModule >::iterator":
        return _connect.ModuleVector_begin(self)

    def end(self) -> "std::vector< isys::CModule >::iterator":
        return _connect.ModuleVector_end(self)

    def rbegin(self) -> "std::vector< isys::CModule >::reverse_iterator":
        return _connect.ModuleVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CModule >::reverse_iterator":
        return _connect.ModuleVector_rend(self)

    def clear(self) -> "void":
        return _connect.ModuleVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CModule >::allocator_type":
        return _connect.ModuleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.ModuleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CModule >::iterator":
        return _connect.ModuleVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_ModuleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CModule') -> "void":
        return _connect.ModuleVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CModule >::value_type const &":
        return _connect.ModuleVector_front(self)

    def back(self) -> "std::vector< isys::CModule >::value_type const &":
        return _connect.ModuleVector_back(self)

    def assign(self, n: 'std::vector< isys::CModule >::size_type', x: 'CModule') -> "void":
        return _connect.ModuleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.ModuleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.ModuleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CModule >::size_type') -> "void":
        return _connect.ModuleVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CModule >::size_type":
        return _connect.ModuleVector_capacity(self)
    __swig_destroy__ = _connect.delete_ModuleVector
    __del__ = lambda self: None
ModuleVector_swigregister = _connect.ModuleVector_swigregister
ModuleVector_swigregister(ModuleVector)

class TypeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.TypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.TypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.TypeVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CType >::size_type":
        return _connect.TypeVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CType >::difference_type', j: 'std::vector< isys::CType >::difference_type') -> "std::vector< isys::CType,std::allocator< isys::CType > > *":
        return _connect.TypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.TypeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CType >::difference_type', j: 'std::vector< isys::CType >::difference_type') -> "void":
        return _connect.TypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.TypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CType >::value_type const &":
        return _connect.TypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.TypeVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CType >::value_type":
        return _connect.TypeVector_pop(self)

    def append(self, x: 'CType') -> "void":
        return _connect.TypeVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.TypeVector_empty(self)

    def size(self) -> "std::vector< isys::CType >::size_type":
        return _connect.TypeVector_size(self)

    def swap(self, v: 'TypeVector') -> "void":
        return _connect.TypeVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CType >::iterator":
        return _connect.TypeVector_begin(self)

    def end(self) -> "std::vector< isys::CType >::iterator":
        return _connect.TypeVector_end(self)

    def rbegin(self) -> "std::vector< isys::CType >::reverse_iterator":
        return _connect.TypeVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CType >::reverse_iterator":
        return _connect.TypeVector_rend(self)

    def clear(self) -> "void":
        return _connect.TypeVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CType >::allocator_type":
        return _connect.TypeVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.TypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CType >::iterator":
        return _connect.TypeVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_TypeVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CType') -> "void":
        return _connect.TypeVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CType >::value_type const &":
        return _connect.TypeVector_front(self)

    def back(self) -> "std::vector< isys::CType >::value_type const &":
        return _connect.TypeVector_back(self)

    def assign(self, n: 'std::vector< isys::CType >::size_type', x: 'CType') -> "void":
        return _connect.TypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.TypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.TypeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CType >::size_type') -> "void":
        return _connect.TypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CType >::size_type":
        return _connect.TypeVector_capacity(self)
    __swig_destroy__ = _connect.delete_TypeVector
    __del__ = lambda self: None
TypeVector_swigregister = _connect.TypeVector_swigregister
TypeVector_swigregister(TypeVector)

class TypedefVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypedefVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TypedefVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.TypedefVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.TypedefVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.TypedefVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CTypedef >::size_type":
        return _connect.TypedefVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CTypedef >::difference_type', j: 'std::vector< isys::CTypedef >::difference_type') -> "std::vector< isys::CTypedef,std::allocator< isys::CTypedef > > *":
        return _connect.TypedefVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.TypedefVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CTypedef >::difference_type', j: 'std::vector< isys::CTypedef >::difference_type') -> "void":
        return _connect.TypedefVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.TypedefVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CTypedef >::value_type const &":
        return _connect.TypedefVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.TypedefVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CTypedef >::value_type":
        return _connect.TypedefVector_pop(self)

    def append(self, x: 'CTypedef') -> "void":
        return _connect.TypedefVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.TypedefVector_empty(self)

    def size(self) -> "std::vector< isys::CTypedef >::size_type":
        return _connect.TypedefVector_size(self)

    def swap(self, v: 'TypedefVector') -> "void":
        return _connect.TypedefVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CTypedef >::iterator":
        return _connect.TypedefVector_begin(self)

    def end(self) -> "std::vector< isys::CTypedef >::iterator":
        return _connect.TypedefVector_end(self)

    def rbegin(self) -> "std::vector< isys::CTypedef >::reverse_iterator":
        return _connect.TypedefVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CTypedef >::reverse_iterator":
        return _connect.TypedefVector_rend(self)

    def clear(self) -> "void":
        return _connect.TypedefVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CTypedef >::allocator_type":
        return _connect.TypedefVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.TypedefVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CTypedef >::iterator":
        return _connect.TypedefVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_TypedefVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CTypedef') -> "void":
        return _connect.TypedefVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CTypedef >::value_type const &":
        return _connect.TypedefVector_front(self)

    def back(self) -> "std::vector< isys::CTypedef >::value_type const &":
        return _connect.TypedefVector_back(self)

    def assign(self, n: 'std::vector< isys::CTypedef >::size_type', x: 'CTypedef') -> "void":
        return _connect.TypedefVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.TypedefVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.TypedefVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CTypedef >::size_type') -> "void":
        return _connect.TypedefVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CTypedef >::size_type":
        return _connect.TypedefVector_capacity(self)
    __swig_destroy__ = _connect.delete_TypedefVector
    __del__ = lambda self: None
TypedefVector_swigregister = _connect.TypedefVector_swigregister
TypedefVector_swigregister(TypedefVector)

class HILChannelVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HILChannelVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HILChannelVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.HILChannelVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.HILChannelVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.HILChannelVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::size_type":
        return _connect.HILChannelVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::shared_ptr< isys::CHILChannel > >::difference_type', j: 'std::vector< std::shared_ptr< isys::CHILChannel > >::difference_type') -> "std::vector< std::shared_ptr< isys::CHILChannel >,std::allocator< std::shared_ptr< isys::CHILChannel > > > *":
        return _connect.HILChannelVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.HILChannelVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::shared_ptr< isys::CHILChannel > >::difference_type', j: 'std::vector< std::shared_ptr< isys::CHILChannel > >::difference_type') -> "void":
        return _connect.HILChannelVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.HILChannelVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &":
        return _connect.HILChannelVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.HILChannelVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type":
        return _connect.HILChannelVector_pop(self)

    def append(self, x: 'std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &') -> "void":
        return _connect.HILChannelVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.HILChannelVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::size_type":
        return _connect.HILChannelVector_size(self)

    def swap(self, v: 'HILChannelVector') -> "void":
        return _connect.HILChannelVector_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::iterator":
        return _connect.HILChannelVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::iterator":
        return _connect.HILChannelVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::reverse_iterator":
        return _connect.HILChannelVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::reverse_iterator":
        return _connect.HILChannelVector_rend(self)

    def clear(self) -> "void":
        return _connect.HILChannelVector_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::allocator_type":
        return _connect.HILChannelVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.HILChannelVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::iterator":
        return _connect.HILChannelVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_HILChannelVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &') -> "void":
        return _connect.HILChannelVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &":
        return _connect.HILChannelVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &":
        return _connect.HILChannelVector_back(self)

    def assign(self, n: 'std::vector< std::shared_ptr< isys::CHILChannel > >::size_type', x: 'std::vector< std::shared_ptr< isys::CHILChannel > >::value_type const &') -> "void":
        return _connect.HILChannelVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.HILChannelVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.HILChannelVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::shared_ptr< isys::CHILChannel > >::size_type') -> "void":
        return _connect.HILChannelVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< isys::CHILChannel > >::size_type":
        return _connect.HILChannelVector_capacity(self)
    __swig_destroy__ = _connect.delete_HILChannelVector
    __del__ = lambda self: None
HILChannelVector_swigregister = _connect.HILChannelVector_swigregister
HILChannelVector_swigregister(HILChannelVector)

class StrVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _connect.StrVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _connect.StrVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.StrVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _connect.StrVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.StrVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _connect.StrVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.StrVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _connect.StrVector_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _connect.StrVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.StrVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _connect.StrVector_size(self)

    def swap(self, v: 'StrVector') -> "void":
        return _connect.StrVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _connect.StrVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _connect.StrVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _connect.StrVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _connect.StrVector_rend(self)

    def clear(self) -> "void":
        return _connect.StrVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _connect.StrVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.StrVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _connect.StrVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_StrVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _connect.StrVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _connect.StrVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _connect.StrVector_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _connect.StrVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.StrVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.StrVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _connect.StrVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _connect.StrVector_capacity(self)
    __swig_destroy__ = _connect.delete_StrVector
    __del__ = lambda self: None
StrVector_swigregister = _connect.StrVector_swigregister
StrVector_swigregister(StrVector)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _connect.IntVector___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _connect.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.IntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _connect.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _connect.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _connect.IntVector_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _connect.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _connect.IntVector_size(self)

    def swap(self, v: 'IntVector') -> "void":
        return _connect.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _connect.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _connect.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _connect.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _connect.IntVector_rend(self)

    def clear(self) -> "void":
        return _connect.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _connect.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _connect.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _connect.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _connect.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _connect.IntVector_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _connect.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.IntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _connect.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _connect.IntVector_capacity(self)
    __swig_destroy__ = _connect.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _connect.IntVector_swigregister
IntVector_swigregister(IntVector)

class StrSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _connect.new_StrSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def size(self) -> "unsigned int":
        return _connect.StrSet_size(self)

    def empty(self) -> "bool":
        return _connect.StrSet_empty(self)

    def clear(self) -> "void":
        return _connect.StrSet_clear(self)

    def remove(self, key: 'std::string const &') -> "void":
        return _connect.StrSet_remove(self, key)

    def contains(self, value: 'std::string const &') -> "bool":
        return _connect.StrSet_contains(self, value)

    def toString(self) -> "std::string":
        return _connect.StrSet_toString(self)
    __swig_destroy__ = _connect.delete_StrSet
    __del__ = lambda self: None
StrSet_swigregister = _connect.StrSet_swigregister
StrSet_swigregister(StrSet)

class StrStrMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrStrMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrStrMap, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrStrMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrStrMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::string >::size_type":
        return _connect.StrStrMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,std::string >::key_type const &') -> "std::map< std::string,std::string >::mapped_type const &":
        return _connect.StrStrMap___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,std::string >::key_type const &') -> "void":
        return _connect.StrStrMap___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,std::string >::key_type const &') -> "bool":
        return _connect.StrStrMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _connect.StrStrMap_keys(self)

    def values(self) -> "PyObject *":
        return _connect.StrStrMap_values(self)

    def items(self) -> "PyObject *":
        return _connect.StrStrMap_items(self)

    def __contains__(self, key: 'std::map< std::string,std::string >::key_type const &') -> "bool":
        return _connect.StrStrMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrStrMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _connect.StrStrMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _connect.StrStrMap_asdict(self)

    def __init__(self, *args):
        this = _connect.new_StrStrMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _connect.StrStrMap_empty(self)

    def size(self) -> "std::map< std::string,std::string >::size_type":
        return _connect.StrStrMap_size(self)

    def swap(self, v: 'StrStrMap') -> "void":
        return _connect.StrStrMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_begin(self)

    def end(self) -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _connect.StrStrMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _connect.StrStrMap_rend(self)

    def clear(self) -> "void":
        return _connect.StrStrMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::string >::allocator_type":
        return _connect.StrStrMap_get_allocator(self)

    def count(self, x: 'std::map< std::string,std::string >::key_type const &') -> "std::map< std::string,std::string >::size_type":
        return _connect.StrStrMap_count(self, x)

    def erase(self, *args) -> "void":
        return _connect.StrStrMap_erase(self, *args)

    def find(self, x: 'std::map< std::string,std::string >::key_type const &') -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,std::string >::key_type const &') -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,std::string >::key_type const &') -> "std::map< std::string,std::string >::iterator":
        return _connect.StrStrMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrStrMap
    __del__ = lambda self: None
StrStrMap_swigregister = _connect.StrStrMap_swigregister
StrStrMap_swigregister(StrStrMap)

class StrStrMapIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrStrMapIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrStrMapIterator, name)
    __repr__ = _swig_repr

    def __init__(self, container: 'StrStrMap'):
        this = _connect.new_StrStrMapIterator(container)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isValid(self) -> "bool":
        return _connect.StrStrMapIterator_isValid(self)

    def key(self) -> "std::string const &":
        return _connect.StrStrMapIterator_key(self)

    def value(self) -> "std::string const &":
        return _connect.StrStrMapIterator_value(self)

    def inc(self) -> "void":
        return _connect.StrStrMapIterator_inc(self)
    __swig_destroy__ = _connect.delete_StrStrMapIterator
    __del__ = lambda self: None
StrStrMapIterator_swigregister = _connect.StrStrMapIterator_swigregister
StrStrMapIterator_swigregister(StrStrMapIterator)

class AddressVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AddressVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AddressVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.AddressVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.AddressVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.AddressVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned long >::size_type":
        return _connect.AddressVector___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned long >::difference_type', j: 'std::vector< unsigned long >::difference_type') -> "std::vector< unsigned long,std::allocator< unsigned long > > *":
        return _connect.AddressVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.AddressVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned long >::difference_type', j: 'std::vector< unsigned long >::difference_type') -> "void":
        return _connect.AddressVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.AddressVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long >::value_type const &":
        return _connect.AddressVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.AddressVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long >::value_type":
        return _connect.AddressVector_pop(self)

    def append(self, x: 'std::vector< unsigned long >::value_type const &') -> "void":
        return _connect.AddressVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.AddressVector_empty(self)

    def size(self) -> "std::vector< unsigned long >::size_type":
        return _connect.AddressVector_size(self)

    def swap(self, v: 'AddressVector') -> "void":
        return _connect.AddressVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned long >::iterator":
        return _connect.AddressVector_begin(self)

    def end(self) -> "std::vector< unsigned long >::iterator":
        return _connect.AddressVector_end(self)

    def rbegin(self) -> "std::vector< unsigned long >::reverse_iterator":
        return _connect.AddressVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned long >::reverse_iterator":
        return _connect.AddressVector_rend(self)

    def clear(self) -> "void":
        return _connect.AddressVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long >::allocator_type":
        return _connect.AddressVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.AddressVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long >::iterator":
        return _connect.AddressVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_AddressVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned long >::value_type const &') -> "void":
        return _connect.AddressVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned long >::value_type const &":
        return _connect.AddressVector_front(self)

    def back(self) -> "std::vector< unsigned long >::value_type const &":
        return _connect.AddressVector_back(self)

    def assign(self, n: 'std::vector< unsigned long >::size_type', x: 'std::vector< unsigned long >::value_type const &') -> "void":
        return _connect.AddressVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.AddressVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.AddressVector_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned long >::size_type') -> "void":
        return _connect.AddressVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long >::size_type":
        return _connect.AddressVector_capacity(self)
    __swig_destroy__ = _connect.delete_AddressVector
    __del__ = lambda self: None
AddressVector_swigregister = _connect.AddressVector_swigregister
AddressVector_swigregister(AddressVector)

class StrCoverageTestResultsMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrCoverageTestResultsMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrCoverageTestResultsMap, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrCoverageTestResultsMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrCoverageTestResultsMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrCoverageTestResultsMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::size_type":
        return _connect.StrCoverageTestResultsMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::mapped_type const &":
        return _connect.StrCoverageTestResultsMap___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &') -> "void":
        return _connect.StrCoverageTestResultsMap___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &') -> "bool":
        return _connect.StrCoverageTestResultsMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _connect.StrCoverageTestResultsMap_keys(self)

    def values(self) -> "PyObject *":
        return _connect.StrCoverageTestResultsMap_values(self)

    def items(self) -> "PyObject *":
        return _connect.StrCoverageTestResultsMap_items(self)

    def __contains__(self, key: 'std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &') -> "bool":
        return _connect.StrCoverageTestResultsMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrCoverageTestResultsMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrCoverageTestResultsMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _connect.StrCoverageTestResultsMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _connect.StrCoverageTestResultsMap_asdict(self)

    def __init__(self, *args):
        this = _connect.new_StrCoverageTestResultsMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _connect.StrCoverageTestResultsMap_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::size_type":
        return _connect.StrCoverageTestResultsMap_size(self)

    def swap(self, v: 'StrCoverageTestResultsMap') -> "void":
        return _connect.StrCoverageTestResultsMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::reverse_iterator":
        return _connect.StrCoverageTestResultsMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::reverse_iterator":
        return _connect.StrCoverageTestResultsMap_rend(self)

    def clear(self) -> "void":
        return _connect.StrCoverageTestResultsMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::allocator_type":
        return _connect.StrCoverageTestResultsMap_get_allocator(self)

    def count(self, x: 'std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::size_type":
        return _connect.StrCoverageTestResultsMap_count(self, x)

    def erase(self, *args) -> "void":
        return _connect.StrCoverageTestResultsMap_erase(self, *args)

    def find(self, x: 'std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CTestCoverageResult > >::iterator":
        return _connect.StrCoverageTestResultsMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrCoverageTestResultsMap
    __del__ = lambda self: None
StrCoverageTestResultsMap_swigregister = _connect.StrCoverageTestResultsMap_swigregister
StrCoverageTestResultsMap_swigregister(StrCoverageTestResultsMap)

class StrProfilerTestResultsMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrProfilerTestResultsMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StrProfilerTestResultsMap, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrProfilerTestResultsMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.StrProfilerTestResultsMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.StrProfilerTestResultsMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::size_type":
        return _connect.StrProfilerTestResultsMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::mapped_type const &":
        return _connect.StrProfilerTestResultsMap___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &') -> "void":
        return _connect.StrProfilerTestResultsMap___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &') -> "bool":
        return _connect.StrProfilerTestResultsMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _connect.StrProfilerTestResultsMap_keys(self)

    def values(self) -> "PyObject *":
        return _connect.StrProfilerTestResultsMap_values(self)

    def items(self) -> "PyObject *":
        return _connect.StrProfilerTestResultsMap_items(self)

    def __contains__(self, key: 'std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &') -> "bool":
        return _connect.StrProfilerTestResultsMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrProfilerTestResultsMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _connect.StrProfilerTestResultsMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _connect.StrProfilerTestResultsMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _connect.StrProfilerTestResultsMap_asdict(self)

    def __init__(self, *args):
        this = _connect.new_StrProfilerTestResultsMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _connect.StrProfilerTestResultsMap_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::size_type":
        return _connect.StrProfilerTestResultsMap_size(self)

    def swap(self, v: 'StrProfilerTestResultsMap') -> "void":
        return _connect.StrProfilerTestResultsMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::reverse_iterator":
        return _connect.StrProfilerTestResultsMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::reverse_iterator":
        return _connect.StrProfilerTestResultsMap_rend(self)

    def clear(self) -> "void":
        return _connect.StrProfilerTestResultsMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::allocator_type":
        return _connect.StrProfilerTestResultsMap_get_allocator(self)

    def count(self, x: 'std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::size_type":
        return _connect.StrProfilerTestResultsMap_count(self, x)

    def erase(self, *args) -> "void":
        return _connect.StrProfilerTestResultsMap_erase(self, *args)

    def find(self, x: 'std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::key_type const &') -> "std::map< std::string,std::shared_ptr< isys::CProfilerTestResult > >::iterator":
        return _connect.StrProfilerTestResultsMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrProfilerTestResultsMap
    __del__ = lambda self: None
StrProfilerTestResultsMap_swigregister = _connect.StrProfilerTestResultsMap_swigregister
StrProfilerTestResultsMap_swigregister(StrProfilerTestResultsMap)

class TestResultsVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TestResultsVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TestResultsVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.TestResultsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.TestResultsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.TestResultsVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::size_type":
        return _connect.TestResultsVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::shared_ptr< isys::CTestResult > >::difference_type', j: 'std::vector< std::shared_ptr< isys::CTestResult > >::difference_type') -> "std::vector< std::shared_ptr< isys::CTestResult >,std::allocator< std::shared_ptr< isys::CTestResult > > > *":
        return _connect.TestResultsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.TestResultsVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::shared_ptr< isys::CTestResult > >::difference_type', j: 'std::vector< std::shared_ptr< isys::CTestResult > >::difference_type') -> "void":
        return _connect.TestResultsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.TestResultsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &":
        return _connect.TestResultsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.TestResultsVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::value_type":
        return _connect.TestResultsVector_pop(self)

    def append(self, x: 'std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &') -> "void":
        return _connect.TestResultsVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.TestResultsVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::size_type":
        return _connect.TestResultsVector_size(self)

    def swap(self, v: 'TestResultsVector') -> "void":
        return _connect.TestResultsVector_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::iterator":
        return _connect.TestResultsVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::iterator":
        return _connect.TestResultsVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::reverse_iterator":
        return _connect.TestResultsVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::reverse_iterator":
        return _connect.TestResultsVector_rend(self)

    def clear(self) -> "void":
        return _connect.TestResultsVector_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::allocator_type":
        return _connect.TestResultsVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.TestResultsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< isys::CTestResult > >::iterator":
        return _connect.TestResultsVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_TestResultsVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &') -> "void":
        return _connect.TestResultsVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &":
        return _connect.TestResultsVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &":
        return _connect.TestResultsVector_back(self)

    def assign(self, n: 'std::vector< std::shared_ptr< isys::CTestResult > >::size_type', x: 'std::vector< std::shared_ptr< isys::CTestResult > >::value_type const &') -> "void":
        return _connect.TestResultsVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.TestResultsVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.TestResultsVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::shared_ptr< isys::CTestResult > >::size_type') -> "void":
        return _connect.TestResultsVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< isys::CTestResult > >::size_type":
        return _connect.TestResultsVector_capacity(self)
    __swig_destroy__ = _connect.delete_TestResultsVector
    __del__ = lambda self: None
TestResultsVector_swigregister = _connect.TestResultsVector_swigregister
TestResultsVector_swigregister(TestResultsVector)

class TestFilterVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TestFilterVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TestFilterVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.TestFilterVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.TestFilterVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.TestFilterVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::size_type":
        return _connect.TestFilterVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::shared_ptr< isys::CTestFilter > >::difference_type', j: 'std::vector< std::shared_ptr< isys::CTestFilter > >::difference_type') -> "std::vector< std::shared_ptr< isys::CTestFilter >,std::allocator< std::shared_ptr< isys::CTestFilter > > > *":
        return _connect.TestFilterVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.TestFilterVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::shared_ptr< isys::CTestFilter > >::difference_type', j: 'std::vector< std::shared_ptr< isys::CTestFilter > >::difference_type') -> "void":
        return _connect.TestFilterVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.TestFilterVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &":
        return _connect.TestFilterVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.TestFilterVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type":
        return _connect.TestFilterVector_pop(self)

    def append(self, x: 'std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &') -> "void":
        return _connect.TestFilterVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.TestFilterVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::size_type":
        return _connect.TestFilterVector_size(self)

    def swap(self, v: 'TestFilterVector') -> "void":
        return _connect.TestFilterVector_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::iterator":
        return _connect.TestFilterVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::iterator":
        return _connect.TestFilterVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::reverse_iterator":
        return _connect.TestFilterVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::reverse_iterator":
        return _connect.TestFilterVector_rend(self)

    def clear(self) -> "void":
        return _connect.TestFilterVector_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::allocator_type":
        return _connect.TestFilterVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.TestFilterVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::iterator":
        return _connect.TestFilterVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_TestFilterVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &') -> "void":
        return _connect.TestFilterVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &":
        return _connect.TestFilterVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &":
        return _connect.TestFilterVector_back(self)

    def assign(self, n: 'std::vector< std::shared_ptr< isys::CTestFilter > >::size_type', x: 'std::vector< std::shared_ptr< isys::CTestFilter > >::value_type const &') -> "void":
        return _connect.TestFilterVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.TestFilterVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.TestFilterVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::shared_ptr< isys::CTestFilter > >::size_type') -> "void":
        return _connect.TestFilterVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< isys::CTestFilter > >::size_type":
        return _connect.TestFilterVector_capacity(self)
    __swig_destroy__ = _connect.delete_TestFilterVector
    __del__ = lambda self: None
TestFilterVector_swigregister = _connect.TestFilterVector_swigregister
TestFilterVector_swigregister(TestFilterVector)

class DAQSampleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DAQSampleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DAQSampleVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _connect.DAQSampleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _connect.DAQSampleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _connect.DAQSampleVector___bool__(self)

    def __len__(self) -> "std::vector< isys::CDAQSample >::size_type":
        return _connect.DAQSampleVector___len__(self)

    def __getslice__(self, i: 'std::vector< isys::CDAQSample >::difference_type', j: 'std::vector< isys::CDAQSample >::difference_type') -> "std::vector< isys::CDAQSample,std::allocator< isys::CDAQSample > > *":
        return _connect.DAQSampleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _connect.DAQSampleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< isys::CDAQSample >::difference_type', j: 'std::vector< isys::CDAQSample >::difference_type') -> "void":
        return _connect.DAQSampleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _connect.DAQSampleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< isys::CDAQSample >::value_type const &":
        return _connect.DAQSampleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _connect.DAQSampleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< isys::CDAQSample >::value_type":
        return _connect.DAQSampleVector_pop(self)

    def append(self, x: 'CDAQSample') -> "void":
        return _connect.DAQSampleVector_append(self, x)

    def empty(self) -> "bool":
        return _connect.DAQSampleVector_empty(self)

    def size(self) -> "std::vector< isys::CDAQSample >::size_type":
        return _connect.DAQSampleVector_size(self)

    def swap(self, v: 'DAQSampleVector') -> "void":
        return _connect.DAQSampleVector_swap(self, v)

    def begin(self) -> "std::vector< isys::CDAQSample >::iterator":
        return _connect.DAQSampleVector_begin(self)

    def end(self) -> "std::vector< isys::CDAQSample >::iterator":
        return _connect.DAQSampleVector_end(self)

    def rbegin(self) -> "std::vector< isys::CDAQSample >::reverse_iterator":
        return _connect.DAQSampleVector_rbegin(self)

    def rend(self) -> "std::vector< isys::CDAQSample >::reverse_iterator":
        return _connect.DAQSampleVector_rend(self)

    def clear(self) -> "void":
        return _connect.DAQSampleVector_clear(self)

    def get_allocator(self) -> "std::vector< isys::CDAQSample >::allocator_type":
        return _connect.DAQSampleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _connect.DAQSampleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< isys::CDAQSample >::iterator":
        return _connect.DAQSampleVector_erase(self, *args)

    def __init__(self, *args):
        this = _connect.new_DAQSampleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'CDAQSample') -> "void":
        return _connect.DAQSampleVector_push_back(self, x)

    def front(self) -> "std::vector< isys::CDAQSample >::value_type const &":
        return _connect.DAQSampleVector_front(self)

    def back(self) -> "std::vector< isys::CDAQSample >::value_type const &":
        return _connect.DAQSampleVector_back(self)

    def assign(self, n: 'std::vector< isys::CDAQSample >::size_type', x: 'CDAQSample') -> "void":
        return _connect.DAQSampleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _connect.DAQSampleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _connect.DAQSampleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< isys::CDAQSample >::size_type') -> "void":
        return _connect.DAQSampleVector_reserve(self, n)

    def capacity(self) -> "std::vector< isys::CDAQSample >::size_type":
        return _connect.DAQSampleVector_capacity(self)
    __swig_destroy__ = _connect.delete_DAQSampleVector
    __del__ = lambda self: None
DAQSampleVector_swigregister = _connect.DAQSampleVector_swigregister
DAQSampleVector_swigregister(DAQSampleVector)

# This file is compatible with both classic and new-style classes.


