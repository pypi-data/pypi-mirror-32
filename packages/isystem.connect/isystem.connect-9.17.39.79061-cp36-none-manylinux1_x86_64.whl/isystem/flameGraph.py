# This script generates flame graph as SVG image out of profiler XML
# file generated by iSYSTEM winIDEA.
# Script input is profiler XML export with timeline. Prefer binary
# timeline export, since file size is much smaller than XML timeline export.
#
# This script is not be suitable for long recordings. Additionally, interrupt
# routines should be filtered out, since they may appear at any point in
# any stack trace, which makes output image very large and it does not
# present needed information. Use command line option --ignore to specify
# interrupt functions.
#
# To make it easier to estimate trace size, the following are number from one
# of tests:
# Trd file size 258 MB, XML export with indentation file size 4 GB, without
# indentation 3 GB. Binary timeline export 9 MB for XML file with areas
# and statistics, 646 MB for binary timeline file.
# This file had a bit over 28_000_000 timeline events, and before filtering
# interrupt functions it had:
# Number of different stack frames = 2_859_554
# Size of output file with SVG image = 1.3 GB.
# Average stack depth = 76
# Max stack depth = 341
# This script took 16 minutes to process XML file, 7 minutes to process
# file with binary timeline (option --binTimeline).
# Chrome took about 1 hour before reporting rendering error, while FF
# rendered it in about 20 minutes, using about 7 GB of RAM, but responsivnes
# (scrolling) was bad (about a minute to render after scrolling, clicking
# was not detected).
#
# After filtering several interrupt functions:
#
# (c) iSYSTEM Labs d.o.o., 2018

from __future__ import print_function

import sys
import re
import pprint
import webbrowser
import hashlib

import isystem.connect as ic
import isystem.diagutils as diagutils

# list indices
eTime = 0
rTime = 1
netTime = 2
grossTime = 3

g_isDebug = False

GRAPH_WIDTH = 800
TEXT_RIGHT_MARGIN = 200 # space for text (function names) on the right of the graph
TEXT_LEFT_MARGIN = 2
FULL_W = GRAPH_WIDTH + TEXT_RIGHT_MARGIN
RECT_HEIGHT = 20
FONT_SIZE = RECT_HEIGHT
SMALL_BTN_W = 30
SEARCH_BTN_W = 50
RECT_ALL_FUNCTIONS_ID = "rectAllFunctions"
SEARCH_TIME_TXT_ID = 'searchTimeTxt'
SEARCH_COLOR = '00af00'

class ColorMapType:
    FLAME = 'flame'
    GRASS = 'grass'
    WATER = 'water'
    RAINBOW = 'rainbow'
    FLAME_W_INVERSE = 'flameWInverse'

class ColorMapIdxAlgorithm:
    INC = 'inc'
    DEPTH = 'depth'
    CYCLE = 'cycle'
    HASH = 'hash'
    

JAVASCRIPT_CODE = """
    <script type="text/ecmascript">
    <![CDATA[
    var zoomStack = [];
    var zoomIdx = 0;
    var searchTime = 0;
    var searchTimeText;
    var allFunctionsRect, svg;

    function initVars(evt) { 
        allFunctionsRect = document.getElementById('${rectAllFuncsId}');
        searchTimeText = document.getElementById('${searchTimeText}');
        zoomStack.push(allFunctionsRect);
        if (!isBatik(false)) {
            svg = document.getElementsByTagName("svg")[0];
        }
    }


    // Support for javascript in Batik lacks info in DOM,
    // so skip functions to avoid error pop-up dialogs.
    function isBatik(isShowMsg) {
        if (typeof(navigator) == "undefined") {
            if (isShowMsg) {
                searchTimeText.textContent = "Not impl. in testIDEA. Open graph in FF or Chrome.";
            } else {
                searchTimeText.textContent = "";
            }
            return true;
        }

        return false;
    }


    function setOpacity(node, opacity) {
        node.setAttribute('opacity', opacity)
    }


    function mi(node) {   // mouse in
        if (isBatik(false)) return;

        rectNode  = node.children[0];
        rectNode.style["stroke-width"] = '1.5';
        rectNode.style["stroke"] = 'black';
    }
    

    function mo(node) {   // mouse out
        if (isBatik(false)) return;

        rectNode  = node.children[0];
        rectNode.style["stroke-width"] = '0';
    }
    

    function searchDialog() {
        if (isBatik(true)) return;

        var regex = prompt("Find regex:", "");

        if (regex != null) {
            search(regex)
        }
    }


    function search(regex) {

        var re = new RegExp(regex);

        var groups = document.getElementsByTagName("g");
        for(var i = 0; i < groups.length; i++){

            var group = groups[i];

            if (group.attributes['class'] == undefined  ||  group.attributes['class'].value != 'fBox') {
                continue;
            }

            var text = group.children[1].textContent;

            if (text.match(re)) {
                rectAttrs = getRectNodeAttrs(group);
                if (rectAttrs["origFill"] == undefined) {
                    rectAttrs["origFill"] = rectAttrs["fill"].value;
                    searchTime += parseFloat(rectAttrs['timeMs'].value);
                }
                rectAttrs["fill"].value = "#${searchColor}";
            }
        }

        searchTimeText.textContent = " t = " + searchTime;
    }


    function clearSearchResults() {
        if (isBatik(false)) return;

        var groups = document.getElementsByTagName("g");
        searchTime = 0;
        searchTimeText.textContent = "";

        for(var i = 0; i < groups.length; i++){

            var group = groups[i];

            if (group.attributes['class'] == undefined  ||  group.attributes['class'].value != 'fBox') {
                continue;
            }

            rectAttrs = getRectNodeAttrs(group);
            if (rectAttrs["origFill"] != undefined) {
                rectAttrs["fill"].value = rectAttrs["origFill"];
                rectAttrs["origFill"] = undefined;
            }
        }
    }



    // Zooming
    function getRectNodeAttrs(g_node) {
        return g_node.children[0].attributes
    }

    
    function getTxtNodeAttrs(g_node) {
        return g_node.children[1].attributes
    }

    
    function zoomAtNode(g_node) { 
        var clickedAttr = getRectNodeAttrs(g_node);
        var clickedXleft = parseFloat(clickedAttr["xo"].value);
        var clickedWidthOrig = parseFloat(clickedAttr["wo"].value);
        var clickedXright = clickedXleft + clickedWidthOrig;
        var clickedY = parseFloat(clickedAttr["y"].value);
        var scale = (svg.width.baseVal.value - ${textRightMargin}) / clickedWidthOrig;
        var eps = 0.0001;

        var groups = document.getElementsByTagName("g");
        for(var i = 0; i < groups.length; i++){

            var group = groups[i];

            if (group.attributes['class'] == undefined  ||  group.attributes['class'].value != 'fBox') {
                continue;
            }
    
            var curRectAttrs = getRectNodeAttrs(group);
            var curRectXleft = parseFloat(curRectAttrs["xo"].value);
            var curRectWidth = parseFloat(curRectAttrs["wo"].value);
            var curRectXright = curRectWidth + curRectXleft;
            var curRectY = parseFloat(curRectAttrs["y"].value);

            // skip elements out of view (to the left or right of clicke rect.)
            if (curRectXright < (clickedXleft + eps)  ||  curRectXleft > (clickedXright - eps)) {
    
                group.style["display"] = "none";
            } else {
                group.style["display"] = "block";
                curRectAttrs['x'].value = (curRectXleft - clickedXleft) * scale;
                curRectAttrs['width'].value = curRectWidth * scale;

                var txtAttrs = getTxtNodeAttrs(group);
                var txtX = (curRectXleft - clickedXleft) * scale; 
                if (txtX < 0) {   
                    txtX = 0;
                }
                txtAttrs['x'].value = txtX + ${textLeftMargin};
    
                if (curRectY > clickedY) {
                    group.style["opacity"] = "0.5";
                } else {
                    group.style["opacity"] = "1.0";
                }
            }
        }

        // move white rectangles
        var whiteRects = document.getElementsByClassName("wrect");
        for(var i = 0; i < whiteRects.length; i++) {

            var whiteRect = whiteRects[i];

            var curRectAttrs = whiteRect.attributes;
            var curRectXleft = parseFloat(curRectAttrs["xo"].value);
            var curRectWidth = parseFloat(curRectAttrs["wo"].value);
            var curRectXright = curRectWidth + curRectXleft;

            // skip elements out of view (to the left or right of clicke rect.)
            if (curRectXleft < clickedXleft  ||  (curRectXleft - 3) > clickedXright) {
    
                whiteRect.style["display"] = "none";
            } else {
                whiteRect.style["display"] = "block";
                curRectAttrs['x'].value = (curRectXleft - clickedXleft) * scale;
                curRectAttrs['width'].value = curRectWidth * scale;
            }
        }
    }


    function zoom(g_node) {
        if (isBatik(true)) return;

        // remove nodes above current position
        zoomStack.splice(zoomIdx + 1, zoomStack.length);
        zoomStack.push(g_node);
        zoomIdx = zoomStack.length - 1;
        zoomAtNode(g_node);
    }


    function resetZoom(node) {
        if (isBatik(true)) return;

        zoom(allFunctionsRect);
    }    

    
    function previousZoom(node) {
        if (isBatik(true)) return;

        zoomIdx--;
        if (zoomIdx < 0) {
            zoomIdx = 0;
        }

        if (zoomStack.length > 0) {
            zoomAtNode(zoomStack[zoomIdx]);
        } else {
            zoomAtNode(allFunctionsRect);
        }
    }    

    
    function nextZoom(node) {
        if (isBatik(true)) return;

        zoomIdx++;
        if (zoomIdx >= zoomStack.length) {
            zoomIdx = zoomStack.length - 1;
            if (zoomIdx < 0) {
                zoomIdx = 0;
            }
        }

        if (zoomStack.length > 0) {
            zoomAtNode(zoomStack[zoomIdx]);
        } else {
            zoomAtNode(allFunctionsRect);
        }
    }    
    ]]>
    </script>
    \n\n"""

    
def createColorMap(colorMapType, step):

    colorMap = []
    if step < 1:
        step = 1
        
    if step > 100:
        step = 100
    
    if (colorMapType == ColorMapType.FLAME):

        r = 255
        b = 0
        
        for g in range(0, 256, step):
            colorMap.append('{:02x}{:02x}{:02x}'.format(r, g, b))

    elif (colorMapType == ColorMapType.FLAME_W_INVERSE):

        r = 255
        b = 0
        
        for g in range(0, 256, step):
            colorMap.append('{:02x}{:02x}{:02x}'.format(r, g, b))
            
        for g in range(255, 0, -step):
            colorMap.append('{:02x}{:02x}{:02x}'.format(r, g, b))

    elif (colorMapType == ColorMapType.GRASS):
        g = 255
        for rb in range(0, 200, step):  # up to 200 to avoid white color
            colorMap.append('{:02x}{:02x}{:02x}'.format(rb, g, rb))

    elif (colorMapType == ColorMapType.WATER):
        r = 0
        b = 255
        for g in range(0, 256, step):
            colorMap.append('{:02x}{:02x}{:02x}'.format(r, g, b))

    elif (colorMapType == ColorMapType.RAINBOW):
        colorMap = ['00ff00', 'ff0000', '5050ff', 'ff00ff', '00ffff', 'ffff00',
                    '00c000', 'c00000', '5050d0', 'c000c0', '008080', '808000',
                    'ff80ff', '80ffff', 'ffff80', '80ff80', 'ff8080', '8080ff',
                    'ffffff']
    else:
        raise Exception("Invalid color map name: " + str(colorMapType))

    return colorMap


def readAreasAndFuncStats(profilerData):
    """
    Returns map of <areaId, areaName> and <areaName, (netTime, grossTime)>.
    """

    areas = {}
    funcStats = {}
    areaIt = profilerData.getAreaIterator(ic.CProfilerArea2.EFunctions)
    while areaIt.hasNext():
        area = areaIt.next()
        areaName = area.getAreaName()
        areaId = area.getAreaId()
        stats = profilerData.getStatistics(areaId)
        funcStats[areaName] = (stats.getNetTotalTime(), stats.getGrossTotalTime())
        areas[areaId] = areaName

    return areas, funcStats


def readStackFrames(profilerData, ignoredAreaIds):
    """
    Takes profiler timeline as input, creates list of stack frames. Each stack
    frame contains a list of function names. Times are added on the fly
    to minimize memory usage.
    
    Events in profiler XML:
    - E - enter function, provides function start time
    - S - suspend, other function is called
    - R - resume, other function returned
    - X - exit function, provides function end time

    Possible combinations:
    - E -> S, X
    - S -> E
    - R -> S, X
    - X -> E

    Data structure:
    {
     #    key           : value
      ['f1', 'f2', 'f3']: {eTime: 1234, rTime: 1234, netTime: 0, grossTime: 0}
     ...
    }

    On event:
    - 'E': eTime = time, rTime = time
    - 'S': netTime += time - rTime
    - 'R': rTime = time
    - 'X': netTime += time - rTime,  grossTime += time - eTime
    """

    print('Reading timeline events ...')
    frames = {}
    currentStack = []
    timeIter = profilerData.getTimelineIterator()
    idx = 0
    
    while timeIter.hasNext():
        timeEvent = timeIter.next()
        evAreaId = timeEvent.getAreaId()

        idx += 1
        if idx % 100000 == 0:
            print(idx, ' ', end='')
            print(" ", len(currentStack), len(frames), currentStack)
            sys.stdout.flush()

        if evAreaId in ignoredAreaIds:
            continue
            pass

        evType = timeEvent.getEventType()
        evTime = timeEvent.getTime()

        if evType == ic.CProfilerTimeEvent.EEvEnter:
            currentStack.append(evAreaId)
            currentStackTuple = tuple(currentStack)
            frameTimes = frames.setdefault(currentStackTuple, [0, 0, 0, 0])
            frameTimes[eTime] = evTime
            frameTimes[rTime] = evTime
            
        elif evType == ic.CProfilerTimeEvent.EEvSuspend:
            frameTimes = frames.get(currentStackTuple)
            if frameTimes != None:
                if g_isDebug:
                    print('S None at time, areaId = ', evTime, hex(evAreaId))
                frameTimes[netTime] += evTime - frameTimes[rTime]
              
        elif evType == ic.CProfilerTimeEvent.EEvResume:
            frameTimes = frames.get(currentStackTuple)
            if frameTimes != None:
                # it may happen that some functions resume execution during
                # revcording, for example ISRs. Ignore such cases.
                if g_isDebug:
                    print('R None at time, areaId = ', evTime, hex(evAreaId))
                frameTimes[rTime] = evTime
              
        elif evType == ic.CProfilerTimeEvent.EEvExit:
            frameTimes = frames.get(currentStackTuple)
            if frameTimes != None:
                if g_isDebug:
                    print('X None at time, areaId = ', evTime, hex(evAreaId))
                frameTimes[netTime] += evTime - frameTimes[rTime]
                frameTimes[grossTime] += evTime - frameTimes[eTime]
                currentStack.pop()
                currentStackTuple = tuple(currentStack)
        # ignore other event types - eg. we are not interested in mem writes

    print('\nNumber of different stack frames =', len(frames))
    return frames

        
def createDemoStackTrace():
    # This f. is used to create demo image for help, uncomment call below
    return {('f',): [0, 0, 2, 10],
            ('f', 'a'): [0, 0, 1, 3],
            ('f', 'a', 'g'): [0, 0, 2, 2],
            ('f', 'b'): [0, 0, 2, 5],
            ('f', 'b', 'g'): [0, 0, 1, 1],
            ('f', 'b', 'h'): [0, 0, 2, 2],
           }

def replaceIdsWithFuncNames(areas, frames):

    print('Replacing IDs with function names ...')
    framesWFuncNames = {}
    maxStackDepth = 0
    allStackDepths = 0
    minNetTime = 10000000000    # 1e9 ns = 1s

    # this loop deletes items as they are being passed to another mapping,
    # so that we do not duplicate memory usage.
    while frames:
        counter = 0;
        framesToDelete = []

        for frame, frameTimes in frames.items():

            # get some statistics, may be useful to user for limiting
            # graphs with args 'minTime' and 'depth'.
            stackDepth = len(frame)
            allStackDepths += stackDepth
            if stackDepth > maxStackDepth:
                maxStackDepth = stackDepth
                
            if frameTimes[netTime] < minNetTime:
                minNetTime = frameTimes[netTime]
            
            funcNamesList = []
            for funcId in frame:
                funcName = areas.get(funcId)
                # state areas have E and X events, but are not
                # interesting for flamegraph (no stacking)
                # and are therefore not in 'areas'
                if funcName != None: 
                    funcNamesList.append(funcName)

            framesWFuncNames[tuple(funcNamesList)] = frameTimes

            framesToDelete.append(frame)
            counter += 1
            if counter > 1000:
                break;

        for frame in framesToDelete:
            del frames[frame]   # free memory, important for large files

    print('    Average stack depth =', allStackDepths/len(framesWFuncNames))
    print('    Max stack depth =', maxStackDepth)
    print('    Min net time =', minNetTime)
    
    return framesWFuncNames


def getIgnoredAreas(areas, ignoredFunctions):

    ignoredAreaIds = set()
    ifNamesSet = set(ignoredFunctions.split(','))
    
    for areaId, areaName in areas.items():
        if areaName in ifNamesSet:
            ignoredAreaIds.add(areaId)

    return ignoredAreaIds
    
    
def analyzeProfilerXMLForGraph(profilerExportFile, isBinaryTimeline, ignoredFunctions):
    """
    Example of output from this fucntion:
    {('f_L0_a',):                    [49970463, 51313699, 881, 1343982],
     ('f_L0_a', 'f_L1_a'):           [49970535, 51295690, 1817, 1326655],
     ('f_L0_a', 'f_L1_a', 'f_L2_a'): [50864130,
                                      51295436,
                                      3879,
                                      1296654],
     ('f_L0_a', 'f_L1_a', 'f_L2_a', 'funcStubNested'): [51290967,
                                                        51294222,
                                                        4663,
                                                        13636],
    
      Items 0 and 1 in times list may be ignored - they are abs times
      used during processing. Items 3,4 are netTime, grossTime.
    """

    profilerData = ic.CProfilerData2.createInstance(profilerExportFile,
                                                    isBinaryTimeline)

    # always check for parser warnings
    warnings = profilerData.getParserWarnings()
    if warnings:
        print('WARNING(S): ', warnings)

    areas, funcStats = readAreasAndFuncStats(profilerData)
    ignoredAreaIDs = getIgnoredAreas(areas, ignoredFunctions)
    frames = readStackFrames(profilerData, ignoredAreaIDs)

    profilerData.closeParser()  # releases memory and closes XML file

    frames = replaceIdsWithFuncNames(areas, frames)
    # frames = createDemoStackTrace() # uncomment for demo iamge

    if g_isDebug:
        pprint.pprint(frames)

    return frames


def writeHeader(outf, width, height, infoX, infoY, infoFs, titleText):
    #     width="700pt"
    #     height="332pt"
    #      viewBox="0.00 0.00 700 332.00"
    outf.write("""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1"
     baseProfile="full"
         width="{w}"
         height="{h}"
         preserveAspectRatio="none"
         viewBox="0.00 0.00 {w} {h}"
         onload="initVars(evt)" 
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink">
    """.format(w = width, h = height))

    outf.write("""
    <style type="text/css">
        .fBox { font-family: "Arial";}
    </style>
    """)

    jscript = JAVASCRIPT_CODE.replace('${rectAllFuncsId}', RECT_ALL_FUNCTIONS_ID)
    jscript = jscript.replace('${textRightMargin}', str(TEXT_RIGHT_MARGIN))
    jscript = jscript.replace('${textLeftMargin}', str(TEXT_LEFT_MARGIN))
    jscript = jscript.replace('${searchTimeText}', str(SEARCH_TIME_TXT_ID))
    jscript = jscript.replace('${searchColor}', SEARCH_COLOR)

    outf.write(jscript)

    # Buttons for prev/next/reset zoom
    outf.write("""
    <g class = 'zoomBtn' onclick='resetZoom(this)' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xr1}' y='{yr}' rx = '3' width='{w}' height='{h}' fill='#c0c0c0'/>
        <text x='{xt1}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">1:1</text>
        <title>Reset zoom</title>
    </g>
    <g class = 'zoomBtn' onclick='previousZoom(this)' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xr2}' y='{yr}' rx = '3' width='{w}' height='{h}' fill='#c0c0c0'/>
        <text x='{xt2}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">&lt;</text>
        <title>Previous zoom</title>
    </g>
    <g class = 'zoomBtn' onclick='nextZoom(this)' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xr3}' y='{yr}' rx = '3' width='{w}' height='{h}' fill='#c0c0c0'/>
        <text x='{xt3}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">&gt;</text>
        <title>Next zoom</title>
    </g>
    <g class = 'searchBtn' onclick='searchDialog()' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xr4}' y='{yr}' rx = '3' width='{wsearch}' height='{h}' fill='#c0c0c0'/>
        <text x='{xt4}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">Find</text>
        <title>Search functions</title>
    </g>
    <g class = 'searchBtn' onclick='clearSearchResults()' onmousedown='setOpacity(this, 0.6)' onmouseup='setOpacity(this, 1)'>
        <rect x='{xrClr}' y='{yr}' rx = '3' width='{wsearch}' height='{h}' fill='#c0c0c0'/>
        <text x='{xtClr}' y='{yt}' font-size="11" font-family="Verdana"
               fill="rgb(0,0,0)" style="cursor:pointer; text-anchor: middle">Clear</text>
        <title>Clear find results</title>
    </g>
    <g>
        <text x='{xtTime}' y='{yt}' font-size="11" font-family="Verdana" fill="#000000" id="{sTT}"></text>
        <title>Shows sum of gross times of all selected functions.</title>
    </g>
    \n\n""".format(xr1 = 10,
                   xt1 = 10 + SMALL_BTN_W / 2,
                   
                   xr2 = 12 + SMALL_BTN_W,
                   xt2 = 12 + SMALL_BTN_W + SMALL_BTN_W / 2,
                   
                   xr3 = 14 + SMALL_BTN_W * 2,
                   xt3 = 14 + SMALL_BTN_W * 2 + SMALL_BTN_W / 2,
                   
                   xr4 = 22 + SMALL_BTN_W * 3,
                   xt4 = 22 + SMALL_BTN_W * 3 + SEARCH_BTN_W / 2,
                   
                   xrClr = 24 + SMALL_BTN_W * 3 + SEARCH_BTN_W,
                   xtClr = 24 + SMALL_BTN_W * 3 + SEARCH_BTN_W * 3 / 2,
                   
                   xtTime = 28 + SMALL_BTN_W * 3 + SEARCH_BTN_W * 2,
                   
                   yr = 2,
                   yt = RECT_HEIGHT - RECT_HEIGHT / 5, w = SMALL_BTN_W, h = RECT_HEIGHT,
                   wsearch = SEARCH_BTN_W,
                   sTT = SEARCH_TIME_TXT_ID))

    outf.write("""
        <text x='{titleX}' y='{titleY}' font-size="16" font-family="Verdana" fill="#000000" style="font-weight: bold; text-anchor: middle">{titleText}</text>
    \n\n""".format(titleX = width / 2, titleY = 20, titleText = titleText))
    
    
def writeWhiteRect(outf, x, y, w, h):
    outf.write('    <rect class="wrect" x="{x:.5}" xo="{x:.5}" y="{y}" width="{w}" wo = "{w}" height="{h}" fill="#ffffff"/>\n'
               .format(x = x, y = y, w = w, h = h))

               
def writeRect(outf, x, y, w, h, fill, textRect, textFull, timeNs, gid = ''):

    if gid:
        gid = ' id="{}"'.format(gid)
        
    # 'xo' and 'wo' are original values, because 'x' and 'w' get overwritten on
    # zoom operations. For mouse over indication an alternative to functions
    # is css style: .fBox:hover { stroke:black; stroke-width: 1; }
    # but then text is made very bold. If style is applied to rect only, then
    # it is not active when mouse is over text. If style 'pointer-events:none' is
    # specified for text, then it is not selectable and user can not copy it to clipboard.
    outf.write("""    <g class='fBox' onclick="zoom(this)" onmouseover="mi(this)" onmouseout="mo(this)"{gid}>
        <rect x="{x:.7}" xo="{x:.7}" y="{y}" width="{w}" wo="{w}" timeMs='{timeMs}' height="{h}" rx="2" fill="#{fill}"/>
""".format(x = x, y = y, w = w, h = h - RECT_HEIGHT / 10, fill = fill, timeMs = timeNs / 1000, gid = gid))

    outf.write("""        <text x="{x:.7}" y="{y}" font-size="{fs}" fill="black">{txt}</text>
    """.format(x = x + TEXT_LEFT_MARGIN, y = int(y + h*3/4),
               fs = int(h/2), txt = textRect))
    
    outf.write("    <title>{}</title>\n    </g>\n\n".format(textFull))


def writeEnd(outf, width, height):
    # image frame
    outf.write("""<rect x ='0' y = '0' width = '{}' height = '{}' fill-opacity='0.0' style='stroke: #808080; pointer-events:none'/>
    \n\n""".format(width, height))

    outf.write('</svg>')
    

def getHashColorIdx(funcName, colorMapSize):
    return int(hashlib.md5(funcName.encode('UTF-8')).hexdigest()[:8], 16) % colorMapSize


def getColorIdx(funcName, colorIdx, colorMap, stackDepth, maxStackDepth,
                algorithm):

    if algorithm == ColorMapIdxAlgorithm.INC:
        # Next rectangle gets next color from map. Color is not related
        # to depth level.
        colorIdx += 1
        if colorIdx >= len(colorMap):
            colorIdx = 0
            
    elif algorithm == ColorMapIdxAlgorithm.DEPTH:
        # Color is related to stack depth level - greater depth, greater color
        # index.
        colorIdx = int((len(colorMap) - 1) / maxStackDepth * stackDepth)

    elif algorithm == ColorMapIdxAlgorithm.CYCLE:
        # Color is related to stack depth level, but colors are cycled.
        colorIdx = (stackDepth - 1) % len(colorMap)
    elif algorithm == ColorMapIdxAlgorithm.HASH:
        # Color is related function name hash value.
        colorIdx = getHashColorIdx(funcName, len(colorMap))
    else:
        raise Exception('Unknown color map index algorithm: ' + str(algorithm))
    
    return colorIdx


def getRectColor(regex, funcName, colorIdx, colorMap, stackDepth, maxStackDepth,
                 colorMapIdxAlg):

    # Always calculate color index, so that it is updated also if regex
    # matches. This way colors do not shift in case of matches.
    colorIdx = getColorIdx(funcName, colorIdx, colorMap, stackDepth,
                               maxStackDepth, colorMapIdxAlg)
    
    if regex  and  regex.match(funcName):
        rectColor = SEARCH_COLOR
    else:
        rectColor = colorMap[colorIdx]

    return rectColor, colorIdx


def getTotalTime(flameData):

    totalTime = 0;
    for key in flameData:
        if len(key) == 1:
            totalTime += flameData[key][grossTime]
            
    return totalTime


def getDesc(funcName, frameTimes):
    return "{} ({} us / {} us, {:.4}%)".format(funcName,
                                            frameTimes[netTime] / 1000,
                                            frameTimes[grossTime] / 1000,
                                                frameTimes[netTime] / frameTimes[grossTime] * 100)


def isWriteWhiteRect(keyIdx, sortedKeys):
    # if this is the last column, or next stack frame (column) is shorter than
    # the current one, or this is the last rectangle in a row,
    # then draw white rect to delete long function names from previous columns.
    # This way the current function name will be visible even if it is
    # longer than rectangle, and will not overlap with previous functions.

    key = sortedKeys[keyIdx]
    isLastStackFrame = (keyIdx + 1) == len(sortedKeys)
    isNextFrameShorter = False
    if not isLastStackFrame:
        nextKey = sortedKeys[keyIdx + 1]
        if len(nextKey) < len(key):
            isNextFrameShorter = True

    lastStackFrame = sortedKeys[-1]
    isLastRectangleInRow = len(lastStackFrame) >= len(key)  and  key[-1] == lastStackFrame[len(key) - 1]

    return isLastStackFrame  or  isNextFrameShorter  or isLastRectangleInRow
    

def flameDataToSVG(flameData, opts):

    print('Writing svg file ...')

    minTime = float(opts.minTime)
    stackDepthLimit = int(opts.depth)
    totalTimeNs = getTotalTime(flameData)
    sortedKeys = sorted(flameData)
    maxStackDepth = 0
    for key in sortedKeys:
        maxStackDepth = max(maxStackDepth, len(key))

    maxStackDepth = min(stackDepthLimit, maxStackDepth)
    imageHeight = RECT_HEIGHT * (maxStackDepth + 3)
    timeScale = GRAPH_WIDTH / totalTimeNs
    regex = re.compile(opts.findRegEx) if opts.findRegEx else None

    with open(opts.outFileName, 'wt') as outf:

        writeHeader(outf, FULL_W, imageHeight,
                    TEXT_LEFT_MARGIN, imageHeight - RECT_HEIGHT / 5, int(RECT_HEIGHT*2/3),
                    opts.titleText)

        x = 0.0
        colorIdx = -1  # means not initialized
        colorMap = createColorMap(opts.colorMap, int(opts.colorMapStep))

        if g_isDebug:
            pprint.pprint(colorMap)

        # add rectangle covering all stack frames - contains full time and is 
        # used in zooming functionality
        baseDesc = 'all ({}us)'.format(totalTimeNs / 1000)
        writeRect(outf, x, imageHeight - RECT_HEIGHT, GRAPH_WIDTH, RECT_HEIGHT,
                  'ffffff', baseDesc, baseDesc, totalTimeNs, RECT_ALL_FUNCTIONS_ID)
                  
            
        keyIdx = 0;
        for key in sortedKeys:
            
            frameTime = flameData[key]
            stackDepth = len(key)
            
            if stackDepth > 0 and stackDepth <= stackDepthLimit and frameTime[grossTime] > minTime:

                funcName = key[stackDepth - 1]
                rectColor, colorIdx = getRectColor(regex, funcName, colorIdx, 
                                           colorMap, stackDepth, maxStackDepth,
                                           opts.colorMapIdxAlg)

                if isWriteWhiteRect(keyIdx, sortedKeys):
                    writeWhiteRect(outf,
                                   x = x * timeScale,
                                   y = imageHeight - (stackDepth + 1) * RECT_HEIGHT - 1, 
                                   w = FULL_W - x * timeScale,
                                   h = RECT_HEIGHT)

                writeRect(outf,
                          x = x * timeScale,
                          y = imageHeight - (stackDepth + 1) * RECT_HEIGHT, 
                          w = frameTime[grossTime] * timeScale,
                          h = RECT_HEIGHT, 
                          fill = rectColor,
                          textRect = "{} ({}us)".format(key[stackDepth - 1], frameTime[grossTime]/1000),
                          textFull = getDesc(funcName, frameTime),
                          timeNs = frameTime[grossTime])

            x += frameTime[netTime]
            keyIdx += 1
        
        writeEnd(outf, FULL_W, imageHeight)


def printStacks(flameData):

    sortedKeys = sorted(flameData)

    for key in sortedKeys:
        times = flameData[key]
        print(key, ", ", times[netTime], ", ", times[grossTime], sep='')

              
def parseArgs(cmdLineArgs):
    opts = diagutils.parseArgs(cmdLineArgs,
        [('-d',
          '--depth',
          'depth',
          1000000000,
          'defines max number of calls on call stack to be shown.'),

         ('-m',
          '--colorMap',
          'colorMap',
          'flame',
          'defines color map: flame, flameWInverse, water, grass, rainbow.'),

         ('-s',
          '--colorMapStep',
          'colorMapStep',
          50,
          'defines how fast colors in color map change. Should be in range 1..100.'),

         ('-a',
          '--colorMapIdxAlg',
          'colorMapIdxAlg',
          'inc',
          'defines algorithm for color map index: inc, depth, cycle, map.\n' +
          "'inc' - color map index is incremented for next function. " +
          "'depth' - color index increases with stack depth. " +
          "'cycle' - color index increments with stack depth, if there are less " +
                    "colors than stack depth it starts again from 0. " +
          "'hash' - color index is calculated from function hash."),

         ('-t',
          '--title',
          'titleText',
          '',
          'defines graph title.'),

         ('-p',
          '--printStacks',
          'isPrintStacks',
          False,
          'if specified, stack frames with net and gross times are printed to stdout.'),

         ('-n',
          '--mint',
          'minTime',
          '0',
          'if specified, then all frames shorter than this time are not shown.'),

         ('-o',
          '--open',
          'isOpenInSystemViewer',
          False,
          'if present, then generated diagram is opened in OS default viwer.'),
         
         ('-f',
          '--find',
          'findRegEx',
          '',
          'functions which names match regex will be shown in green color. ' +
          'Regular expression does not need to match complete function name, but ' +
          "only start of it. For example, 'max' will match both 'maxInt' and 'maxFloat'. " +
          "Use '$' to match complete func. name, eg. 'max$'. " +
          "Use operator '|' to match more than one function, eg. 'max|min'. " +
          "Use '.*' to match string in the middle, eg. '.*Color' will match both " +
          "'getColor' and 'setColor'."),

         ('-i',
          '--ignore',
          'ignoredFunctions',
          '',
          'if specified, then the list of given comma-separated function names is used to ' +
          'ignore timeline events for these functions. Use this option to exclude ' +
          'interrupt functions, because they corrupt stack traces. Do not use spaces ' +
          'in the list. Example: -i adcISR,canISR'),
        ])
    
    if not opts.profExport:
        raise Exception("Profiler XML export file name missing in command line aruments ('--profExport')!")
        
    return opts;


def main(cmdLineArgs):
    opts = parseArgs(cmdLineArgs)

    flameData = analyzeProfilerXMLForGraph(opts.profExport,
                                           opts.isBinaryTimeline,
                                           opts.ignoredFunctions)
    if opts.isPrintStacks:
        printStacks(flameData)

    flameDataToSVG(flameData, opts)
    
    if opts.isOpenInSystemViewer:
        webbrowser.open_new_tab(opts.outFileName)

    print('    Done!')
    

if __name__ == '__main__':
    main(sys.argv[1:])
