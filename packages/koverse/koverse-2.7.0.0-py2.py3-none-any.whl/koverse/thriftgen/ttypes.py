#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TValueType:
  STRING = 1
  LONG = 2
  DOUBLE = 3
  DATE = 4
  URL = 5
  IPADDRESS = 6
  GEO = 7
  LIST = 8
  MAP = 9
  BYTES = 10
  BOOLEAN = 11

  _VALUES_TO_NAMES = {
    1: "STRING",
    2: "LONG",
    3: "DOUBLE",
    4: "DATE",
    5: "URL",
    6: "IPADDRESS",
    7: "GEO",
    8: "LIST",
    9: "MAP",
    10: "BYTES",
    11: "BOOLEAN",
  }

  _NAMES_TO_VALUES = {
    "STRING": 1,
    "LONG": 2,
    "DOUBLE": 3,
    "DATE": 4,
    "URL": 5,
    "IPADDRESS": 6,
    "GEO": 7,
    "LIST": 8,
    "MAP": 9,
    "BYTES": 10,
    "BOOLEAN": 11,
  }

class TConfigValueType:
  STRING = 0
  DOUBLE = 1
  LONG = 2
  STRING_LIST = 3
  DOUBLE_LIST = 4
  LONG_LIST = 5
  BOOLEAN = 6
  BOOLEAN_LIST = 7

  _VALUES_TO_NAMES = {
    0: "STRING",
    1: "DOUBLE",
    2: "LONG",
    3: "STRING_LIST",
    4: "DOUBLE_LIST",
    5: "LONG_LIST",
    6: "BOOLEAN",
    7: "BOOLEAN_LIST",
  }

  _NAMES_TO_VALUES = {
    "STRING": 0,
    "DOUBLE": 1,
    "LONG": 2,
    "STRING_LIST": 3,
    "DOUBLE_LIST": 4,
    "LONG_LIST": 5,
    "BOOLEAN": 6,
    "BOOLEAN_LIST": 7,
  }

class TScheduleRepeatUnit:
  Hourly = 1
  Daily = 2
  Weekly = 3
  Monthly = 4
  Cron = 5

  _VALUES_TO_NAMES = {
    1: "Hourly",
    2: "Daily",
    3: "Weekly",
    4: "Monthly",
    5: "Cron",
  }

  _NAMES_TO_VALUES = {
    "Hourly": 1,
    "Daily": 2,
    "Weekly": 3,
    "Monthly": 4,
    "Cron": 5,
  }

class TScheduleEndingType:
  Never = 1
  Date = 2
  Count = 3

  _VALUES_TO_NAMES = {
    1: "Never",
    2: "Date",
    3: "Count",
  }

  _NAMES_TO_VALUES = {
    "Never": 1,
    "Date": 2,
    "Count": 3,
  }


class TParameter:
  """
  Attributes:
   - parameterId
   - displayName
   - parameterName
   - parameterType
   - enumerations
   - defaultValue
   - requiredParameter
   - hint
   - referenceParameterNames
   - hideInput
   - javascriptClassName
   - parameterGroup
   - position
   - placeholder
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'parameterId', None, None, ), # 1
    (2, TType.STRING, 'displayName', None, None, ), # 2
    (3, TType.STRING, 'parameterName', None, None, ), # 3
    (4, TType.STRING, 'parameterType', None, None, ), # 4
    (5, TType.LIST, 'enumerations', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'defaultValue', None, None, ), # 6
    (7, TType.BOOL, 'requiredParameter', None, None, ), # 7
    (8, TType.STRING, 'hint', None, None, ), # 8
    (9, TType.STRING, 'referenceParameterNames', None, None, ), # 9
    (10, TType.BOOL, 'hideInput', None, None, ), # 10
    (11, TType.STRING, 'javascriptClassName', None, None, ), # 11
    (12, TType.STRING, 'parameterGroup', None, None, ), # 12
    (13, TType.I32, 'position', None, None, ), # 13
    (14, TType.STRING, 'placeholder', None, None, ), # 14
  )

  def __init__(self, parameterId=None, displayName=None, parameterName=None, parameterType=None, enumerations=None, defaultValue=None, requiredParameter=None, hint=None, referenceParameterNames=None, hideInput=None, javascriptClassName=None, parameterGroup=None, position=None, placeholder=None,):
    self.parameterId = parameterId
    self.displayName = displayName
    self.parameterName = parameterName
    self.parameterType = parameterType
    self.enumerations = enumerations
    self.defaultValue = defaultValue
    self.requiredParameter = requiredParameter
    self.hint = hint
    self.referenceParameterNames = referenceParameterNames
    self.hideInput = hideInput
    self.javascriptClassName = javascriptClassName
    self.parameterGroup = parameterGroup
    self.position = position
    self.placeholder = placeholder

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.parameterId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.displayName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.parameterName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.parameterType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.enumerations = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString()
            self.enumerations.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.defaultValue = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.requiredParameter = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.hint = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.referenceParameterNames = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.hideInput = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.javascriptClassName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.parameterGroup = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.position = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.placeholder = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TParameter')
    if self.parameterId is not None:
      oprot.writeFieldBegin('parameterId', TType.I64, 1)
      oprot.writeI64(self.parameterId)
      oprot.writeFieldEnd()
    if self.displayName is not None:
      oprot.writeFieldBegin('displayName', TType.STRING, 2)
      oprot.writeString(self.displayName)
      oprot.writeFieldEnd()
    if self.parameterName is not None:
      oprot.writeFieldBegin('parameterName', TType.STRING, 3)
      oprot.writeString(self.parameterName)
      oprot.writeFieldEnd()
    if self.parameterType is not None:
      oprot.writeFieldBegin('parameterType', TType.STRING, 4)
      oprot.writeString(self.parameterType)
      oprot.writeFieldEnd()
    if self.enumerations is not None:
      oprot.writeFieldBegin('enumerations', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.enumerations))
      for iter6 in self.enumerations:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.defaultValue is not None:
      oprot.writeFieldBegin('defaultValue', TType.STRING, 6)
      oprot.writeString(self.defaultValue)
      oprot.writeFieldEnd()
    if self.requiredParameter is not None:
      oprot.writeFieldBegin('requiredParameter', TType.BOOL, 7)
      oprot.writeBool(self.requiredParameter)
      oprot.writeFieldEnd()
    if self.hint is not None:
      oprot.writeFieldBegin('hint', TType.STRING, 8)
      oprot.writeString(self.hint)
      oprot.writeFieldEnd()
    if self.referenceParameterNames is not None:
      oprot.writeFieldBegin('referenceParameterNames', TType.STRING, 9)
      oprot.writeString(self.referenceParameterNames)
      oprot.writeFieldEnd()
    if self.hideInput is not None:
      oprot.writeFieldBegin('hideInput', TType.BOOL, 10)
      oprot.writeBool(self.hideInput)
      oprot.writeFieldEnd()
    if self.javascriptClassName is not None:
      oprot.writeFieldBegin('javascriptClassName', TType.STRING, 11)
      oprot.writeString(self.javascriptClassName)
      oprot.writeFieldEnd()
    if self.parameterGroup is not None:
      oprot.writeFieldBegin('parameterGroup', TType.STRING, 12)
      oprot.writeString(self.parameterGroup)
      oprot.writeFieldEnd()
    if self.position is not None:
      oprot.writeFieldBegin('position', TType.I32, 13)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    if self.placeholder is not None:
      oprot.writeFieldBegin('placeholder', TType.STRING, 14)
      oprot.writeString(self.placeholder)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.parameterId)
    value = (value * 31) ^ hash(self.displayName)
    value = (value * 31) ^ hash(self.parameterName)
    value = (value * 31) ^ hash(self.parameterType)
    value = (value * 31) ^ hash(self.enumerations)
    value = (value * 31) ^ hash(self.defaultValue)
    value = (value * 31) ^ hash(self.requiredParameter)
    value = (value * 31) ^ hash(self.hint)
    value = (value * 31) ^ hash(self.referenceParameterNames)
    value = (value * 31) ^ hash(self.hideInput)
    value = (value * 31) ^ hash(self.javascriptClassName)
    value = (value * 31) ^ hash(self.parameterGroup)
    value = (value * 31) ^ hash(self.position)
    value = (value * 31) ^ hash(self.placeholder)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TValue:
  """
  Attributes:
   - type
   - longValue
   - doubleValue
   - stringValue
   - geoValue
   - listValue
   - mapValue
   - bytesValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I64, 'longValue', None, None, ), # 2
    (3, TType.DOUBLE, 'doubleValue', None, None, ), # 3
    (4, TType.STRING, 'stringValue', None, None, ), # 4
    (5, TType.LIST, 'geoValue', (TType.DOUBLE,None), None, ), # 5
    (6, TType.LIST, 'listValue', (TType.I32,None), None, ), # 6
    (7, TType.MAP, 'mapValue', (TType.STRING,None,TType.I32,None), None, ), # 7
    (8, TType.STRING, 'bytesValue', None, None, ), # 8
  )

  def __init__(self, type=None, longValue=None, doubleValue=None, stringValue=None, geoValue=None, listValue=None, mapValue=None, bytesValue=None,):
    self.type = type
    self.longValue = longValue
    self.doubleValue = doubleValue
    self.stringValue = stringValue
    self.geoValue = geoValue
    self.listValue = listValue
    self.mapValue = mapValue
    self.bytesValue = bytesValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.longValue = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.doubleValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.geoValue = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readDouble()
            self.geoValue.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.listValue = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = iprot.readI32()
            self.listValue.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.mapValue = {}
          (_ktype20, _vtype21, _size19 ) = iprot.readMapBegin()
          for _i23 in xrange(_size19):
            _key24 = iprot.readString()
            _val25 = iprot.readI32()
            self.mapValue[_key24] = _val25
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.bytesValue = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TValue')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.longValue is not None:
      oprot.writeFieldBegin('longValue', TType.I64, 2)
      oprot.writeI64(self.longValue)
      oprot.writeFieldEnd()
    if self.doubleValue is not None:
      oprot.writeFieldBegin('doubleValue', TType.DOUBLE, 3)
      oprot.writeDouble(self.doubleValue)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 4)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.geoValue is not None:
      oprot.writeFieldBegin('geoValue', TType.LIST, 5)
      oprot.writeListBegin(TType.DOUBLE, len(self.geoValue))
      for iter26 in self.geoValue:
        oprot.writeDouble(iter26)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.listValue is not None:
      oprot.writeFieldBegin('listValue', TType.LIST, 6)
      oprot.writeListBegin(TType.I32, len(self.listValue))
      for iter27 in self.listValue:
        oprot.writeI32(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mapValue is not None:
      oprot.writeFieldBegin('mapValue', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.mapValue))
      for kiter28,viter29 in self.mapValue.items():
        oprot.writeString(kiter28)
        oprot.writeI32(viter29)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.bytesValue is not None:
      oprot.writeFieldBegin('bytesValue', TType.STRING, 8)
      oprot.writeString(self.bytesValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.longValue)
    value = (value * 31) ^ hash(self.doubleValue)
    value = (value * 31) ^ hash(self.stringValue)
    value = (value * 31) ^ hash(self.geoValue)
    value = (value * 31) ^ hash(self.listValue)
    value = (value * 31) ^ hash(self.mapValue)
    value = (value * 31) ^ hash(self.bytesValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TConfigValue:
  """
  Attributes:
   - type
   - stringValue
   - doubleValue
   - longValue
   - stringList
   - doubleList
   - longList
   - booleanValue
   - booleanList
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRING, 'stringValue', None, None, ), # 2
    (3, TType.DOUBLE, 'doubleValue', None, None, ), # 3
    (4, TType.I64, 'longValue', None, None, ), # 4
    (5, TType.LIST, 'stringList', (TType.STRING,None), None, ), # 5
    (6, TType.LIST, 'doubleList', (TType.DOUBLE,None), None, ), # 6
    (7, TType.LIST, 'longList', (TType.I64,None), None, ), # 7
    (8, TType.BOOL, 'booleanValue', None, None, ), # 8
    (9, TType.LIST, 'booleanList', (TType.BOOL,None), None, ), # 9
  )

  def __init__(self, type=None, stringValue=None, doubleValue=None, longValue=None, stringList=None, doubleList=None, longList=None, booleanValue=None, booleanList=None,):
    self.type = type
    self.stringValue = stringValue
    self.doubleValue = doubleValue
    self.longValue = longValue
    self.stringList = stringList
    self.doubleList = doubleList
    self.longList = longList
    self.booleanValue = booleanValue
    self.booleanList = booleanList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.doubleValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.longValue = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.stringList = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readString()
            self.stringList.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.doubleList = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readDouble()
            self.doubleList.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.longList = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readI64()
            self.longList.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.booleanValue = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.booleanList = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = iprot.readBool()
            self.booleanList.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TConfigValue')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 2)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.doubleValue is not None:
      oprot.writeFieldBegin('doubleValue', TType.DOUBLE, 3)
      oprot.writeDouble(self.doubleValue)
      oprot.writeFieldEnd()
    if self.longValue is not None:
      oprot.writeFieldBegin('longValue', TType.I64, 4)
      oprot.writeI64(self.longValue)
      oprot.writeFieldEnd()
    if self.stringList is not None:
      oprot.writeFieldBegin('stringList', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.stringList))
      for iter54 in self.stringList:
        oprot.writeString(iter54)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.doubleList is not None:
      oprot.writeFieldBegin('doubleList', TType.LIST, 6)
      oprot.writeListBegin(TType.DOUBLE, len(self.doubleList))
      for iter55 in self.doubleList:
        oprot.writeDouble(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.longList is not None:
      oprot.writeFieldBegin('longList', TType.LIST, 7)
      oprot.writeListBegin(TType.I64, len(self.longList))
      for iter56 in self.longList:
        oprot.writeI64(iter56)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.booleanValue is not None:
      oprot.writeFieldBegin('booleanValue', TType.BOOL, 8)
      oprot.writeBool(self.booleanValue)
      oprot.writeFieldEnd()
    if self.booleanList is not None:
      oprot.writeFieldBegin('booleanList', TType.LIST, 9)
      oprot.writeListBegin(TType.BOOL, len(self.booleanList))
      for iter57 in self.booleanList:
        oprot.writeBool(iter57)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.stringValue)
    value = (value * 31) ^ hash(self.doubleValue)
    value = (value * 31) ^ hash(self.longValue)
    value = (value * 31) ^ hash(self.stringList)
    value = (value * 31) ^ hash(self.doubleList)
    value = (value * 31) ^ hash(self.longList)
    value = (value * 31) ^ hash(self.booleanValue)
    value = (value * 31) ^ hash(self.booleanList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSimpleRecord:
  """
  Attributes:
   - allValues
   - collectionId
   - securityLabel
   - recordId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'allValues', (TType.STRUCT,(TValue, TValue.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.STRING, 'securityLabel', None, None, ), # 3
    (4, TType.STRING, 'recordId', None, None, ), # 4
  )

  def __init__(self, allValues=None, collectionId=None, securityLabel=None, recordId=None,):
    self.allValues = allValues
    self.collectionId = collectionId
    self.securityLabel = securityLabel
    self.recordId = recordId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.allValues = []
          (_etype61, _size58) = iprot.readListBegin()
          for _i62 in xrange(_size58):
            _elem63 = TValue()
            _elem63.read(iprot)
            self.allValues.append(_elem63)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.securityLabel = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.recordId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSimpleRecord')
    if self.allValues is not None:
      oprot.writeFieldBegin('allValues', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.allValues))
      for iter64 in self.allValues:
        iter64.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.securityLabel is not None:
      oprot.writeFieldBegin('securityLabel', TType.STRING, 3)
      oprot.writeString(self.securityLabel)
      oprot.writeFieldEnd()
    if self.recordId is not None:
      oprot.writeFieldBegin('recordId', TType.STRING, 4)
      oprot.writeString(self.recordId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.allValues)
    value = (value * 31) ^ hash(self.collectionId)
    value = (value * 31) ^ hash(self.securityLabel)
    value = (value * 31) ^ hash(self.recordId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFieldList:
  """
  Attributes:
   - collectionId
   - fields
   - fieldsToKeep
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'collectionId', None, None, ), # 1
    (2, TType.MAP, 'fields', (TType.STRING,None,TType.STRUCT,(TValue, TValue.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'fieldsToKeep', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, collectionId=None, fields=None, fieldsToKeep=None,):
    self.collectionId = collectionId
    self.fields = fields
    self.fieldsToKeep = fieldsToKeep

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.fields = {}
          (_ktype66, _vtype67, _size65 ) = iprot.readMapBegin()
          for _i69 in xrange(_size65):
            _key70 = iprot.readString()
            _val71 = TValue()
            _val71.read(iprot)
            self.fields[_key70] = _val71
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fieldsToKeep = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = iprot.readString()
            self.fieldsToKeep.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFieldList')
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 1)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.fields))
      for kiter78,viter79 in self.fields.items():
        oprot.writeString(kiter78)
        viter79.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.fieldsToKeep is not None:
      oprot.writeFieldBegin('fieldsToKeep', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.fieldsToKeep))
      for iter80 in self.fieldsToKeep:
        oprot.writeString(iter80)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.collectionId)
    value = (value * 31) ^ hash(self.fields)
    value = (value * 31) ^ hash(self.fieldsToKeep)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TLabel:
  """
  Attributes:
   - id
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, id=None, name=None,):
    self.id = id
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TLabel')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDownloadRecords:
  """
  Attributes:
   - downloadId
   - hasMore
   - records
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'downloadId', None, None, ), # 1
    (2, TType.BOOL, 'hasMore', None, None, ), # 2
    (3, TType.LIST, 'records', (TType.STRUCT,(TSimpleRecord, TSimpleRecord.thrift_spec)), None, ), # 3
  )

  def __init__(self, downloadId=None, hasMore=None, records=None,):
    self.downloadId = downloadId
    self.hasMore = hasMore
    self.records = records

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.hasMore = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype84, _size81) = iprot.readListBegin()
          for _i85 in xrange(_size81):
            _elem86 = TSimpleRecord()
            _elem86.read(iprot)
            self.records.append(_elem86)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDownloadRecords')
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 1)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    if self.hasMore is not None:
      oprot.writeFieldBegin('hasMore', TType.BOOL, 2)
      oprot.writeBool(self.hasMore)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.records))
      for iter87 in self.records:
        iter87.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.downloadId)
    value = (value * 31) ^ hash(self.hasMore)
    value = (value * 31) ^ hash(self.records)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSchedule:
  """
  Attributes:
   - id
   - lastExecutedOnMs
   - startsOnMs
   - endsOnMs
   - endsAfter
   - executionCount
   - repeatInterval
   - repeatUnit
   - endingType
   - cron
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I64, 'lastExecutedOnMs', None, None, ), # 2
    (3, TType.I64, 'startsOnMs', None, None, ), # 3
    (4, TType.I64, 'endsOnMs', None, None, ), # 4
    (5, TType.I64, 'endsAfter', None, None, ), # 5
    (6, TType.I64, 'executionCount', None, None, ), # 6
    (7, TType.I64, 'repeatInterval', None, None, ), # 7
    (8, TType.I32, 'repeatUnit', None, None, ), # 8
    (9, TType.I32, 'endingType', None, None, ), # 9
    None, # 10
    (11, TType.STRING, 'cron', None, None, ), # 11
  )

  def __init__(self, id=None, lastExecutedOnMs=None, startsOnMs=None, endsOnMs=None, endsAfter=None, executionCount=None, repeatInterval=None, repeatUnit=None, endingType=None, cron=None,):
    self.id = id
    self.lastExecutedOnMs = lastExecutedOnMs
    self.startsOnMs = startsOnMs
    self.endsOnMs = endsOnMs
    self.endsAfter = endsAfter
    self.executionCount = executionCount
    self.repeatInterval = repeatInterval
    self.repeatUnit = repeatUnit
    self.endingType = endingType
    self.cron = cron

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.lastExecutedOnMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.startsOnMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.endsOnMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.endsAfter = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.executionCount = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.repeatInterval = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.repeatUnit = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.endingType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.cron = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSchedule')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.lastExecutedOnMs is not None:
      oprot.writeFieldBegin('lastExecutedOnMs', TType.I64, 2)
      oprot.writeI64(self.lastExecutedOnMs)
      oprot.writeFieldEnd()
    if self.startsOnMs is not None:
      oprot.writeFieldBegin('startsOnMs', TType.I64, 3)
      oprot.writeI64(self.startsOnMs)
      oprot.writeFieldEnd()
    if self.endsOnMs is not None:
      oprot.writeFieldBegin('endsOnMs', TType.I64, 4)
      oprot.writeI64(self.endsOnMs)
      oprot.writeFieldEnd()
    if self.endsAfter is not None:
      oprot.writeFieldBegin('endsAfter', TType.I64, 5)
      oprot.writeI64(self.endsAfter)
      oprot.writeFieldEnd()
    if self.executionCount is not None:
      oprot.writeFieldBegin('executionCount', TType.I64, 6)
      oprot.writeI64(self.executionCount)
      oprot.writeFieldEnd()
    if self.repeatInterval is not None:
      oprot.writeFieldBegin('repeatInterval', TType.I64, 7)
      oprot.writeI64(self.repeatInterval)
      oprot.writeFieldEnd()
    if self.repeatUnit is not None:
      oprot.writeFieldBegin('repeatUnit', TType.I32, 8)
      oprot.writeI32(self.repeatUnit)
      oprot.writeFieldEnd()
    if self.endingType is not None:
      oprot.writeFieldBegin('endingType', TType.I32, 9)
      oprot.writeI32(self.endingType)
      oprot.writeFieldEnd()
    if self.cron is not None:
      oprot.writeFieldBegin('cron', TType.STRING, 11)
      oprot.writeString(self.cron)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.lastExecutedOnMs)
    value = (value * 31) ^ hash(self.startsOnMs)
    value = (value * 31) ^ hash(self.endsOnMs)
    value = (value * 31) ^ hash(self.endsAfter)
    value = (value * 31) ^ hash(self.executionCount)
    value = (value * 31) ^ hash(self.repeatInterval)
    value = (value * 31) ^ hash(self.repeatUnit)
    value = (value * 31) ^ hash(self.endingType)
    value = (value * 31) ^ hash(self.cron)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TKoverseException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TKoverseException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TNotFoundException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TNotFoundException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
