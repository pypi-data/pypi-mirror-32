#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def getCollectionById(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getCollectionByIdNotDeleted(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getCollectionByName(self, auth, collectionName):
    """
    Parameters:
     - auth
     - collectionName
    """
    pass

  def listCollections(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def createCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    pass

  def updateCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    pass

  def deleteCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    pass

  def clearCollection(self, auth, collectionId, removeFieldNamesSeen):
    """
    Parameters:
     - auth
     - collectionId
     - removeFieldNamesSeen
    """
    pass

  def repair(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getCollectionSample(self, auth, collectionId, maxRecords, removeByteArrayFieldValues, maxStringValueLength):
    """
    Parameters:
     - auth
     - collectionId
     - maxRecords
     - removeByteArrayFieldValues
     - maxStringValueLength
    """
    pass

  def startDownloadRecords(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def downloadMoreRecords(self, auth, downloadId, maxToReturn):
    """
    Parameters:
     - auth
     - downloadId
     - maxToReturn
    """
    pass

  def stopDownloadRecords(self, auth, downloadId):
    """
    Parameters:
     - auth
     - downloadId
    """
    pass

  def startDownloadSamples(self, auth, collectionId, removeByteArrayFieldValues):
    """
    Parameters:
     - auth
     - collectionId
     - removeByteArrayFieldValues
    """
    pass

  def downloadMoreSamples(self, auth, downloadId, maxToReturn):
    """
    Parameters:
     - auth
     - downloadId
     - maxToReturn
    """
    pass

  def stopDownloadSamples(self, auth, downloadId):
    """
    Parameters:
     - auth
     - downloadId
    """
    pass

  def createAggregate(self, auth, aggregate):
    """
    Parameters:
     - auth
     - aggregate
    """
    pass

  def deleteAggregate(self, auth, collectionId, id):
    """
    Parameters:
     - auth
     - collectionId
     - id
    """
    pass

  def getAggregate(self, auth, id):
    """
    Parameters:
     - auth
     - id
    """
    pass

  def getCollectionAggregates(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getSparkRDDConf(self, auth, collectionName):
    """
    Parameters:
     - auth
     - collectionName
    """
    pass

  def getNewSparkJobOutputPath(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def addSparkFilesToCollection(self, auth, collectionName, path):
    """
    Parameters:
     - auth
     - collectionName
     - path
    """
    pass

  def cleanupSparkImportDir(self, auth, importId):
    """
    Parameters:
     - auth
     - importId
    """
    pass

  def getDataSetAttributes(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    pass

  def getDataSetAttributeNames(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    pass

  def createLabel(self, auth, name):
    """
    Parameters:
     - auth
     - name
    """
    pass

  def getLabels(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def getLabel(self, auth, labelId):
    """
    Parameters:
     - auth
     - labelId
    """
    pass

  def deleteLabel(self, auth, labelId):
    """
    Parameters:
     - auth
     - labelId
    """
    pass

  def updateLabel(self, auth, label):
    """
    Parameters:
     - auth
     - label
    """
    pass

  def createLabelAssignment(self, auth, labelId, dataSetId):
    """
    Parameters:
     - auth
     - labelId
     - dataSetId
    """
    pass

  def getLabelAssignments(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def getLabelAssigmentById(self, auth, labelAssignmentId):
    """
    Parameters:
     - auth
     - labelAssignmentId
    """
    pass

  def deleteLabelAssignment(self, auth, labelId):
    """
    Parameters:
     - auth
     - labelId
    """
    pass

  def getDataSetPermissions(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    pass

  def createDataSetPermission(self, auth, permission):
    """
    Parameters:
     - auth
     - permission
    """
    pass

  def updateDataSetPermission(self, auth, permission):
    """
    Parameters:
     - auth
     - permission
    """
    pass

  def deleteDataSetPermission(self, auth, permissionId):
    """
    Parameters:
     - auth
     - permissionId
    """
    pass

  def getIndexingPolicy(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    pass

  def updateIndexingPolicy(self, auth, indexingPolicy):
    """
    Parameters:
     - auth
     - indexingPolicy
    """
    pass

  def updateMaskedAttributes(self, auth, attributes):
    """
    Parameters:
     - auth
     - attributes
    """
    pass

  def registerTable(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    pass

  def unregisterTable(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def getCollectionById(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getCollectionById(auth, collectionId)
    return self.recv_getCollectionById()

  def send_getCollectionById(self, auth, collectionId):
    self._oprot.writeMessageBegin('getCollectionById', TMessageType.CALL, self._seqid)
    args = getCollectionById_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionById(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCollectionById_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.nfe is not None:
      raise result.nfe
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionById failed: unknown result")

  def getCollectionByIdNotDeleted(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getCollectionByIdNotDeleted(auth, collectionId)
    return self.recv_getCollectionByIdNotDeleted()

  def send_getCollectionByIdNotDeleted(self, auth, collectionId):
    self._oprot.writeMessageBegin('getCollectionByIdNotDeleted', TMessageType.CALL, self._seqid)
    args = getCollectionByIdNotDeleted_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionByIdNotDeleted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCollectionByIdNotDeleted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.nfe is not None:
      raise result.nfe
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionByIdNotDeleted failed: unknown result")

  def getCollectionByName(self, auth, collectionName):
    """
    Parameters:
     - auth
     - collectionName
    """
    self.send_getCollectionByName(auth, collectionName)
    return self.recv_getCollectionByName()

  def send_getCollectionByName(self, auth, collectionName):
    self._oprot.writeMessageBegin('getCollectionByName', TMessageType.CALL, self._seqid)
    args = getCollectionByName_args()
    args.auth = auth
    args.collectionName = collectionName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionByName(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCollectionByName_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.nfe is not None:
      raise result.nfe
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionByName failed: unknown result")

  def listCollections(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_listCollections(auth)
    return self.recv_listCollections()

  def send_listCollections(self, auth):
    self._oprot.writeMessageBegin('listCollections', TMessageType.CALL, self._seqid)
    args = listCollections_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listCollections(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = listCollections_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listCollections failed: unknown result")

  def createCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    self.send_createCollection(auth, collection)
    return self.recv_createCollection()

  def send_createCollection(self, auth, collection):
    self._oprot.writeMessageBegin('createCollection', TMessageType.CALL, self._seqid)
    args = createCollection_args()
    args.auth = auth
    args.collection = collection
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createCollection(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createCollection_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createCollection failed: unknown result")

  def updateCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    self.send_updateCollection(auth, collection)
    return self.recv_updateCollection()

  def send_updateCollection(self, auth, collection):
    self._oprot.writeMessageBegin('updateCollection', TMessageType.CALL, self._seqid)
    args = updateCollection_args()
    args.auth = auth
    args.collection = collection
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateCollection(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateCollection_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateCollection failed: unknown result")

  def deleteCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    self.send_deleteCollection(auth, collection)
    return self.recv_deleteCollection()

  def send_deleteCollection(self, auth, collection):
    self._oprot.writeMessageBegin('deleteCollection', TMessageType.CALL, self._seqid)
    args = deleteCollection_args()
    args.auth = auth
    args.collection = collection
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteCollection(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteCollection_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteCollection failed: unknown result")

  def clearCollection(self, auth, collectionId, removeFieldNamesSeen):
    """
    Parameters:
     - auth
     - collectionId
     - removeFieldNamesSeen
    """
    self.send_clearCollection(auth, collectionId, removeFieldNamesSeen)
    self.recv_clearCollection()

  def send_clearCollection(self, auth, collectionId, removeFieldNamesSeen):
    self._oprot.writeMessageBegin('clearCollection', TMessageType.CALL, self._seqid)
    args = clearCollection_args()
    args.auth = auth
    args.collectionId = collectionId
    args.removeFieldNamesSeen = removeFieldNamesSeen
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearCollection(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearCollection_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def repair(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_repair(auth, collectionId)
    self.recv_repair()

  def send_repair(self, auth, collectionId):
    self._oprot.writeMessageBegin('repair', TMessageType.CALL, self._seqid)
    args = repair_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_repair(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = repair_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def getCollectionSample(self, auth, collectionId, maxRecords, removeByteArrayFieldValues, maxStringValueLength):
    """
    Parameters:
     - auth
     - collectionId
     - maxRecords
     - removeByteArrayFieldValues
     - maxStringValueLength
    """
    self.send_getCollectionSample(auth, collectionId, maxRecords, removeByteArrayFieldValues, maxStringValueLength)
    return self.recv_getCollectionSample()

  def send_getCollectionSample(self, auth, collectionId, maxRecords, removeByteArrayFieldValues, maxStringValueLength):
    self._oprot.writeMessageBegin('getCollectionSample', TMessageType.CALL, self._seqid)
    args = getCollectionSample_args()
    args.auth = auth
    args.collectionId = collectionId
    args.maxRecords = maxRecords
    args.removeByteArrayFieldValues = removeByteArrayFieldValues
    args.maxStringValueLength = maxStringValueLength
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionSample(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCollectionSample_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ae is not None:
      raise result.ae
    if result.ke is not None:
      raise result.ke
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionSample failed: unknown result")

  def startDownloadRecords(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_startDownloadRecords(auth, collectionId)
    return self.recv_startDownloadRecords()

  def send_startDownloadRecords(self, auth, collectionId):
    self._oprot.writeMessageBegin('startDownloadRecords', TMessageType.CALL, self._seqid)
    args = startDownloadRecords_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startDownloadRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = startDownloadRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startDownloadRecords failed: unknown result")

  def downloadMoreRecords(self, auth, downloadId, maxToReturn):
    """
    Parameters:
     - auth
     - downloadId
     - maxToReturn
    """
    self.send_downloadMoreRecords(auth, downloadId, maxToReturn)
    return self.recv_downloadMoreRecords()

  def send_downloadMoreRecords(self, auth, downloadId, maxToReturn):
    self._oprot.writeMessageBegin('downloadMoreRecords', TMessageType.CALL, self._seqid)
    args = downloadMoreRecords_args()
    args.auth = auth
    args.downloadId = downloadId
    args.maxToReturn = maxToReturn
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_downloadMoreRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = downloadMoreRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "downloadMoreRecords failed: unknown result")

  def stopDownloadRecords(self, auth, downloadId):
    """
    Parameters:
     - auth
     - downloadId
    """
    self.send_stopDownloadRecords(auth, downloadId)
    self.recv_stopDownloadRecords()

  def send_stopDownloadRecords(self, auth, downloadId):
    self._oprot.writeMessageBegin('stopDownloadRecords', TMessageType.CALL, self._seqid)
    args = stopDownloadRecords_args()
    args.auth = auth
    args.downloadId = downloadId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopDownloadRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = stopDownloadRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def startDownloadSamples(self, auth, collectionId, removeByteArrayFieldValues):
    """
    Parameters:
     - auth
     - collectionId
     - removeByteArrayFieldValues
    """
    self.send_startDownloadSamples(auth, collectionId, removeByteArrayFieldValues)
    return self.recv_startDownloadSamples()

  def send_startDownloadSamples(self, auth, collectionId, removeByteArrayFieldValues):
    self._oprot.writeMessageBegin('startDownloadSamples', TMessageType.CALL, self._seqid)
    args = startDownloadSamples_args()
    args.auth = auth
    args.collectionId = collectionId
    args.removeByteArrayFieldValues = removeByteArrayFieldValues
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startDownloadSamples(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = startDownloadSamples_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startDownloadSamples failed: unknown result")

  def downloadMoreSamples(self, auth, downloadId, maxToReturn):
    """
    Parameters:
     - auth
     - downloadId
     - maxToReturn
    """
    self.send_downloadMoreSamples(auth, downloadId, maxToReturn)
    return self.recv_downloadMoreSamples()

  def send_downloadMoreSamples(self, auth, downloadId, maxToReturn):
    self._oprot.writeMessageBegin('downloadMoreSamples', TMessageType.CALL, self._seqid)
    args = downloadMoreSamples_args()
    args.auth = auth
    args.downloadId = downloadId
    args.maxToReturn = maxToReturn
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_downloadMoreSamples(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = downloadMoreSamples_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "downloadMoreSamples failed: unknown result")

  def stopDownloadSamples(self, auth, downloadId):
    """
    Parameters:
     - auth
     - downloadId
    """
    self.send_stopDownloadSamples(auth, downloadId)
    self.recv_stopDownloadSamples()

  def send_stopDownloadSamples(self, auth, downloadId):
    self._oprot.writeMessageBegin('stopDownloadSamples', TMessageType.CALL, self._seqid)
    args = stopDownloadSamples_args()
    args.auth = auth
    args.downloadId = downloadId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopDownloadSamples(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = stopDownloadSamples_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def createAggregate(self, auth, aggregate):
    """
    Parameters:
     - auth
     - aggregate
    """
    self.send_createAggregate(auth, aggregate)
    self.recv_createAggregate()

  def send_createAggregate(self, auth, aggregate):
    self._oprot.writeMessageBegin('createAggregate', TMessageType.CALL, self._seqid)
    args = createAggregate_args()
    args.auth = auth
    args.aggregate = aggregate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createAggregate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createAggregate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def deleteAggregate(self, auth, collectionId, id):
    """
    Parameters:
     - auth
     - collectionId
     - id
    """
    self.send_deleteAggregate(auth, collectionId, id)
    self.recv_deleteAggregate()

  def send_deleteAggregate(self, auth, collectionId, id):
    self._oprot.writeMessageBegin('deleteAggregate', TMessageType.CALL, self._seqid)
    args = deleteAggregate_args()
    args.auth = auth
    args.collectionId = collectionId
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteAggregate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteAggregate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def getAggregate(self, auth, id):
    """
    Parameters:
     - auth
     - id
    """
    self.send_getAggregate(auth, id)
    return self.recv_getAggregate()

  def send_getAggregate(self, auth, id):
    self._oprot.writeMessageBegin('getAggregate', TMessageType.CALL, self._seqid)
    args = getAggregate_args()
    args.auth = auth
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAggregate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getAggregate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAggregate failed: unknown result")

  def getCollectionAggregates(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getCollectionAggregates(auth, collectionId)
    return self.recv_getCollectionAggregates()

  def send_getCollectionAggregates(self, auth, collectionId):
    self._oprot.writeMessageBegin('getCollectionAggregates', TMessageType.CALL, self._seqid)
    args = getCollectionAggregates_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionAggregates(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCollectionAggregates_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionAggregates failed: unknown result")

  def getSparkRDDConf(self, auth, collectionName):
    """
    Parameters:
     - auth
     - collectionName
    """
    self.send_getSparkRDDConf(auth, collectionName)
    return self.recv_getSparkRDDConf()

  def send_getSparkRDDConf(self, auth, collectionName):
    self._oprot.writeMessageBegin('getSparkRDDConf', TMessageType.CALL, self._seqid)
    args = getSparkRDDConf_args()
    args.auth = auth
    args.collectionName = collectionName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSparkRDDConf(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getSparkRDDConf_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSparkRDDConf failed: unknown result")

  def getNewSparkJobOutputPath(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_getNewSparkJobOutputPath(auth)
    return self.recv_getNewSparkJobOutputPath()

  def send_getNewSparkJobOutputPath(self, auth):
    self._oprot.writeMessageBegin('getNewSparkJobOutputPath', TMessageType.CALL, self._seqid)
    args = getNewSparkJobOutputPath_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNewSparkJobOutputPath(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getNewSparkJobOutputPath_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNewSparkJobOutputPath failed: unknown result")

  def addSparkFilesToCollection(self, auth, collectionName, path):
    """
    Parameters:
     - auth
     - collectionName
     - path
    """
    self.send_addSparkFilesToCollection(auth, collectionName, path)
    self.recv_addSparkFilesToCollection()

  def send_addSparkFilesToCollection(self, auth, collectionName, path):
    self._oprot.writeMessageBegin('addSparkFilesToCollection', TMessageType.CALL, self._seqid)
    args = addSparkFilesToCollection_args()
    args.auth = auth
    args.collectionName = collectionName
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addSparkFilesToCollection(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addSparkFilesToCollection_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def cleanupSparkImportDir(self, auth, importId):
    """
    Parameters:
     - auth
     - importId
    """
    self.send_cleanupSparkImportDir(auth, importId)
    self.recv_cleanupSparkImportDir()

  def send_cleanupSparkImportDir(self, auth, importId):
    self._oprot.writeMessageBegin('cleanupSparkImportDir', TMessageType.CALL, self._seqid)
    args = cleanupSparkImportDir_args()
    args.auth = auth
    args.importId = importId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cleanupSparkImportDir(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cleanupSparkImportDir_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def getDataSetAttributes(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    self.send_getDataSetAttributes(auth, dataSetId)
    return self.recv_getDataSetAttributes()

  def send_getDataSetAttributes(self, auth, dataSetId):
    self._oprot.writeMessageBegin('getDataSetAttributes', TMessageType.CALL, self._seqid)
    args = getDataSetAttributes_args()
    args.auth = auth
    args.dataSetId = dataSetId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDataSetAttributes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getDataSetAttributes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataSetAttributes failed: unknown result")

  def getDataSetAttributeNames(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    self.send_getDataSetAttributeNames(auth, dataSetId)
    return self.recv_getDataSetAttributeNames()

  def send_getDataSetAttributeNames(self, auth, dataSetId):
    self._oprot.writeMessageBegin('getDataSetAttributeNames', TMessageType.CALL, self._seqid)
    args = getDataSetAttributeNames_args()
    args.auth = auth
    args.dataSetId = dataSetId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDataSetAttributeNames(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getDataSetAttributeNames_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataSetAttributeNames failed: unknown result")

  def createLabel(self, auth, name):
    """
    Parameters:
     - auth
     - name
    """
    self.send_createLabel(auth, name)
    return self.recv_createLabel()

  def send_createLabel(self, auth, name):
    self._oprot.writeMessageBegin('createLabel', TMessageType.CALL, self._seqid)
    args = createLabel_args()
    args.auth = auth
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createLabel(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createLabel_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createLabel failed: unknown result")

  def getLabels(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_getLabels(auth)
    return self.recv_getLabels()

  def send_getLabels(self, auth):
    self._oprot.writeMessageBegin('getLabels', TMessageType.CALL, self._seqid)
    args = getLabels_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLabels(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getLabels_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLabels failed: unknown result")

  def getLabel(self, auth, labelId):
    """
    Parameters:
     - auth
     - labelId
    """
    self.send_getLabel(auth, labelId)
    return self.recv_getLabel()

  def send_getLabel(self, auth, labelId):
    self._oprot.writeMessageBegin('getLabel', TMessageType.CALL, self._seqid)
    args = getLabel_args()
    args.auth = auth
    args.labelId = labelId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLabel(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getLabel_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLabel failed: unknown result")

  def deleteLabel(self, auth, labelId):
    """
    Parameters:
     - auth
     - labelId
    """
    self.send_deleteLabel(auth, labelId)
    self.recv_deleteLabel()

  def send_deleteLabel(self, auth, labelId):
    self._oprot.writeMessageBegin('deleteLabel', TMessageType.CALL, self._seqid)
    args = deleteLabel_args()
    args.auth = auth
    args.labelId = labelId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteLabel(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteLabel_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    return

  def updateLabel(self, auth, label):
    """
    Parameters:
     - auth
     - label
    """
    self.send_updateLabel(auth, label)
    return self.recv_updateLabel()

  def send_updateLabel(self, auth, label):
    self._oprot.writeMessageBegin('updateLabel', TMessageType.CALL, self._seqid)
    args = updateLabel_args()
    args.auth = auth
    args.label = label
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateLabel(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateLabel_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateLabel failed: unknown result")

  def createLabelAssignment(self, auth, labelId, dataSetId):
    """
    Parameters:
     - auth
     - labelId
     - dataSetId
    """
    self.send_createLabelAssignment(auth, labelId, dataSetId)
    return self.recv_createLabelAssignment()

  def send_createLabelAssignment(self, auth, labelId, dataSetId):
    self._oprot.writeMessageBegin('createLabelAssignment', TMessageType.CALL, self._seqid)
    args = createLabelAssignment_args()
    args.auth = auth
    args.labelId = labelId
    args.dataSetId = dataSetId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createLabelAssignment(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createLabelAssignment_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createLabelAssignment failed: unknown result")

  def getLabelAssignments(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_getLabelAssignments(auth)
    return self.recv_getLabelAssignments()

  def send_getLabelAssignments(self, auth):
    self._oprot.writeMessageBegin('getLabelAssignments', TMessageType.CALL, self._seqid)
    args = getLabelAssignments_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLabelAssignments(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getLabelAssignments_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLabelAssignments failed: unknown result")

  def getLabelAssigmentById(self, auth, labelAssignmentId):
    """
    Parameters:
     - auth
     - labelAssignmentId
    """
    self.send_getLabelAssigmentById(auth, labelAssignmentId)
    return self.recv_getLabelAssigmentById()

  def send_getLabelAssigmentById(self, auth, labelAssignmentId):
    self._oprot.writeMessageBegin('getLabelAssigmentById', TMessageType.CALL, self._seqid)
    args = getLabelAssigmentById_args()
    args.auth = auth
    args.labelAssignmentId = labelAssignmentId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLabelAssigmentById(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getLabelAssigmentById_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLabelAssigmentById failed: unknown result")

  def deleteLabelAssignment(self, auth, labelId):
    """
    Parameters:
     - auth
     - labelId
    """
    self.send_deleteLabelAssignment(auth, labelId)
    self.recv_deleteLabelAssignment()

  def send_deleteLabelAssignment(self, auth, labelId):
    self._oprot.writeMessageBegin('deleteLabelAssignment', TMessageType.CALL, self._seqid)
    args = deleteLabelAssignment_args()
    args.auth = auth
    args.labelId = labelId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteLabelAssignment(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteLabelAssignment_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    return

  def getDataSetPermissions(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    self.send_getDataSetPermissions(auth, dataSetId)
    return self.recv_getDataSetPermissions()

  def send_getDataSetPermissions(self, auth, dataSetId):
    self._oprot.writeMessageBegin('getDataSetPermissions', TMessageType.CALL, self._seqid)
    args = getDataSetPermissions_args()
    args.auth = auth
    args.dataSetId = dataSetId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDataSetPermissions(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getDataSetPermissions_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataSetPermissions failed: unknown result")

  def createDataSetPermission(self, auth, permission):
    """
    Parameters:
     - auth
     - permission
    """
    self.send_createDataSetPermission(auth, permission)
    return self.recv_createDataSetPermission()

  def send_createDataSetPermission(self, auth, permission):
    self._oprot.writeMessageBegin('createDataSetPermission', TMessageType.CALL, self._seqid)
    args = createDataSetPermission_args()
    args.auth = auth
    args.permission = permission
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createDataSetPermission(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createDataSetPermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createDataSetPermission failed: unknown result")

  def updateDataSetPermission(self, auth, permission):
    """
    Parameters:
     - auth
     - permission
    """
    self.send_updateDataSetPermission(auth, permission)
    return self.recv_updateDataSetPermission()

  def send_updateDataSetPermission(self, auth, permission):
    self._oprot.writeMessageBegin('updateDataSetPermission', TMessageType.CALL, self._seqid)
    args = updateDataSetPermission_args()
    args.auth = auth
    args.permission = permission
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateDataSetPermission(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateDataSetPermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateDataSetPermission failed: unknown result")

  def deleteDataSetPermission(self, auth, permissionId):
    """
    Parameters:
     - auth
     - permissionId
    """
    self.send_deleteDataSetPermission(auth, permissionId)
    self.recv_deleteDataSetPermission()

  def send_deleteDataSetPermission(self, auth, permissionId):
    self._oprot.writeMessageBegin('deleteDataSetPermission', TMessageType.CALL, self._seqid)
    args = deleteDataSetPermission_args()
    args.auth = auth
    args.permissionId = permissionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteDataSetPermission(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteDataSetPermission_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    return

  def getIndexingPolicy(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    self.send_getIndexingPolicy(auth, dataSetId)
    return self.recv_getIndexingPolicy()

  def send_getIndexingPolicy(self, auth, dataSetId):
    self._oprot.writeMessageBegin('getIndexingPolicy', TMessageType.CALL, self._seqid)
    args = getIndexingPolicy_args()
    args.auth = auth
    args.dataSetId = dataSetId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getIndexingPolicy(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getIndexingPolicy_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getIndexingPolicy failed: unknown result")

  def updateIndexingPolicy(self, auth, indexingPolicy):
    """
    Parameters:
     - auth
     - indexingPolicy
    """
    self.send_updateIndexingPolicy(auth, indexingPolicy)
    return self.recv_updateIndexingPolicy()

  def send_updateIndexingPolicy(self, auth, indexingPolicy):
    self._oprot.writeMessageBegin('updateIndexingPolicy', TMessageType.CALL, self._seqid)
    args = updateIndexingPolicy_args()
    args.auth = auth
    args.indexingPolicy = indexingPolicy
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateIndexingPolicy(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateIndexingPolicy_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateIndexingPolicy failed: unknown result")

  def updateMaskedAttributes(self, auth, attributes):
    """
    Parameters:
     - auth
     - attributes
    """
    self.send_updateMaskedAttributes(auth, attributes)
    return self.recv_updateMaskedAttributes()

  def send_updateMaskedAttributes(self, auth, attributes):
    self._oprot.writeMessageBegin('updateMaskedAttributes', TMessageType.CALL, self._seqid)
    args = updateMaskedAttributes_args()
    args.auth = auth
    args.attributes = attributes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateMaskedAttributes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateMaskedAttributes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateMaskedAttributes failed: unknown result")

  def registerTable(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    self.send_registerTable(auth, dataSetId)
    self.recv_registerTable()

  def send_registerTable(self, auth, dataSetId):
    self._oprot.writeMessageBegin('registerTable', TMessageType.CALL, self._seqid)
    args = registerTable_args()
    args.auth = auth
    args.dataSetId = dataSetId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_registerTable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = registerTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def unregisterTable(self, auth, dataSetId):
    """
    Parameters:
     - auth
     - dataSetId
    """
    self.send_unregisterTable(auth, dataSetId)
    self.recv_unregisterTable()

  def send_unregisterTable(self, auth, dataSetId):
    self._oprot.writeMessageBegin('unregisterTable', TMessageType.CALL, self._seqid)
    args = unregisterTable_args()
    args.auth = auth
    args.dataSetId = dataSetId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unregisterTable(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = unregisterTable_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["getCollectionById"] = Processor.process_getCollectionById
    self._processMap["getCollectionByIdNotDeleted"] = Processor.process_getCollectionByIdNotDeleted
    self._processMap["getCollectionByName"] = Processor.process_getCollectionByName
    self._processMap["listCollections"] = Processor.process_listCollections
    self._processMap["createCollection"] = Processor.process_createCollection
    self._processMap["updateCollection"] = Processor.process_updateCollection
    self._processMap["deleteCollection"] = Processor.process_deleteCollection
    self._processMap["clearCollection"] = Processor.process_clearCollection
    self._processMap["repair"] = Processor.process_repair
    self._processMap["getCollectionSample"] = Processor.process_getCollectionSample
    self._processMap["startDownloadRecords"] = Processor.process_startDownloadRecords
    self._processMap["downloadMoreRecords"] = Processor.process_downloadMoreRecords
    self._processMap["stopDownloadRecords"] = Processor.process_stopDownloadRecords
    self._processMap["startDownloadSamples"] = Processor.process_startDownloadSamples
    self._processMap["downloadMoreSamples"] = Processor.process_downloadMoreSamples
    self._processMap["stopDownloadSamples"] = Processor.process_stopDownloadSamples
    self._processMap["createAggregate"] = Processor.process_createAggregate
    self._processMap["deleteAggregate"] = Processor.process_deleteAggregate
    self._processMap["getAggregate"] = Processor.process_getAggregate
    self._processMap["getCollectionAggregates"] = Processor.process_getCollectionAggregates
    self._processMap["getSparkRDDConf"] = Processor.process_getSparkRDDConf
    self._processMap["getNewSparkJobOutputPath"] = Processor.process_getNewSparkJobOutputPath
    self._processMap["addSparkFilesToCollection"] = Processor.process_addSparkFilesToCollection
    self._processMap["cleanupSparkImportDir"] = Processor.process_cleanupSparkImportDir
    self._processMap["getDataSetAttributes"] = Processor.process_getDataSetAttributes
    self._processMap["getDataSetAttributeNames"] = Processor.process_getDataSetAttributeNames
    self._processMap["createLabel"] = Processor.process_createLabel
    self._processMap["getLabels"] = Processor.process_getLabels
    self._processMap["getLabel"] = Processor.process_getLabel
    self._processMap["deleteLabel"] = Processor.process_deleteLabel
    self._processMap["updateLabel"] = Processor.process_updateLabel
    self._processMap["createLabelAssignment"] = Processor.process_createLabelAssignment
    self._processMap["getLabelAssignments"] = Processor.process_getLabelAssignments
    self._processMap["getLabelAssigmentById"] = Processor.process_getLabelAssigmentById
    self._processMap["deleteLabelAssignment"] = Processor.process_deleteLabelAssignment
    self._processMap["getDataSetPermissions"] = Processor.process_getDataSetPermissions
    self._processMap["createDataSetPermission"] = Processor.process_createDataSetPermission
    self._processMap["updateDataSetPermission"] = Processor.process_updateDataSetPermission
    self._processMap["deleteDataSetPermission"] = Processor.process_deleteDataSetPermission
    self._processMap["getIndexingPolicy"] = Processor.process_getIndexingPolicy
    self._processMap["updateIndexingPolicy"] = Processor.process_updateIndexingPolicy
    self._processMap["updateMaskedAttributes"] = Processor.process_updateMaskedAttributes
    self._processMap["registerTable"] = Processor.process_registerTable
    self._processMap["unregisterTable"] = Processor.process_unregisterTable

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getCollectionById(self, seqid, iprot, oprot):
    args = getCollectionById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionById_result()
    try:
      result.success = self._handler.getCollectionById(args.auth, args.collectionId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.ttypes.TNotFoundException as nfe:
      msg_type = TMessageType.REPLY
      result.nfe = nfe
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCollectionById", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionByIdNotDeleted(self, seqid, iprot, oprot):
    args = getCollectionByIdNotDeleted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionByIdNotDeleted_result()
    try:
      result.success = self._handler.getCollectionByIdNotDeleted(args.auth, args.collectionId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.ttypes.TNotFoundException as nfe:
      msg_type = TMessageType.REPLY
      result.nfe = nfe
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCollectionByIdNotDeleted", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionByName(self, seqid, iprot, oprot):
    args = getCollectionByName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionByName_result()
    try:
      result.success = self._handler.getCollectionByName(args.auth, args.collectionName)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.ttypes.TNotFoundException as nfe:
      msg_type = TMessageType.REPLY
      result.nfe = nfe
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCollectionByName", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listCollections(self, seqid, iprot, oprot):
    args = listCollections_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listCollections_result()
    try:
      result.success = self._handler.listCollections(args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("listCollections", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createCollection(self, seqid, iprot, oprot):
    args = createCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createCollection_result()
    try:
      result.success = self._handler.createCollection(args.auth, args.collection)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createCollection", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateCollection(self, seqid, iprot, oprot):
    args = updateCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateCollection_result()
    try:
      result.success = self._handler.updateCollection(args.auth, args.collection)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateCollection", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteCollection(self, seqid, iprot, oprot):
    args = deleteCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteCollection_result()
    try:
      result.success = self._handler.deleteCollection(args.auth, args.collection)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteCollection", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearCollection(self, seqid, iprot, oprot):
    args = clearCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearCollection_result()
    try:
      self._handler.clearCollection(args.auth, args.collectionId, args.removeFieldNamesSeen)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearCollection", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_repair(self, seqid, iprot, oprot):
    args = repair_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = repair_result()
    try:
      self._handler.repair(args.auth, args.collectionId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("repair", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionSample(self, seqid, iprot, oprot):
    args = getCollectionSample_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionSample_result()
    try:
      result.success = self._handler.getCollectionSample(args.auth, args.collectionId, args.maxRecords, args.removeByteArrayFieldValues, args.maxStringValueLength)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCollectionSample", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startDownloadRecords(self, seqid, iprot, oprot):
    args = startDownloadRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startDownloadRecords_result()
    try:
      result.success = self._handler.startDownloadRecords(args.auth, args.collectionId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("startDownloadRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_downloadMoreRecords(self, seqid, iprot, oprot):
    args = downloadMoreRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = downloadMoreRecords_result()
    try:
      result.success = self._handler.downloadMoreRecords(args.auth, args.downloadId, args.maxToReturn)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("downloadMoreRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopDownloadRecords(self, seqid, iprot, oprot):
    args = stopDownloadRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopDownloadRecords_result()
    try:
      self._handler.stopDownloadRecords(args.auth, args.downloadId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("stopDownloadRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startDownloadSamples(self, seqid, iprot, oprot):
    args = startDownloadSamples_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startDownloadSamples_result()
    try:
      result.success = self._handler.startDownloadSamples(args.auth, args.collectionId, args.removeByteArrayFieldValues)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("startDownloadSamples", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_downloadMoreSamples(self, seqid, iprot, oprot):
    args = downloadMoreSamples_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = downloadMoreSamples_result()
    try:
      result.success = self._handler.downloadMoreSamples(args.auth, args.downloadId, args.maxToReturn)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("downloadMoreSamples", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopDownloadSamples(self, seqid, iprot, oprot):
    args = stopDownloadSamples_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopDownloadSamples_result()
    try:
      self._handler.stopDownloadSamples(args.auth, args.downloadId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("stopDownloadSamples", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createAggregate(self, seqid, iprot, oprot):
    args = createAggregate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createAggregate_result()
    try:
      self._handler.createAggregate(args.auth, args.aggregate)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createAggregate", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteAggregate(self, seqid, iprot, oprot):
    args = deleteAggregate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteAggregate_result()
    try:
      self._handler.deleteAggregate(args.auth, args.collectionId, args.id)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteAggregate", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAggregate(self, seqid, iprot, oprot):
    args = getAggregate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAggregate_result()
    try:
      result.success = self._handler.getAggregate(args.auth, args.id)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getAggregate", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionAggregates(self, seqid, iprot, oprot):
    args = getCollectionAggregates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionAggregates_result()
    try:
      result.success = self._handler.getCollectionAggregates(args.auth, args.collectionId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCollectionAggregates", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSparkRDDConf(self, seqid, iprot, oprot):
    args = getSparkRDDConf_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSparkRDDConf_result()
    try:
      result.success = self._handler.getSparkRDDConf(args.auth, args.collectionName)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getSparkRDDConf", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNewSparkJobOutputPath(self, seqid, iprot, oprot):
    args = getNewSparkJobOutputPath_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNewSparkJobOutputPath_result()
    try:
      result.success = self._handler.getNewSparkJobOutputPath(args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getNewSparkJobOutputPath", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addSparkFilesToCollection(self, seqid, iprot, oprot):
    args = addSparkFilesToCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addSparkFilesToCollection_result()
    try:
      self._handler.addSparkFilesToCollection(args.auth, args.collectionName, args.path)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addSparkFilesToCollection", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cleanupSparkImportDir(self, seqid, iprot, oprot):
    args = cleanupSparkImportDir_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cleanupSparkImportDir_result()
    try:
      self._handler.cleanupSparkImportDir(args.auth, args.importId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("cleanupSparkImportDir", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDataSetAttributes(self, seqid, iprot, oprot):
    args = getDataSetAttributes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDataSetAttributes_result()
    try:
      result.success = self._handler.getDataSetAttributes(args.auth, args.dataSetId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getDataSetAttributes", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDataSetAttributeNames(self, seqid, iprot, oprot):
    args = getDataSetAttributeNames_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDataSetAttributeNames_result()
    try:
      result.success = self._handler.getDataSetAttributeNames(args.auth, args.dataSetId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getDataSetAttributeNames", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createLabel(self, seqid, iprot, oprot):
    args = createLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createLabel_result()
    try:
      result.success = self._handler.createLabel(args.auth, args.name)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createLabel", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLabels(self, seqid, iprot, oprot):
    args = getLabels_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLabels_result()
    try:
      result.success = self._handler.getLabels(args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getLabels", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLabel(self, seqid, iprot, oprot):
    args = getLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLabel_result()
    try:
      result.success = self._handler.getLabel(args.auth, args.labelId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getLabel", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteLabel(self, seqid, iprot, oprot):
    args = deleteLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteLabel_result()
    try:
      self._handler.deleteLabel(args.auth, args.labelId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteLabel", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateLabel(self, seqid, iprot, oprot):
    args = updateLabel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateLabel_result()
    try:
      result.success = self._handler.updateLabel(args.auth, args.label)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateLabel", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createLabelAssignment(self, seqid, iprot, oprot):
    args = createLabelAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createLabelAssignment_result()
    try:
      result.success = self._handler.createLabelAssignment(args.auth, args.labelId, args.dataSetId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createLabelAssignment", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLabelAssignments(self, seqid, iprot, oprot):
    args = getLabelAssignments_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLabelAssignments_result()
    try:
      result.success = self._handler.getLabelAssignments(args.auth)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getLabelAssignments", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLabelAssigmentById(self, seqid, iprot, oprot):
    args = getLabelAssigmentById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLabelAssigmentById_result()
    try:
      result.success = self._handler.getLabelAssigmentById(args.auth, args.labelAssignmentId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getLabelAssigmentById", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteLabelAssignment(self, seqid, iprot, oprot):
    args = deleteLabelAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteLabelAssignment_result()
    try:
      self._handler.deleteLabelAssignment(args.auth, args.labelId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteLabelAssignment", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDataSetPermissions(self, seqid, iprot, oprot):
    args = getDataSetPermissions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDataSetPermissions_result()
    try:
      result.success = self._handler.getDataSetPermissions(args.auth, args.dataSetId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getDataSetPermissions", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createDataSetPermission(self, seqid, iprot, oprot):
    args = createDataSetPermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createDataSetPermission_result()
    try:
      result.success = self._handler.createDataSetPermission(args.auth, args.permission)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createDataSetPermission", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateDataSetPermission(self, seqid, iprot, oprot):
    args = updateDataSetPermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateDataSetPermission_result()
    try:
      result.success = self._handler.updateDataSetPermission(args.auth, args.permission)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateDataSetPermission", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteDataSetPermission(self, seqid, iprot, oprot):
    args = deleteDataSetPermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteDataSetPermission_result()
    try:
      self._handler.deleteDataSetPermission(args.auth, args.permissionId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteDataSetPermission", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getIndexingPolicy(self, seqid, iprot, oprot):
    args = getIndexingPolicy_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getIndexingPolicy_result()
    try:
      result.success = self._handler.getIndexingPolicy(args.auth, args.dataSetId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getIndexingPolicy", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateIndexingPolicy(self, seqid, iprot, oprot):
    args = updateIndexingPolicy_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateIndexingPolicy_result()
    try:
      result.success = self._handler.updateIndexingPolicy(args.auth, args.indexingPolicy)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateIndexingPolicy", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateMaskedAttributes(self, seqid, iprot, oprot):
    args = updateMaskedAttributes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateMaskedAttributes_result()
    try:
      result.success = self._handler.updateMaskedAttributes(args.auth, args.attributes)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateMaskedAttributes", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_registerTable(self, seqid, iprot, oprot):
    args = registerTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = registerTable_result()
    try:
      self._handler.registerTable(args.auth, args.dataSetId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("registerTable", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unregisterTable(self, seqid, iprot, oprot):
    args = unregisterTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unregisterTable_result()
    try:
      self._handler.unregisterTable(args.auth, args.dataSetId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except koverse.thriftgen.ttypes.TKoverseException as ke:
      msg_type = TMessageType.REPLY
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException as ae:
      msg_type = TMessageType.REPLY
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException as ce:
      msg_type = TMessageType.REPLY
      result.ce = ce
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("unregisterTable", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getCollectionById_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionById_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionById_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - nfe
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nfe', (koverse.thriftgen.ttypes.TNotFoundException, koverse.thriftgen.ttypes.TNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ke=None, ae=None, nfe=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.nfe = nfe
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nfe = koverse.thriftgen.ttypes.TNotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe is not None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 3)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 4)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.nfe)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionByIdNotDeleted_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionByIdNotDeleted_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionByIdNotDeleted_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - nfe
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nfe', (koverse.thriftgen.ttypes.TNotFoundException, koverse.thriftgen.ttypes.TNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ke=None, ae=None, nfe=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.nfe = nfe
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nfe = koverse.thriftgen.ttypes.TNotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionByIdNotDeleted_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe is not None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 3)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 4)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.nfe)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionByName_args:
  """
  Attributes:
   - auth
   - collectionName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionName', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionName=None,):
    self.auth = auth
    self.collectionName = collectionName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionByName_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionName is not None:
      oprot.writeFieldBegin('collectionName', TType.STRING, 2)
      oprot.writeString(self.collectionName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionByName_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - nfe
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nfe', (koverse.thriftgen.ttypes.TNotFoundException, koverse.thriftgen.ttypes.TNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ke=None, ae=None, nfe=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.nfe = nfe
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nfe = koverse.thriftgen.ttypes.TNotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionByName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe is not None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 3)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 4)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.nfe)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listCollections_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listCollections_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listCollections_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollection, TCollection.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype183, _size180) = iprot.readListBegin()
          for _i184 in xrange(_size180):
            _elem185 = TCollection()
            _elem185.read(iprot)
            self.success.append(_elem185)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listCollections_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter186 in self.success:
        iter186.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createCollection_args:
  """
  Attributes:
   - auth
   - collection
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'collection', (TCollection, TCollection.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, collection=None,):
    self.auth = auth
    self.collection = collection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.collection = TCollection()
          self.collection.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collection is not None:
      oprot.writeFieldBegin('collection', TType.STRUCT, 2)
      self.collection.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collection)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createCollection_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createCollection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateCollection_args:
  """
  Attributes:
   - auth
   - collection
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'collection', (TCollection, TCollection.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, collection=None,):
    self.auth = auth
    self.collection = collection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.collection = TCollection()
          self.collection.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collection is not None:
      oprot.writeFieldBegin('collection', TType.STRUCT, 2)
      self.collection.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collection)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateCollection_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateCollection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteCollection_args:
  """
  Attributes:
   - auth
   - collection
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'collection', (TCollection, TCollection.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, collection=None,):
    self.auth = auth
    self.collection = collection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.collection = TCollection()
          self.collection.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collection is not None:
      oprot.writeFieldBegin('collection', TType.STRUCT, 2)
      self.collection.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collection)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteCollection_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteCollection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearCollection_args:
  """
  Attributes:
   - auth
   - collectionId
   - removeFieldNamesSeen
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.BOOL, 'removeFieldNamesSeen', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, removeFieldNamesSeen=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.removeFieldNamesSeen = removeFieldNamesSeen

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.removeFieldNamesSeen = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.removeFieldNamesSeen is not None:
      oprot.writeFieldBegin('removeFieldNamesSeen', TType.BOOL, 3)
      oprot.writeBool(self.removeFieldNamesSeen)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    value = (value * 31) ^ hash(self.removeFieldNamesSeen)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearCollection_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearCollection_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class repair_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('repair_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class repair_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('repair_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionSample_args:
  """
  Attributes:
   - auth
   - collectionId
   - maxRecords
   - removeByteArrayFieldValues
   - maxStringValueLength
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.I32, 'maxRecords', None, None, ), # 3
    (4, TType.BOOL, 'removeByteArrayFieldValues', None, None, ), # 4
    (5, TType.I32, 'maxStringValueLength', None, None, ), # 5
  )

  def __init__(self, auth=None, collectionId=None, maxRecords=None, removeByteArrayFieldValues=None, maxStringValueLength=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.maxRecords = maxRecords
    self.removeByteArrayFieldValues = removeByteArrayFieldValues
    self.maxStringValueLength = maxStringValueLength

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxRecords = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.removeByteArrayFieldValues = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.maxStringValueLength = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionSample_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.maxRecords is not None:
      oprot.writeFieldBegin('maxRecords', TType.I32, 3)
      oprot.writeI32(self.maxRecords)
      oprot.writeFieldEnd()
    if self.removeByteArrayFieldValues is not None:
      oprot.writeFieldBegin('removeByteArrayFieldValues', TType.BOOL, 4)
      oprot.writeBool(self.removeByteArrayFieldValues)
      oprot.writeFieldEnd()
    if self.maxStringValueLength is not None:
      oprot.writeFieldBegin('maxStringValueLength', TType.I32, 5)
      oprot.writeI32(self.maxStringValueLength)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    value = (value * 31) ^ hash(self.maxRecords)
    value = (value * 31) ^ hash(self.removeByteArrayFieldValues)
    value = (value * 31) ^ hash(self.maxStringValueLength)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionSample_result:
  """
  Attributes:
   - success
   - ae
   - ke
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(koverse.thriftgen.ttypes.TSimpleRecord, koverse.thriftgen.ttypes.TSimpleRecord.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ae=None, ke=None, ce=None,):
    self.success = success
    self.ae = ae
    self.ke = ke
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype190, _size187) = iprot.readListBegin()
          for _i191 in xrange(_size187):
            _elem192 = koverse.thriftgen.ttypes.TSimpleRecord()
            _elem192.read(iprot)
            self.success.append(_elem192)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionSample_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter193 in self.success:
        iter193.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 1)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 2)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startDownloadRecords_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startDownloadRecords_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startDownloadRecords_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startDownloadRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class downloadMoreRecords_args:
  """
  Attributes:
   - auth
   - downloadId
   - maxToReturn
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'downloadId', None, None, ), # 2
    (3, TType.I16, 'maxToReturn', None, None, ), # 3
  )

  def __init__(self, auth=None, downloadId=None, maxToReturn=None,):
    self.auth = auth
    self.downloadId = downloadId
    self.maxToReturn = maxToReturn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.maxToReturn = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('downloadMoreRecords_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 2)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    if self.maxToReturn is not None:
      oprot.writeFieldBegin('maxToReturn', TType.I16, 3)
      oprot.writeI16(self.maxToReturn)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.downloadId)
    value = (value * 31) ^ hash(self.maxToReturn)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class downloadMoreRecords_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (koverse.thriftgen.ttypes.TDownloadRecords, koverse.thriftgen.ttypes.TDownloadRecords.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = koverse.thriftgen.ttypes.TDownloadRecords()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('downloadMoreRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopDownloadRecords_args:
  """
  Attributes:
   - auth
   - downloadId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'downloadId', None, None, ), # 2
  )

  def __init__(self, auth=None, downloadId=None,):
    self.auth = auth
    self.downloadId = downloadId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopDownloadRecords_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 2)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.downloadId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopDownloadRecords_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopDownloadRecords_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startDownloadSamples_args:
  """
  Attributes:
   - auth
   - collectionId
   - removeByteArrayFieldValues
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.BOOL, 'removeByteArrayFieldValues', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, removeByteArrayFieldValues=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.removeByteArrayFieldValues = removeByteArrayFieldValues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.removeByteArrayFieldValues = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startDownloadSamples_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.removeByteArrayFieldValues is not None:
      oprot.writeFieldBegin('removeByteArrayFieldValues', TType.BOOL, 3)
      oprot.writeBool(self.removeByteArrayFieldValues)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    value = (value * 31) ^ hash(self.removeByteArrayFieldValues)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startDownloadSamples_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startDownloadSamples_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class downloadMoreSamples_args:
  """
  Attributes:
   - auth
   - downloadId
   - maxToReturn
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'downloadId', None, None, ), # 2
    (3, TType.I16, 'maxToReturn', None, None, ), # 3
  )

  def __init__(self, auth=None, downloadId=None, maxToReturn=None,):
    self.auth = auth
    self.downloadId = downloadId
    self.maxToReturn = maxToReturn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.maxToReturn = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('downloadMoreSamples_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 2)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    if self.maxToReturn is not None:
      oprot.writeFieldBegin('maxToReturn', TType.I16, 3)
      oprot.writeI16(self.maxToReturn)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.downloadId)
    value = (value * 31) ^ hash(self.maxToReturn)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class downloadMoreSamples_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (koverse.thriftgen.ttypes.TDownloadRecords, koverse.thriftgen.ttypes.TDownloadRecords.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = koverse.thriftgen.ttypes.TDownloadRecords()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('downloadMoreSamples_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopDownloadSamples_args:
  """
  Attributes:
   - auth
   - downloadId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'downloadId', None, None, ), # 2
  )

  def __init__(self, auth=None, downloadId=None,):
    self.auth = auth
    self.downloadId = downloadId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopDownloadSamples_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 2)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.downloadId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopDownloadSamples_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopDownloadSamples_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createAggregate_args:
  """
  Attributes:
   - auth
   - aggregate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'aggregate', (koverse.thriftgen.aggregate.ttypes.TAggregate, koverse.thriftgen.aggregate.ttypes.TAggregate.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, aggregate=None,):
    self.auth = auth
    self.aggregate = aggregate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.aggregate = koverse.thriftgen.aggregate.ttypes.TAggregate()
          self.aggregate.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createAggregate_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.aggregate is not None:
      oprot.writeFieldBegin('aggregate', TType.STRUCT, 2)
      self.aggregate.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.aggregate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createAggregate_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createAggregate_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteAggregate_args:
  """
  Attributes:
   - auth
   - collectionId
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.I64, 'id', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, id=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteAggregate_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 3)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    value = (value * 31) ^ hash(self.id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteAggregate_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteAggregate_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAggregate_args:
  """
  Attributes:
   - auth
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I64, 'id', None, None, ), # 2
  )

  def __init__(self, auth=None, id=None,):
    self.auth = auth
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAggregate_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAggregate_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (koverse.thriftgen.aggregate.ttypes.TAggregate, koverse.thriftgen.aggregate.ttypes.TAggregate.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = koverse.thriftgen.aggregate.ttypes.TAggregate()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAggregate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionAggregates_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionAggregates_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionAggregates_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(koverse.thriftgen.aggregate.ttypes.TAggregate, koverse.thriftgen.aggregate.ttypes.TAggregate.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype197, _size194) = iprot.readListBegin()
          for _i198 in xrange(_size194):
            _elem199 = koverse.thriftgen.aggregate.ttypes.TAggregate()
            _elem199.read(iprot)
            self.success.append(_elem199)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionAggregates_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter200 in self.success:
        iter200.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSparkRDDConf_args:
  """
  Attributes:
   - auth
   - collectionName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionName', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionName=None,):
    self.auth = auth
    self.collectionName = collectionName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSparkRDDConf_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionName is not None:
      oprot.writeFieldBegin('collectionName', TType.STRING, 2)
      oprot.writeString(self.collectionName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSparkRDDConf_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype202, _vtype203, _size201 ) = iprot.readMapBegin()
          for _i205 in xrange(_size201):
            _key206 = iprot.readString()
            _val207 = iprot.readString()
            self.success[_key206] = _val207
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSparkRDDConf_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter208,viter209 in self.success.items():
        oprot.writeString(kiter208)
        oprot.writeString(viter209)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNewSparkJobOutputPath_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNewSparkJobOutputPath_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNewSparkJobOutputPath_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNewSparkJobOutputPath_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addSparkFilesToCollection_args:
  """
  Attributes:
   - auth
   - collectionName
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionName', None, None, ), # 2
    (3, TType.STRING, 'path', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionName=None, path=None,):
    self.auth = auth
    self.collectionName = collectionName
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.path = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addSparkFilesToCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionName is not None:
      oprot.writeFieldBegin('collectionName', TType.STRING, 2)
      oprot.writeString(self.collectionName)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 3)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.collectionName)
    value = (value * 31) ^ hash(self.path)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addSparkFilesToCollection_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addSparkFilesToCollection_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cleanupSparkImportDir_args:
  """
  Attributes:
   - auth
   - importId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I32, 'importId', None, None, ), # 2
  )

  def __init__(self, auth=None, importId=None,):
    self.auth = auth
    self.importId = importId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.importId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cleanupSparkImportDir_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.importId is not None:
      oprot.writeFieldBegin('importId', TType.I32, 2)
      oprot.writeI32(self.importId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.importId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cleanupSparkImportDir_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cleanupSparkImportDir_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataSetAttributes_args:
  """
  Attributes:
   - auth
   - dataSetId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dataSetId', None, None, ), # 2
  )

  def __init__(self, auth=None, dataSetId=None,):
    self.auth = auth
    self.dataSetId = dataSetId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dataSetId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataSetAttributes_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.dataSetId is not None:
      oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
      oprot.writeString(self.dataSetId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.dataSetId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataSetAttributes_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TDataSetAttribute, TDataSetAttribute.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype213, _size210) = iprot.readListBegin()
          for _i214 in xrange(_size210):
            _elem215 = TDataSetAttribute()
            _elem215.read(iprot)
            self.success.append(_elem215)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataSetAttributes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter216 in self.success:
        iter216.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataSetAttributeNames_args:
  """
  Attributes:
   - auth
   - dataSetId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dataSetId', None, None, ), # 2
  )

  def __init__(self, auth=None, dataSetId=None,):
    self.auth = auth
    self.dataSetId = dataSetId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dataSetId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataSetAttributeNames_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.dataSetId is not None:
      oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
      oprot.writeString(self.dataSetId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.dataSetId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataSetAttributeNames_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype220, _size217) = iprot.readListBegin()
          for _i221 in xrange(_size217):
            _elem222 = iprot.readString()
            self.success.append(_elem222)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataSetAttributeNames_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter223 in self.success:
        oprot.writeString(iter223)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLabel_args:
  """
  Attributes:
   - auth
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, auth=None, name=None,):
    self.auth = auth
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLabel_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLabel_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (koverse.thriftgen.ttypes.TLabel, koverse.thriftgen.ttypes.TLabel.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = koverse.thriftgen.ttypes.TLabel()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLabels_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLabels_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLabels_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(koverse.thriftgen.ttypes.TLabel, koverse.thriftgen.ttypes.TLabel.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype227, _size224) = iprot.readListBegin()
          for _i228 in xrange(_size224):
            _elem229 = koverse.thriftgen.ttypes.TLabel()
            _elem229.read(iprot)
            self.success.append(_elem229)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLabels_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter230 in self.success:
        iter230.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLabel_args:
  """
  Attributes:
   - auth
   - labelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I64, 'labelId', None, None, ), # 2
  )

  def __init__(self, auth=None, labelId=None,):
    self.auth = auth
    self.labelId = labelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.labelId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLabel_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.labelId is not None:
      oprot.writeFieldBegin('labelId', TType.I64, 2)
      oprot.writeI64(self.labelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.labelId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLabel_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (koverse.thriftgen.ttypes.TLabel, koverse.thriftgen.ttypes.TLabel.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = koverse.thriftgen.ttypes.TLabel()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteLabel_args:
  """
  Attributes:
   - auth
   - labelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I64, 'labelId', None, None, ), # 2
  )

  def __init__(self, auth=None, labelId=None,):
    self.auth = auth
    self.labelId = labelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.labelId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteLabel_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.labelId is not None:
      oprot.writeFieldBegin('labelId', TType.I64, 2)
      oprot.writeI64(self.labelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.labelId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteLabel_result:
  """
  Attributes:
   - ke
   - ae
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, ke=None, ae=None,):
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteLabel_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateLabel_args:
  """
  Attributes:
   - auth
   - label
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'label', (koverse.thriftgen.ttypes.TLabel, koverse.thriftgen.ttypes.TLabel.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, label=None,):
    self.auth = auth
    self.label = label

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.label = koverse.thriftgen.ttypes.TLabel()
          self.label.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateLabel_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.label is not None:
      oprot.writeFieldBegin('label', TType.STRUCT, 2)
      self.label.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.label)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateLabel_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (koverse.thriftgen.ttypes.TLabel, koverse.thriftgen.ttypes.TLabel.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = koverse.thriftgen.ttypes.TLabel()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateLabel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLabelAssignment_args:
  """
  Attributes:
   - auth
   - labelId
   - dataSetId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I64, 'labelId', None, None, ), # 2
    (3, TType.STRING, 'dataSetId', None, None, ), # 3
  )

  def __init__(self, auth=None, labelId=None, dataSetId=None,):
    self.auth = auth
    self.labelId = labelId
    self.dataSetId = dataSetId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.labelId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dataSetId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLabelAssignment_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.labelId is not None:
      oprot.writeFieldBegin('labelId', TType.I64, 2)
      oprot.writeI64(self.labelId)
      oprot.writeFieldEnd()
    if self.dataSetId is not None:
      oprot.writeFieldBegin('dataSetId', TType.STRING, 3)
      oprot.writeString(self.dataSetId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.labelId)
    value = (value * 31) ^ hash(self.dataSetId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLabelAssignment_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TLabelAssignment, TLabelAssignment.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TLabelAssignment()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLabelAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLabelAssignments_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLabelAssignments_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLabelAssignments_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TLabelAssignment, TLabelAssignment.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype234, _size231) = iprot.readListBegin()
          for _i235 in xrange(_size231):
            _elem236 = TLabelAssignment()
            _elem236.read(iprot)
            self.success.append(_elem236)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLabelAssignments_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter237 in self.success:
        iter237.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLabelAssigmentById_args:
  """
  Attributes:
   - auth
   - labelAssignmentId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I64, 'labelAssignmentId', None, None, ), # 2
  )

  def __init__(self, auth=None, labelAssignmentId=None,):
    self.auth = auth
    self.labelAssignmentId = labelAssignmentId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.labelAssignmentId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLabelAssigmentById_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.labelAssignmentId is not None:
      oprot.writeFieldBegin('labelAssignmentId', TType.I64, 2)
      oprot.writeI64(self.labelAssignmentId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.labelAssignmentId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLabelAssigmentById_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TLabelAssignment, TLabelAssignment.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TLabelAssignment()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLabelAssigmentById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteLabelAssignment_args:
  """
  Attributes:
   - auth
   - labelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I64, 'labelId', None, None, ), # 2
  )

  def __init__(self, auth=None, labelId=None,):
    self.auth = auth
    self.labelId = labelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.labelId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteLabelAssignment_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.labelId is not None:
      oprot.writeFieldBegin('labelId', TType.I64, 2)
      oprot.writeI64(self.labelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.labelId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteLabelAssignment_result:
  """
  Attributes:
   - ke
   - ae
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, ke=None, ae=None,):
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteLabelAssignment_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataSetPermissions_args:
  """
  Attributes:
   - auth
   - dataSetId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dataSetId', None, None, ), # 2
  )

  def __init__(self, auth=None, dataSetId=None,):
    self.auth = auth
    self.dataSetId = dataSetId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dataSetId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataSetPermissions_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.dataSetId is not None:
      oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
      oprot.writeString(self.dataSetId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.dataSetId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataSetPermissions_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollectionGroupPermission, TCollectionGroupPermission.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype241, _size238) = iprot.readListBegin()
          for _i242 in xrange(_size238):
            _elem243 = TCollectionGroupPermission()
            _elem243.read(iprot)
            self.success.append(_elem243)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataSetPermissions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter244 in self.success:
        iter244.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createDataSetPermission_args:
  """
  Attributes:
   - auth
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'permission', (TCollectionGroupPermission, TCollectionGroupPermission.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, permission=None,):
    self.auth = auth
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.permission = TCollectionGroupPermission()
          self.permission.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createDataSetPermission_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.STRUCT, 2)
      self.permission.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.permission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createDataSetPermission_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollectionGroupPermission, TCollectionGroupPermission.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollectionGroupPermission()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createDataSetPermission_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateDataSetPermission_args:
  """
  Attributes:
   - auth
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'permission', (TCollectionGroupPermission, TCollectionGroupPermission.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, permission=None,):
    self.auth = auth
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.permission = TCollectionGroupPermission()
          self.permission.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateDataSetPermission_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.STRUCT, 2)
      self.permission.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.permission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateDataSetPermission_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollectionGroupPermission, TCollectionGroupPermission.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollectionGroupPermission()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateDataSetPermission_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteDataSetPermission_args:
  """
  Attributes:
   - auth
   - permissionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I64, 'permissionId', None, None, ), # 2
  )

  def __init__(self, auth=None, permissionId=None,):
    self.auth = auth
    self.permissionId = permissionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.permissionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteDataSetPermission_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.permissionId is not None:
      oprot.writeFieldBegin('permissionId', TType.I64, 2)
      oprot.writeI64(self.permissionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.permissionId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteDataSetPermission_result:
  """
  Attributes:
   - ke
   - ae
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, ke=None, ae=None,):
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteDataSetPermission_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIndexingPolicy_args:
  """
  Attributes:
   - auth
   - dataSetId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dataSetId', None, None, ), # 2
  )

  def __init__(self, auth=None, dataSetId=None,):
    self.auth = auth
    self.dataSetId = dataSetId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dataSetId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIndexingPolicy_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.dataSetId is not None:
      oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
      oprot.writeString(self.dataSetId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.dataSetId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIndexingPolicy_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TIndexingPolicy, TIndexingPolicy.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TIndexingPolicy()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIndexingPolicy_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateIndexingPolicy_args:
  """
  Attributes:
   - auth
   - indexingPolicy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'indexingPolicy', (TIndexingPolicy, TIndexingPolicy.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, indexingPolicy=None,):
    self.auth = auth
    self.indexingPolicy = indexingPolicy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.indexingPolicy = TIndexingPolicy()
          self.indexingPolicy.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateIndexingPolicy_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.indexingPolicy is not None:
      oprot.writeFieldBegin('indexingPolicy', TType.STRUCT, 2)
      self.indexingPolicy.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.indexingPolicy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateIndexingPolicy_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TIndexingPolicy, TIndexingPolicy.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TIndexingPolicy()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateIndexingPolicy_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateMaskedAttributes_args:
  """
  Attributes:
   - auth
   - attributes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'attributes', (TMaskedAttributes, TMaskedAttributes.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, attributes=None,):
    self.auth = auth
    self.attributes = attributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.attributes = TMaskedAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateMaskedAttributes_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 2)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.attributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateMaskedAttributes_result:
  """
  Attributes:
   - success
   - ke
   - ae
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TDataSetAttribute, TDataSetAttribute.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ke=None, ae=None,):
    self.success = success
    self.ke = ke
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype248, _size245) = iprot.readListBegin()
          for _i249 in xrange(_size245):
            _elem250 = TDataSetAttribute()
            _elem250.read(iprot)
            self.success.append(_elem250)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateMaskedAttributes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter251 in self.success:
        iter251.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class registerTable_args:
  """
  Attributes:
   - auth
   - dataSetId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dataSetId', None, None, ), # 2
  )

  def __init__(self, auth=None, dataSetId=None,):
    self.auth = auth
    self.dataSetId = dataSetId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dataSetId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerTable_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.dataSetId is not None:
      oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
      oprot.writeString(self.dataSetId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.dataSetId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class registerTable_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('registerTable_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unregisterTable_args:
  """
  Attributes:
   - auth
   - dataSetId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dataSetId', None, None, ), # 2
  )

  def __init__(self, auth=None, dataSetId=None,):
    self.auth = auth
    self.dataSetId = dataSetId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dataSetId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unregisterTable_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.dataSetId is not None:
      oprot.writeFieldBegin('dataSetId', TType.STRING, 2)
      oprot.writeString(self.dataSetId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.auth)
    value = (value * 31) ^ hash(self.dataSetId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unregisterTable_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unregisterTable_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ke)
    value = (value * 31) ^ hash(self.ae)
    value = (value * 31) ^ hash(self.ce)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
