
<html><head></head><body><h1 id="main-frontend-tecnologies">Main Frontend Tecnologies</h1>
<hr />
<p>The main tecnologies used on the mapstore 2 are:</p>
<ul>
<li>ReactJS (View)</li>
<li>Redux (state management)</li>
</ul>
<h2 id="reactjs">ReactJS</h2>
<p><a href="https://facebook.github.io/react/index.html">ReactJS</a> 0.15.x is used to develop MapStore2. The main purpose of ReactJS is to allow writing the <strong>View</strong> of the application, through the composition of <em>small components</em>, in a <em>declarative way</em>.</p>
<p>Components are written using a "templating" language, called <a href="https://react-bootstrap.github.io/introduction.html"><strong>JSX</strong></a>, that is a sort of composition of HTML and Javascript code. The difference between JSX and older approaches like <em>JSP</em> is that JSX templates are mixed with Javascript code inside javascript files.</p>
<h2 id="reactjs-component-example">ReactJS component example</h2>
<p>Component definition:</p>
<pre><code class="lang-javascript">class MyComponent extends React.Component {
   render() {
       return &lt;h1&gt;{this.props.title}&lt;/h1&gt;;
   }
}
</code></pre>
<p>Component usage:</p>
<pre><code class="lang-javascript">React.render(&lt;MyComponent title="My title"/&gt;, document.body);
</code></pre>
<h3 id="properties-state-and-event-handlers">Properties, State and Event handlers</h3>
<p>Components can define and use <strong>properties</strong>, like the title one used in the example. These are immutable, and cannot be changed by component's code.</p>
<p>Components can also use <strong>state</strong> that can change. When the state changes, the component is updated (re-rendered) automatically.</p>
<pre><code class="lang-javascript">class MyComponent extends React.Component {
   state = {
      return {
         title: 'CHANGE_ME'
      };
   };
   changeTitle = () =&gt; {
      this.setState({
         title: 'CHANGED'
      });
   };
   render() {
       return &lt;h1 onClick={this.changeTitle}&gt;{this.state.title}&lt;/h1&gt;;
   }
}
</code></pre>
<p>In this example, the initial state includes a title property whose value is <code>CHANGE_ME</code>.</p>
<p>When the h1 element is clicked, the state is changed so that title becomes <code>CHANGED</code>.</p>
<p>The HTML page is automatically updated by ReactJS, each time the state changes (each time this.setState is called). For this reason we say that JSX allows to declaratively describe the View for each possible application state.</p>
<h2 id="lifecycle-hooks">Lifecycle hooks</h2>
<p>Components can re-define some <a href="https://facebook.github.io/react/docs/component-specs.html">lifecycle methods</a>, to execute actions in certain moments of the component life.</p>
<pre><code class="lang-javascript">class MyComponent extends React.Component {
   ...
   componentWillMount() {
       console.log('not mounted yet');
   }
   componentDidMount() {
       const domElement = React.findDOMNode(this);
       console.log('DOM mounted');
   }
   ...
}
</code></pre>
<h1 id="redux">Redux</h1>
<hr />
<p><a href="http://redux.js.org/index.html">Redux</a>, and its companion <a href="https://github.com/reactjs/react-redux">react-redux</a> are used to handle the application state and bind it to ReactJS components.</p>
<p>Redux promotes a unidirectional dataflow (inspired by the <a href="https://facebook.github.io/flux/">Flux</a> architecture) and immutable state transformation using reducers, to achieve predictable and reproducable application behaviour.</p>
<p>A single, global, <strong>Store</strong> is delegated to contain all the application state.</p>
<p>The state can be changed dispatching <strong>Actions</strong> to the store.</p>
<p>Each action produces a new state (the state is never changed, a new state is produced and that is the new application state), through the usage of one or more <strong>reducers</strong>.</p>
<p><strong>(Smart) Components</strong> can be connected to the store and be notified when the state changes, so that views are automatically updated.</p>
<h2 id="actions">Actions</h2>
<p>In Redux, actions are actions descriptors, generated by an action creator. Actions descriptors are usually defined by an <strong>action type</strong> and a set of parameters that specify the action payload.</p>
<pre><code class="lang-javascript">const CHANGE_TITLE= 'CHANGE_TITLE';

// action creator
function changeTitle(newTitle) {
    return {
        type: CHANGE_TITLE,
        title: newTitle
    };
}
</code></pre>
<h2 id="reducers">Reducers</h2>
<p>Reducers are functions that receive an action and the current state and:</p>
<ul>
<li>produce a new state, for each recognized action</li>
<li>produce the current state for unrecognized actions</li>
<li>produce initial state, if the current state is undefined</li>
</ul>
<pre><code class="lang-javascript">function reducer(state = {title: "CHANGE_ME"}, action) {
    switch (action.type) {
        case CHANGE_TITLE:
            return {title: action.title};
        default:
            return state;
    }
}
</code></pre>
<h2 id="store">Store</h2>
<p>The redux store combines different reducers to produce a global state, with a slice for each used reducer.</p>
<pre><code class="lang-javascript">var rootReducer = combineReducers({
   slice1: reducer1,
   slice2: reducer2
});
var initialState = {slice1: {}, slice2: {}};

var store = createStore(rootReducer, initialState);
</code></pre>
<p>The Redux store receives actions, through a dispatch method, and creates a new application state, using the configured reducers.</p>
<pre><code class="lang-javascript">store.dispatch(changeTitle('New title'));
</code></pre>
<p>You can subscribe to the store, to be notified whenever the state changes.</p>
<pre><code class="lang-javascript">store.subscribe(function handleChange() {});
</code></pre>
<h2 id="redux-middlewares">Redux Middlewares</h2>
<p>Redux data flow is synchronous. To provide asynchronous functionalities (e.g. Ajax) redux needs a <a href="http://redux.js.org/docs/advanced/Middleware.html">middleware</a>. Actually MapStore 2 uses 2 middlewares for this purpose:</p>
<ul>
<li>Redux thunk (going to be fully replaced by redux-observable)</li>
<li>Redux Observable</li>
</ul>
<h3 id="redux-thunk">Redux thunk</h3>
<p>This middleware allows to perform simple asynchronous flows by returning a function from the action creator (instead of a action object).</p>
<pre><code class="lang-javascript">// action creator
function changeTitleAsync() {
    return (dispatch, getState) =&gt; {
        myAsyncPromise.then( (newTitle) =&gt; {
            dispatch({
                type: CHANGE_TITLE,
                title: newTitle
            };)
        });
    }
}
</code></pre>
<p>This middleware is there from the beginning of the MapStore 2 history. During the years, some better middlewares have been developed for this purpose. We want to replace it in the future with redux-observable.</p>
<h3 id="redux-observable-and-epics">Redux Observable and epics</h3>
<p>This middleware provides support for side-effects in MapStore 2 using rxjs. The core object of this middleware is the <code>epic</code></p>
<pre><code class="lang-javascript">function (action$: Observable&lt;Action&gt;, store: Store): Observable&lt;Action&gt;;
</code></pre>
<p>The epic is a function that simply gets as first parameter an <code>Observable</code> (stream) emitting the actions emitted by redux. It returns another <code>Observable</code> (stream) that emits actions that will be forwarded to redux too.</p>
<p>So there are 2 streams:</p>
<ul>
<li>Actions in</li>
<li>Actions out</li>
</ul>
<p>A simple epic example can be the following:</p>
<pre><code class="lang-javascript">const pingEpic = action$ =&gt;
  action$.filter(action =&gt; action.type === 'PING')
    .mapTo({ type: 'PONG' });
</code></pre>
<p>Every time a 'PING' action is emitted, the epic will emit also the 'PONG' action.</p>
<p>See :</p>
<ul>
<li><a href="https://docs.google.com/presentation/d/1Ts-yZGc12VMr9oG8xMqwptUmMjdsKI2uZh4Mr5shYhA/edit?usp=sharing">Introduction to RxJS for MapStore Developers</a></li>
<li><a href="https://redux-observable.js.org/">redux-observable site</a></li>
<li><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html">rxjs Observable</a> as a reference for methods</li>
<li><a href="https://redux-observable.js.org/docs/basics/SettingUpTheMiddleware.html">setting up the middleware</a> to integrate epics with your store</li>
</ul>
<h1 id="redux-and-reactjs-integration">Redux and ReactJS integration</h1>
<hr />
<p>The <strong>react-redux</strong> library can be used to connect the Redux application state to ReactJS components.</p>
<p>This can be done in the following way:</p>
<ul>
<li>wrap the ReactJS root component with the react-redux <strong>Provider</strong> component, to bind the Redux store to the ReactJS view</li>
</ul>
<pre><code class="lang-javascript">React.render(
    &lt;Provider store={store}&gt;
        {() =&gt; &lt;App /&gt;}
    &lt;/Provider&gt;,
    document.getElementById('container')
);
</code></pre>
<ul>
<li>explicitly connect one or more (smart) components to a all or part of the state (you can also transform the state and have computed properties)</li>
</ul>
<pre><code class="lang-javascript">connect(function(state) {
    return {
        title: state.title,
        name: state.namespace + '.' + state.name,
    };
})(App);
</code></pre>
<p>The connected component will get automatic access to the configured slice through properties:</p>
<pre><code class="lang-javascript">function render() {
   return &lt;div&gt;&lt;h1&gt;{this.props.title}&lt;/h1&gt;&lt;p&gt;{this.props.name}&lt;/p&gt;&lt;/div);
}
</code></pre>
</body></html>